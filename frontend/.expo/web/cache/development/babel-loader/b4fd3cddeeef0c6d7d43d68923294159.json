{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport { AsyncStorage } from \"react-native-web/dist/index\";\nimport * as FileSystem from 'expo-file-system';\nimport pMap from 'p-map';\nimport { getRandomString } from \"./random-string\";\nimport { extractExtname } from \"./extract-extname\";\nimport { getAuthorizationHeader } from \"../../ky\";\nvar LOCAL_URI_ROOT = FileSystem.documentDirectory;\nvar imageCache = new Map();\n\nfunction cache(externalUrl) {\n  var cacheTargetUri, authorizationHeader, downloadOptions;\n  return _regeneratorRuntime.async(function cache$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          cacheTargetUri = LOCAL_URI_ROOT + getRandomString() + extractExtname(externalUrl);\n          _context.next = 3;\n          return _regeneratorRuntime.awrap(getAuthorizationHeader());\n\n        case 3:\n          authorizationHeader = _context.sent;\n          downloadOptions = authorizationHeader ? {\n            headers: {\n              Authorization: authorizationHeader\n            }\n          } : undefined;\n          _context.next = 7;\n          return _regeneratorRuntime.awrap(FileSystem.downloadAsync(externalUrl, cacheTargetUri, downloadOptions));\n\n        case 7:\n          if (!imageCache.has(externalUrl)) {\n            _context.next = 10;\n            break;\n          }\n\n          _context.next = 10;\n          return _regeneratorRuntime.awrap(FileSystem.deleteAsync(imageCache.get(externalUrl), {\n            idempotent: true\n          }));\n\n        case 10:\n          imageCache.set(externalUrl, cacheTargetUri);\n          console.log(\"Successfully cached \\\"\" + externalUrl + \"\\\"\");\n\n        case 12:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\n\nexport function cacheMany(externalUrls, concurrency) {\n  return _regeneratorRuntime.async(function cacheMany$(_context3) {\n    while (1) {\n      switch (_context3.prev = _context3.next) {\n        case 0:\n          _context3.next = 2;\n          return _regeneratorRuntime.awrap(loadFromAsyncStorageIfPresent());\n\n        case 2:\n          _context3.next = 4;\n          return _regeneratorRuntime.awrap(pMap(externalUrls, function _callee(url) {\n            return _regeneratorRuntime.async(function _callee$(_context2) {\n              while (1) {\n                switch (_context2.prev = _context2.next) {\n                  case 0:\n                    return _context2.abrupt(\"return\", cache(url));\n\n                  case 1:\n                  case \"end\":\n                    return _context2.stop();\n                }\n              }\n            }, null, null, null, Promise);\n          }, {\n            concurrency: concurrency\n          }));\n\n        case 4:\n          _context3.next = 6;\n          return _regeneratorRuntime.awrap(saveIntoAsyncStorage());\n\n        case 6:\n        case \"end\":\n          return _context3.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function getCached(externalUrl) {\n  return imageCache.get(externalUrl);\n}\nvar SERIALIZATION_PREFIX = '##CACHE_MAP_V1_SERIALIZATION_PREFIX##';\n\nfunction serializeCacheMap() {\n  return \"\" + SERIALIZATION_PREFIX + JSON.stringify(_toConsumableArray(imageCache.entries()));\n}\n\nfunction deserializeCacheMap(serialized) {\n  if (!serialized.startsWith(SERIALIZATION_PREFIX)) {\n    throw new Error(\"Invalid serialized cache map: \" + JSON.stringify(serialized));\n  }\n\n  var payload = serialized.slice(SERIALIZATION_PREFIX.length);\n  return new Map(JSON.parse(payload));\n}\n\nvar CACHE_KEY_FOR_ASYNC_STORAGE = '##CACHE_MAP_V1_KEY_FOR_ASYNC_STORAGE##';\nexport function loadFromAsyncStorageIfPresent() {\n  var serialized;\n  return _regeneratorRuntime.async(function loadFromAsyncStorageIfPresent$(_context4) {\n    while (1) {\n      switch (_context4.prev = _context4.next) {\n        case 0:\n          _context4.next = 2;\n          return _regeneratorRuntime.awrap(AsyncStorage.getItem(CACHE_KEY_FOR_ASYNC_STORAGE));\n\n        case 2:\n          serialized = _context4.sent;\n          if (serialized) imageCache = deserializeCacheMap(serialized);\n\n        case 4:\n        case \"end\":\n          return _context4.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function saveIntoAsyncStorage() {\n  return _regeneratorRuntime.async(function saveIntoAsyncStorage$(_context5) {\n    while (1) {\n      switch (_context5.prev = _context5.next) {\n        case 0:\n          _context5.next = 2;\n          return _regeneratorRuntime.awrap(AsyncStorage.setItem(CACHE_KEY_FOR_ASYNC_STORAGE, serializeCacheMap()));\n\n        case 2:\n        case \"end\":\n          return _context5.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}","map":{"version":3,"sources":["/home/jmgoncalves/git/agro-x/frontend/src/network/helpers/cache-images/index.ts"],"names":["AsyncStorage","FileSystem","pMap","getRandomString","extractExtname","getAuthorizationHeader","LOCAL_URI_ROOT","documentDirectory","imageCache","Map","cache","externalUrl","cacheTargetUri","authorizationHeader","downloadOptions","headers","Authorization","undefined","downloadAsync","has","deleteAsync","get","idempotent","set","console","log","cacheMany","externalUrls","concurrency","loadFromAsyncStorageIfPresent","url","saveIntoAsyncStorage","getCached","SERIALIZATION_PREFIX","serializeCacheMap","JSON","stringify","entries","deserializeCacheMap","serialized","startsWith","Error","payload","slice","length","parse","CACHE_KEY_FOR_ASYNC_STORAGE","getItem","setItem"],"mappings":"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","sourcesContent":["import { AsyncStorage } from 'react-native';\nimport * as FileSystem from 'expo-file-system';\nimport pMap from 'p-map';\nimport { getRandomString } from './random-string';\nimport { extractExtname } from './extract-extname';\nimport { getAuthorizationHeader } from '../../ky';\n\nconst LOCAL_URI_ROOT = FileSystem.documentDirectory!;\n\nlet imageCache = new Map<string, string>(); // Maps external URLs into local URIs\n\nasync function cache(externalUrl: string): Promise<void> {\n\tconst cacheTargetUri = LOCAL_URI_ROOT + getRandomString() + extractExtname(externalUrl);\n\tconst authorizationHeader = await getAuthorizationHeader();\n\tconst downloadOptions = authorizationHeader ? { headers: { Authorization: authorizationHeader } } : undefined;\n\n\tawait FileSystem.downloadAsync(externalUrl, cacheTargetUri, downloadOptions); // This overwrites if exists\n\n\tif (imageCache.has(externalUrl)) {\n\t\tawait FileSystem.deleteAsync(imageCache.get(externalUrl)!, { idempotent: true });\n\t}\n\n\timageCache.set(externalUrl, cacheTargetUri);\n\n\tconsole.log(`Successfully cached \"${externalUrl}\"`);\n\n\t// return cacheTargetUri;\n}\n\nexport async function cacheMany(externalUrls: string[], concurrency: number): Promise<void> {\n\tawait loadFromAsyncStorageIfPresent();\n\tawait pMap(externalUrls, async (url: string) => cache(url), { concurrency });\n\tawait saveIntoAsyncStorage();\n}\n\nexport function getCached(externalUrl: string): string | undefined {\n\treturn imageCache.get(externalUrl);\n}\n\nconst SERIALIZATION_PREFIX = '##CACHE_MAP_V1_SERIALIZATION_PREFIX##';\n\nfunction serializeCacheMap(): string {\n\treturn `${SERIALIZATION_PREFIX}${JSON.stringify([...imageCache.entries()])}`;\n}\n\nfunction deserializeCacheMap(serialized: string): Map<string, string> {\n\tif (!serialized.startsWith(SERIALIZATION_PREFIX)) {\n\t\tthrow new Error(`Invalid serialized cache map: ${JSON.stringify(serialized)}`);\n\t}\n\n\tconst payload = serialized.slice(SERIALIZATION_PREFIX.length);\n\n\treturn new Map<string, string>(JSON.parse(payload));\n}\n\nconst CACHE_KEY_FOR_ASYNC_STORAGE = '##CACHE_MAP_V1_KEY_FOR_ASYNC_STORAGE##';\n\nexport async function loadFromAsyncStorageIfPresent(): Promise<void> {\n\tconst serialized = await AsyncStorage.getItem(CACHE_KEY_FOR_ASYNC_STORAGE);\n\tif (serialized) imageCache = deserializeCacheMap(serialized);\n}\n\nexport async function saveIntoAsyncStorage(): Promise<void> {\n\tawait AsyncStorage.setItem(CACHE_KEY_FOR_ASYNC_STORAGE, serializeCacheMap());\n}\n"]},"metadata":{},"sourceType":"module"}