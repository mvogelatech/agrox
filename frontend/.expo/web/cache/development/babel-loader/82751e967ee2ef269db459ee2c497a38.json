{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport rem from \"./replacers/rem\";\nimport vars from \"./replacers/vars\";\nimport percent from \"./replacers/percent\";\nimport operation from \"./replacers/operation\";\nimport scale from \"./replacers/scale\";\n\nvar Value = function () {\n  function Value(value, prop) {\n    var varsArr = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n    _classCallCheck(this, Value);\n\n    this.value = value;\n    this.outValue = null;\n    this.prop = prop;\n    this.varsArr = varsArr;\n    this.stack = options.stack || [];\n    this.isOperation = options.isOperation !== undefined ? options.isOperation : false;\n  }\n\n  _createClass(Value, [{\n    key: \"calc\",\n    value: function calc() {\n      if (typeof this.value === 'function') {\n        this.value = this.value();\n      }\n\n      if (typeof this.value === 'string') {\n        this.calcString();\n      } else {\n        this.proxyValue();\n      }\n\n      if (this.isFinal()) {\n        this.applyScale();\n      }\n\n      return this.outValue;\n    }\n  }, {\n    key: \"calcString\",\n    value: function calcString() {\n      var actions = [this.tryCalcOperation, this.isOperation ? this.tryCalcPercent : null, this.tryCalcVar, this.tryCalcRem].filter(Boolean);\n      var value = this.tryActions(actions, this.value);\n\n      if (value !== null) {\n        this.outValue = value;\n      } else {\n        this.proxyValue();\n      }\n    }\n  }, {\n    key: \"tryActions\",\n    value: function tryActions(actions, str) {\n      for (var i = 0; i < actions.length; i++) {\n        var val = actions[i].call(this, str);\n\n        if (val !== null) {\n          return val;\n        }\n      }\n\n      return null;\n    }\n  }, {\n    key: \"tryCalcOperation\",\n    value: function tryCalcOperation(str) {\n      var opInfo = operation.isOperation(str);\n\n      if (!opInfo) {\n        return null;\n      }\n\n      this.isOperation = true;\n      var operands = ['v1', 'v2'];\n\n      for (var i = 0; i < operands.length; i++) {\n        var operand = operands[i];\n        var operandValue = this.calcOperandValue(opInfo[operand]);\n\n        if (operandValue !== null) {\n          opInfo[operand] = operandValue;\n        } else {\n          return null;\n        }\n      }\n\n      return operation.exec(opInfo);\n    }\n  }, {\n    key: \"calcOperandValue\",\n    value: function calcOperandValue(str) {\n      var actions = [this.tryCalcVar, this.tryCalcPercent, this.tryCalcRem, this.tryCalcFloat];\n      return this.tryActions(actions, str);\n    }\n  }, {\n    key: \"tryCalcVar\",\n    value: function tryCalcVar(str) {\n      if (vars.isVar(str)) {\n        var val = vars.calc(str, this.varsArr);\n\n        if (this.stack.indexOf(str) >= 0) {\n          throw new Error('Cyclic reference: ' + this.stack.concat([str]).join(' -> '));\n        }\n\n        var options = {\n          stack: this.stack.concat([str]),\n          isOperation: this.isOperation\n        };\n        return new Value(val, str, this.varsArr, options).calc();\n      } else {\n        return null;\n      }\n    }\n  }, {\n    key: \"tryCalcPercent\",\n    value: function tryCalcPercent(str) {\n      if (percent.isPercent(str)) {\n        return percent.calc(str, this.prop);\n      }\n\n      return null;\n    }\n  }, {\n    key: \"tryCalcRem\",\n    value: function tryCalcRem(str) {\n      if (rem.isRem(str)) {\n        var remValue = vars.get('$rem', this.varsArr);\n        return rem.calc(str, remValue);\n      } else {\n        return null;\n      }\n    }\n  }, {\n    key: \"tryCalcFloat\",\n    value: function tryCalcFloat(str) {\n      var val = parseFloat(str);\n      return !isNaN(val) ? val : null;\n    }\n  }, {\n    key: \"isFinal\",\n    value: function isFinal() {\n      return !this.stack.length;\n    }\n  }, {\n    key: \"proxyValue\",\n    value: function proxyValue() {\n      this.outValue = this.value;\n    }\n  }, {\n    key: \"applyScale\",\n    value: function applyScale() {\n      if (vars.isVar(this.prop)) {\n        return;\n      }\n\n      var scaleFactor = vars.get('$scale', this.varsArr) || 1;\n\n      if (scaleFactor === 1) {\n        return;\n      }\n\n      if (scale.isScalable(this.outValue, this.prop)) {\n        this.outValue = scale.calc(this.outValue, scaleFactor);\n      }\n    }\n  }]);\n\n  return Value;\n}();\n\nexport { Value as default };","map":{"version":3,"sources":["/home/jmgoncalves/git/agro-x/frontend/node_modules/react-native-extended-stylesheet/src/value.js"],"names":["rem","vars","percent","operation","scale","Value","value","prop","varsArr","options","outValue","stack","isOperation","undefined","calcString","proxyValue","isFinal","applyScale","actions","tryCalcOperation","tryCalcPercent","tryCalcVar","tryCalcRem","filter","Boolean","tryActions","str","i","length","val","call","opInfo","operands","operand","operandValue","calcOperandValue","exec","tryCalcFloat","isVar","calc","indexOf","Error","concat","join","isPercent","isRem","remValue","get","parseFloat","isNaN","scaleFactor","isScalable"],"mappings":"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","sourcesContent":["/**\n * Calculates particular value\n */\n\nimport rem from './replacers/rem';\nimport vars from './replacers/vars';\nimport percent from './replacers/percent';\nimport operation from './replacers/operation';\nimport scale from './replacers/scale';\n\nexport default class Value {\n  /**\n   * Constructor\n   *\n   * @param {*} value\n   * @param {String} prop property for which valye is calculated\n   * @param {Array} varsArr array of objects with vars\n   * @param {Object} [options]\n   * @param {Array} [options.stack] stack of calls when resolving variable\n   * @param {Boolean} [options.isOperation] is value calculated inside operation\n   */\n  constructor(value, prop, varsArr = [], options = {}) {\n    this.value = value;\n    this.outValue = null;\n    this.prop = prop;\n    this.varsArr = varsArr;\n    this.stack = options.stack || [];\n    this.isOperation = options.isOperation !== undefined ? options.isOperation : false;\n  }\n\n  /**\n   * Calculates value:\n   * execute function, resolve var refs, convert string of (rem, percent) to pixels\n   */\n  calc() {\n    if (typeof this.value === 'function') {\n      this.value = this.value();\n    }\n\n    if (typeof this.value === 'string') {\n      this.calcString();\n    } else {\n      this.proxyValue();\n    }\n\n    if (this.isFinal()) {\n      this.applyScale();\n    }\n\n    return this.outValue;\n  }\n\n  /**\n   * Calculates string\n   * Here we do not calc direct percent values as they supported natively since RN 43 (#32).\n   * But keep calculating percent for operands when value defined as operation.\n   */\n  calcString() {\n    let actions = [\n      this.tryCalcOperation,\n      this.isOperation ? this.tryCalcPercent : null,\n      this.tryCalcVar,\n      this.tryCalcRem,\n    ].filter(Boolean);\n    let value = this.tryActions(actions, this.value);\n    if (value !== null) {\n      this.outValue = value;\n    } else {\n      this.proxyValue();\n    }\n  }\n\n  /**\n   * Applies array of calculations to value. Stops on the first calculation that returns not null.\n   * @param {Array} actions\n   * @param {String} str\n   */\n  tryActions(actions, str) {\n    // todo: use for.. of after https://github.com/facebook/react-native/issues/4676\n    for (let i = 0; i < actions.length; i++) {\n      let val = actions[i].call(this, str);\n      if (val !== null) {\n        return val;\n      }\n    }\n    return null;\n  }\n\n  tryCalcOperation(str) {\n    let opInfo = operation.isOperation(str);\n    if (!opInfo) {\n      return null;\n    }\n    this.isOperation = true;\n    // todo: use for.. of after https://github.com/facebook/react-native/issues/4676\n    const operands = ['v1', 'v2'];\n    for (let i = 0; i < operands.length; i++) {\n      const operand = operands[i];\n      const operandValue = this.calcOperandValue(opInfo[operand]);\n      if (operandValue !== null) {\n        opInfo[operand] = operandValue;\n      } else {\n        // if we cant calculate operand - it is not operation, see #3\n        return null;\n      }\n    }\n    return operation.exec(opInfo);\n  }\n\n  calcOperandValue(str) {\n    let actions = [\n      this.tryCalcVar,\n      this.tryCalcPercent,\n      this.tryCalcRem,\n      this.tryCalcFloat,\n    ];\n    return this.tryActions(actions, str);\n  }\n\n  tryCalcVar(str) {\n    if (vars.isVar(str)) {\n      let val = vars.calc(str, this.varsArr);\n      if (this.stack.indexOf(str) >= 0) {\n        throw new Error('Cyclic reference: ' + this.stack.concat([str]).join(' -> '));\n      }\n      const options = {\n        stack: this.stack.concat([str]),\n        isOperation: this.isOperation,\n      };\n      // recursive call because var can link to another var or percent/rem\n      return new Value(val, str, this.varsArr, options).calc();\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * Tries calc percent\n   */\n  tryCalcPercent(str) {\n    if (percent.isPercent(str)) {\n      return percent.calc(str, this.prop);\n    }\n    return null;\n  }\n\n  /**\n   * Tries calc rem\n   */\n  tryCalcRem(str) {\n    if (rem.isRem(str)) {\n      let remValue = vars.get('$rem', this.varsArr);\n      return rem.calc(str, remValue);\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * Tries calc float value from string\n   */\n  tryCalcFloat(str) {\n    let val = parseFloat(str);\n    return !isNaN(val) ? val : null;\n  }\n\n  /**\n   * Is it final calculation (not recursion)\n   */\n  isFinal() {\n    return !this.stack.length;\n  }\n\n  /**\n   * Just proxies value when no processing needed\n   */\n  proxyValue() {\n    this.outValue = this.value;\n  }\n\n  applyScale() {\n    // do not apply scale to variables, only for final numbers\n    // otherwise scale will be applied several times\n    if (vars.isVar(this.prop)) {\n      return;\n    }\n    let scaleFactor = vars.get('$scale', this.varsArr) || 1;\n    if (scaleFactor === 1) {\n      return;\n    }\n    if (scale.isScalable(this.outValue, this.prop)) {\n      this.outValue = scale.calc(this.outValue, scaleFactor);\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}