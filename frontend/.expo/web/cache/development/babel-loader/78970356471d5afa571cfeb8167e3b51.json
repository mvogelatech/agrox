{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } it = o[Symbol.iterator](); return it.next.bind(it); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nimport Dimensions from \"react-native-web/dist/exports/Dimensions\";\nimport { REM_SCALE } from \"../../../src/utils\";\nvar WINDOW_WIDTH_PX = Dimensions.get('window').width;\nvar WINDOW_HEIGHT_PX = Dimensions.get('window').height;\n\nfunction toPaddingPx(padding) {\n  if (typeof padding === 'number') {\n    return {\n      topPx: REM_SCALE * padding,\n      leftPx: REM_SCALE * padding,\n      bottomPx: REM_SCALE * padding,\n      rightPx: REM_SCALE * padding\n    };\n  }\n\n  return {\n    topPx: REM_SCALE * padding.top,\n    leftPx: REM_SCALE * padding.left,\n    bottomPx: REM_SCALE * padding.bottom,\n    rightPx: REM_SCALE * padding.right\n  };\n}\n\nvar TILE_SIZE = 256;\nexport function zoomLevelToScale(zoomLevel) {\n  return 1 << zoomLevel;\n}\nexport function geoToWorldCoords(geo) {\n  var siny = Math.sin(geo.latitude * Math.PI / 180);\n  siny = Math.min(Math.max(siny, -0.9999), 0.9999);\n  return {\n    x: TILE_SIZE * (0.5 + geo.longitude / 360),\n    y: TILE_SIZE * (0.5 - Math.log((1 + siny) / (1 - siny)) / (4 * Math.PI))\n  };\n}\nexport function worldCoordsToGeo(world) {\n  var temp = Math.exp(4 * Math.PI * (0.5 - world.y / TILE_SIZE));\n  var siny = (temp - 1) / (temp + 1);\n  return {\n    latitude: 180 * Math.asin(siny) / Math.PI,\n    longitude: 360 * (world.x / TILE_SIZE - 0.5)\n  };\n}\nexport function worldCoordsToTilePixel(world, zoomLevel) {\n  var scale = zoomLevelToScale(zoomLevel);\n  return {\n    pixelX: Math.floor(world.x * scale),\n    pixelY: Math.floor(world.y * scale),\n    tileX: Math.floor(world.x * scale / TILE_SIZE),\n    tileY: Math.floor(world.y * scale / TILE_SIZE)\n  };\n}\nexport function getBoundingBox(points, padding) {\n  if (points.length === 0) {\n    console.warn('Cannot compute a bounding box for an empty array of points. Instead of failing I will return the center of the world...');\n    return [{\n      x: 256 / 4,\n      y: 256 / 4\n    }, {\n      x: 256 / 4 * 3,\n      y: 256 / 4 * 3\n    }];\n  }\n\n  if (points.length === 1) {\n    console.warn('Cannot compute a bounding box of a single point, but I will make a guess.');\n    var point = points[0];\n    return [{\n      x: 0.9 * point.x,\n      y: 0.9 * point.y\n    }, {\n      x: 1.1 * point.x,\n      y: 1.1 * point.y\n    }];\n  }\n\n  if (padding) {\n    var unpaddedBox = getBoundingBox(points);\n    return addRoughPaddingToBoundingBox(unpaddedBox, padding);\n  }\n\n  var minX = Infinity;\n  var maxX = -Infinity;\n  var minY = Infinity;\n  var maxY = -Infinity;\n\n  for (var _iterator = _createForOfIteratorHelperLoose(points), _step; !(_step = _iterator()).done;) {\n    var _point = _step.value;\n    if (_point.x < minX) minX = _point.x;\n    if (_point.x > maxX) maxX = _point.x;\n    if (_point.y < minY) minY = _point.y;\n    if (_point.y > maxY) maxY = _point.y;\n  }\n\n  return [{\n    x: minX,\n    y: minY\n  }, {\n    x: maxX,\n    y: maxY\n  }];\n}\nexport function getCenteredBoundingBox(center, points, padding) {\n  var _getBoundingBox = getBoundingBox(points, padding),\n      _getBoundingBox2 = _slicedToArray(_getBoundingBox, 2),\n      minPointIgnoringCenter = _getBoundingBox2[0],\n      maxPointIgnoringCenter = _getBoundingBox2[1];\n\n  var horizontalDistanceToCenter = Math.max(Math.abs(center.x - minPointIgnoringCenter.x), Math.abs(center.x - maxPointIgnoringCenter.x));\n  var verticalDistanceToCenter = Math.max(Math.abs(center.y - minPointIgnoringCenter.y), Math.abs(center.y - maxPointIgnoringCenter.y));\n  return [{\n    x: center.x - horizontalDistanceToCenter,\n    y: center.y - verticalDistanceToCenter\n  }, {\n    x: center.x + horizontalDistanceToCenter,\n    y: center.y + verticalDistanceToCenter\n  }];\n}\nexport function boundingBoxToRegion(box) {\n  var centerX = (box[0].x + box[1].x) / 2;\n  var centerY = (box[0].y + box[1].y) / 2;\n  var topLeftGeo = worldCoordsToGeo(box[0]);\n  var bottomRightGeo = worldCoordsToGeo(box[1]);\n  var centerGeo = worldCoordsToGeo({\n    x: centerX,\n    y: centerY\n  });\n  return {\n    latitude: centerGeo.latitude,\n    longitude: centerGeo.longitude,\n    latitudeDelta: Math.abs(topLeftGeo.latitude - bottomRightGeo.latitude),\n    longitudeDelta: Math.abs(topLeftGeo.longitude - bottomRightGeo.longitude)\n  };\n}\nexport function boundingBoxContains(box, point) {\n  return box[0].x < point.x && point.x < box[1].x && box[0].y < point.y && point.y < box[1].y;\n}\nexport function getBoundingBoxCenter(box) {\n  return {\n    x: (box[0].x + box[1].x) / 2,\n    y: (box[0].y + box[1].y) / 2\n  };\n}\nexport function cameraToBoundingBox(center, zoomLevel, viewDimensions) {\n  var scale = 1 << zoomLevel;\n  var halfBoxWidth = Math.min(viewDimensions.widthPx / scale, TILE_SIZE) / 2;\n  var halfBoxHeight = Math.min(viewDimensions.heightPx / scale, TILE_SIZE) / 2;\n  var convertedCenter = geoToWorldCoords(center);\n  return [{\n    x: convertedCenter.x - halfBoxWidth,\n    y: convertedCenter.y - halfBoxHeight\n  }, {\n    x: convertedCenter.x + halfBoxWidth,\n    y: convertedCenter.y + halfBoxHeight\n  }];\n}\nexport function boundingBoxToCamera(box, viewDimensions, maxZoomLevel) {\n  var region = boundingBoxToRegion(box);\n  var center = {\n    latitude: region.latitude,\n    longitude: region.longitude\n  };\n  var bestZoomLevel = 0;\n\n  for (var level = 1; level <= maxZoomLevel; level++) {\n    var guessedBox = cameraToBoundingBox(center, level, viewDimensions);\n\n    if (boundingBoxContains(guessedBox, box[0]) && boundingBoxContains(guessedBox, box[1])) {\n      bestZoomLevel = level;\n    } else {\n      break;\n    }\n  }\n\n  return {\n    center: center,\n    zoom: bestZoomLevel\n  };\n}\nexport function cameraToTiles(center, zoomLevel, viewDimensions) {\n  var box = cameraToBoundingBox(center, zoomLevel, viewDimensions);\n  var topLeft = worldCoordsToTilePixel(box[0], zoomLevel);\n  var bottomRight = worldCoordsToTilePixel(box[1], zoomLevel);\n  var tiles = [];\n\n  for (var tileX = topLeft.tileX; tileX <= bottomRight.tileX; tileX++) {\n    for (var tileY = topLeft.tileY; tileY <= bottomRight.tileY; tileY++) {\n      tiles.push({\n        tileX: tileX,\n        tileY: tileY,\n        zoomLevel: zoomLevel\n      });\n    }\n  }\n\n  return tiles;\n}\nexport function worldDistanceToPixels(distance, zoomLevel) {\n  return distance * zoomLevelToScale(zoomLevel);\n}\nexport function pixelsToWorldDistance(pixels, zoomLevel) {\n  return pixels / zoomLevelToScale(zoomLevel);\n}\nexport function addExactPaddingToBoundingBox(box, zoomLevel, padding) {\n  var paddingPx = toPaddingPx(padding);\n  return [{\n    x: box[0].x - pixelsToWorldDistance(paddingPx.leftPx, zoomLevel),\n    y: box[0].y - pixelsToWorldDistance(paddingPx.topPx, zoomLevel)\n  }, {\n    x: box[1].x + pixelsToWorldDistance(paddingPx.rightPx, zoomLevel),\n    y: box[1].y + pixelsToWorldDistance(paddingPx.bottomPx, zoomLevel)\n  }];\n}\nexport function guessCameraZoomForBoundingBox() {\n  return 17;\n}\nexport function addRoughPaddingToBoundingBox(box, paddingPixels) {\n  return addExactPaddingToBoundingBox(box, guessCameraZoomForBoundingBox(), paddingPixels);\n}\nexport function mergeBoundingBoxes(box1, box2) {\n  return [{\n    x: Math.min(box1[0].x, box2[0].x),\n    y: Math.min(box1[0].y, box2[0].y)\n  }, {\n    x: Math.max(box1[1].x, box2[1].x),\n    y: Math.max(box1[1].y, box2[1].y)\n  }];\n}\nvar PIN_PADDING = toPaddingPx({\n  bottom: 16,\n  left: 32,\n  right: 32,\n  top: 88\n});\nexport function addEnoughPaddingToEnsurePinsVisible(box, pins) {\n  if (pins.length === 0) return box;\n  var zoomLevel = guessCameraZoomForBoundingBox();\n  var topPadding = pixelsToWorldDistance(PIN_PADDING.topPx, zoomLevel);\n  var leftPadding = pixelsToWorldDistance(PIN_PADDING.leftPx, zoomLevel);\n  var rightPadding = pixelsToWorldDistance(PIN_PADDING.rightPx, zoomLevel);\n  var uppermostPinYValue = Math.min.apply(Math, _toConsumableArray(pins.map(function (pin) {\n    return pin.y;\n  })));\n  var leftmostPinXValue = Math.min.apply(Math, _toConsumableArray(pins.map(function (pin) {\n    return pin.x;\n  })));\n  var rightmostPinXValue = Math.max.apply(Math, _toConsumableArray(pins.map(function (pin) {\n    return pin.x;\n  })));\n  return [{\n    x: Math.min(box[0].x, leftmostPinXValue - leftPadding),\n    y: Math.min(box[0].y, uppermostPinYValue - topPadding)\n  }, {\n    x: Math.max(box[1].x, rightmostPinXValue + rightPadding),\n    y: box[1].y\n  }];\n}\nexport function safelyPredictTilesForBoundingBox(box) {\n  var mainZoomLevel = guessCameraZoomForBoundingBox();\n  var safeGuessForDimensions = {\n    widthPx: WINDOW_WIDTH_PX * 1.2,\n    heightPx: WINDOW_HEIGHT_PX * 0.9\n  };\n  var center = worldCoordsToGeo(getBoundingBoxCenter(box));\n  var tiles = [];\n\n  for (var zoomLevel = mainZoomLevel - 1; zoomLevel <= mainZoomLevel + 2; zoomLevel++) {\n    tiles = tiles.concat(cameraToTiles(center, zoomLevel, safeGuessForDimensions));\n  }\n\n  return tiles;\n}\nexport function overlayBounding(coordinates) {\n  var topLeftX = Infinity;\n  var bottomRightX = -Infinity;\n  var topLeftY = -Infinity;\n  var bottomRightY = Infinity;\n\n  for (var _iterator2 = _createForOfIteratorHelperLoose(coordinates), _step2; !(_step2 = _iterator2()).done;) {\n    var point = _step2.value;\n    if (point[0] < topLeftX) topLeftX = point[0];\n    if (point[0] > bottomRightX) bottomRightX = point[0];\n    if (point[1] < bottomRightY) bottomRightY = point[1];\n    if (point[1] > topLeftY) topLeftY = point[1];\n  }\n\n  return [[topLeftY, topLeftX], [bottomRightY, bottomRightX]];\n}\nexport function upperCenter(coordinates) {\n  var topLeftX = Infinity;\n  var topLeftY = -Infinity;\n  var topRightX = -Infinity;\n  var topRightY = -Infinity;\n\n  for (var _iterator3 = _createForOfIteratorHelperLoose(coordinates), _step3; !(_step3 = _iterator3()).done;) {\n    var point = _step3.value;\n    topLeftX = Math.min(topLeftX, point[0]);\n    topLeftY = Math.max(topLeftY, point[1]);\n    topRightX = Math.max(topRightX, point[0]);\n    topRightY = Math.max(topRightY, point[1]);\n  }\n\n  return {\n    longitude: (topLeftX + topRightX) / 2,\n    latitude: (topLeftY + topRightY) / 2\n  };\n}\nexport function lowerCenter(coordinates) {\n  var topLeftX = Infinity;\n  var bottomLeftY = Infinity;\n  var topRightX = -Infinity;\n  var bottomRightY = Infinity;\n\n  for (var _iterator4 = _createForOfIteratorHelperLoose(coordinates), _step4; !(_step4 = _iterator4()).done;) {\n    var point = _step4.value;\n    topLeftX = Math.min(topLeftX, point[0]);\n    bottomLeftY = Math.min(bottomLeftY, point[1]);\n    topRightX = Math.max(topRightX, point[0]);\n    bottomRightY = Math.min(bottomRightY, point[1]);\n  }\n\n  return {\n    longitude: (topLeftX + topRightX) / 2,\n    latitude: (bottomLeftY + bottomRightY) / 2\n  };\n}\nexport function center(coordinates) {\n  var up = upperCenter(coordinates);\n  var bottom = lowerCenter(coordinates);\n  return {\n    longitude: (up.longitude + bottom.longitude) / 2,\n    latitude: (up.latitude + bottom.latitude) / 2\n  };\n}","map":{"version":3,"sources":["/home/jmgoncalves/git/agro-x/frontend/components/02-general/map/map-utils.ts"],"names":["REM_SCALE","WINDOW_WIDTH_PX","Dimensions","get","width","WINDOW_HEIGHT_PX","height","toPaddingPx","padding","topPx","leftPx","bottomPx","rightPx","top","left","bottom","right","TILE_SIZE","zoomLevelToScale","zoomLevel","geoToWorldCoords","geo","siny","Math","sin","latitude","PI","min","max","x","longitude","y","log","worldCoordsToGeo","world","temp","exp","asin","worldCoordsToTilePixel","scale","pixelX","floor","pixelY","tileX","tileY","getBoundingBox","points","length","console","warn","point","unpaddedBox","addRoughPaddingToBoundingBox","minX","Infinity","maxX","minY","maxY","getCenteredBoundingBox","center","minPointIgnoringCenter","maxPointIgnoringCenter","horizontalDistanceToCenter","abs","verticalDistanceToCenter","boundingBoxToRegion","box","centerX","centerY","topLeftGeo","bottomRightGeo","centerGeo","latitudeDelta","longitudeDelta","boundingBoxContains","getBoundingBoxCenter","cameraToBoundingBox","viewDimensions","halfBoxWidth","widthPx","halfBoxHeight","heightPx","convertedCenter","boundingBoxToCamera","maxZoomLevel","region","bestZoomLevel","level","guessedBox","zoom","cameraToTiles","topLeft","bottomRight","tiles","push","worldDistanceToPixels","distance","pixelsToWorldDistance","pixels","addExactPaddingToBoundingBox","paddingPx","guessCameraZoomForBoundingBox","paddingPixels","mergeBoundingBoxes","box1","box2","PIN_PADDING","addEnoughPaddingToEnsurePinsVisible","pins","topPadding","leftPadding","rightPadding","uppermostPinYValue","map","pin","leftmostPinXValue","rightmostPinXValue","safelyPredictTilesForBoundingBox","mainZoomLevel","safeGuessForDimensions","concat","overlayBounding","coordinates","topLeftX","bottomRightX","topLeftY","bottomRightY","upperCenter","topRightX","topRightY","lowerCenter","bottomLeftY","up"],"mappings":"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","sourcesContent":["import { Dimensions } from 'react-native';\nimport { REM_SCALE } from '../../../src/utils';\n\nconst WINDOW_WIDTH_PX = Dimensions.get('window').width;\nconst WINDOW_HEIGHT_PX = Dimensions.get('window').height;\n\nexport type LatLng = {\n\tlatitude: number;\n\tlongitude: number;\n};\n\nexport type WorldCoordinate = {\n\tx: number; // 0 to 256\n\ty: number; // 0 to 256\n};\n\nexport type BoundingBox = [WorldCoordinate, WorldCoordinate];\n\nexport type TilePixelCoordinate = {\n\ttileX: number;\n\ttileY: number;\n\tpixelX: number;\n\tpixelY: number;\n};\n\nexport type TileCode = {\n\tzoomLevel: number;\n\ttileX: number;\n\ttileY: number;\n};\n\nexport type Region = {\n\tlatitude: number;\n\tlongitude: number;\n\tlatitudeDelta: number;\n\tlongitudeDelta: number;\n};\n\nexport type MapViewDimensions = {\n\twidthPx: number;\n\theightPx: number;\n};\n\nexport type SimpleCamera = { center: LatLng; zoom: number };\n\nexport type DetailedPaddingRem = {\n\ttop: number;\n\tleft: number;\n\tbottom: number;\n\tright: number;\n};\n\nexport type PaddingRem = number | DetailedPaddingRem;\n\ntype PaddingPx = {\n\ttopPx: number;\n\tleftPx: number;\n\tbottomPx: number;\n\trightPx: number;\n};\n\nfunction toPaddingPx(padding: PaddingRem): PaddingPx {\n\tif (typeof padding === 'number') {\n\t\treturn { topPx: REM_SCALE * padding, leftPx: REM_SCALE * padding, bottomPx: REM_SCALE * padding, rightPx: REM_SCALE * padding };\n\t}\n\n\treturn { topPx: REM_SCALE * padding.top, leftPx: REM_SCALE * padding.left, bottomPx: REM_SCALE * padding.bottom, rightPx: REM_SCALE * padding.right };\n}\n\nconst TILE_SIZE = 256;\n\nexport function zoomLevelToScale(zoomLevel: number): number {\n\treturn 1 << zoomLevel; // Fast way to compute 2 ** Math.floor(zoom)\n}\n\nexport function geoToWorldCoords(geo: LatLng): WorldCoordinate {\n\t// https://developers.google.com/maps/documentation/javascript/examples/map-coordinates?csw=1\n\tlet siny = Math.sin((geo.latitude * Math.PI) / 180);\n\n\t// Truncating to 0.9999 effectively limits latitude to 89.189. This is\n\t// about a third of a tile past the edge of the world tile.\n\tsiny = Math.min(Math.max(siny, -0.9999), 0.9999);\n\n\treturn {\n\t\tx: TILE_SIZE * (0.5 + geo.longitude / 360),\n\t\ty: TILE_SIZE * (0.5 - Math.log((1 + siny) / (1 - siny)) / (4 * Math.PI)),\n\t};\n}\n\nexport function worldCoordsToGeo(world: WorldCoordinate): LatLng {\n\t// Just the mathematical inverse of `geoToWorldCoords` ignoring the sine truncation in (-0.9999, 0.9999).\n\tconst temp = Math.exp(4 * Math.PI * (0.5 - world.y / TILE_SIZE));\n\tconst siny = (temp - 1) / (temp + 1);\n\n\treturn {\n\t\tlatitude: (180 * Math.asin(siny)) / Math.PI,\n\t\tlongitude: 360 * (world.x / TILE_SIZE - 0.5),\n\t};\n}\n\nexport function worldCoordsToTilePixel(world: WorldCoordinate, zoomLevel: number): TilePixelCoordinate {\n\tconst scale = zoomLevelToScale(zoomLevel);\n\n\treturn {\n\t\tpixelX: Math.floor(world.x * scale),\n\t\tpixelY: Math.floor(world.y * scale),\n\t\ttileX: Math.floor((world.x * scale) / TILE_SIZE),\n\t\ttileY: Math.floor((world.y * scale) / TILE_SIZE),\n\t};\n}\n\nexport function getBoundingBox(points: WorldCoordinate[], padding?: PaddingRem): BoundingBox {\n\tif (points.length === 0) {\n\t\tconsole.warn('Cannot compute a bounding box for an empty array of points. Instead of failing I will return the center of the world...');\n\t\treturn [\n\t\t\t{ x: 256 / 4, y: 256 / 4 },\n\t\t\t{ x: (256 / 4) * 3, y: (256 / 4) * 3 },\n\t\t];\n\t}\n\n\tif (points.length === 1) {\n\t\tconsole.warn('Cannot compute a bounding box of a single point, but I will make a guess.');\n\t\tconst point = points[0];\n\t\treturn [\n\t\t\t{ x: 0.9 * point.x, y: 0.9 * point.y },\n\t\t\t{ x: 1.1 * point.x, y: 1.1 * point.y },\n\t\t];\n\t}\n\n\tif (padding) {\n\t\tconst unpaddedBox = getBoundingBox(points);\n\t\treturn addRoughPaddingToBoundingBox(unpaddedBox, padding);\n\t}\n\n\tlet minX = Infinity;\n\tlet maxX = -Infinity;\n\tlet minY = Infinity;\n\tlet maxY = -Infinity;\n\n\tfor (const point of points) {\n\t\tif (point.x < minX) minX = point.x;\n\t\tif (point.x > maxX) maxX = point.x;\n\t\tif (point.y < minY) minY = point.y;\n\t\tif (point.y > maxY) maxY = point.y;\n\t}\n\n\treturn [\n\t\t{ x: minX, y: minY },\n\t\t{ x: maxX, y: maxY },\n\t];\n}\n\nexport function getCenteredBoundingBox(center: WorldCoordinate, points: WorldCoordinate[], padding?: PaddingRem): BoundingBox {\n\tconst [minPointIgnoringCenter, maxPointIgnoringCenter] = getBoundingBox(points, padding);\n\n\t// prettier-ignore\n\tconst horizontalDistanceToCenter = Math.max(\n\t\tMath.abs(center.x - minPointIgnoringCenter.x),\n\t\tMath.abs(center.x - maxPointIgnoringCenter.x),\n\t);\n\n\t// prettier-ignore\n\tconst verticalDistanceToCenter = Math.max(\n\t\tMath.abs(center.y - minPointIgnoringCenter.y),\n\t\tMath.abs(center.y - maxPointIgnoringCenter.y),\n\t);\n\n\treturn [\n\t\t{ x: center.x - horizontalDistanceToCenter, y: center.y - verticalDistanceToCenter },\n\t\t{ x: center.x + horizontalDistanceToCenter, y: center.y + verticalDistanceToCenter },\n\t];\n}\n\nexport function boundingBoxToRegion(box: BoundingBox): Region {\n\t// https://stackoverflow.com/a/36688156/4135063\n\t// In a Region object, the latitude and longitude specify the center location and\n\t// latitudeDelta and longitudeDelta specify the span of the viewable map area.\n\n\tconst centerX = (box[0].x + box[1].x) / 2;\n\tconst centerY = (box[0].y + box[1].y) / 2;\n\n\tconst topLeftGeo = worldCoordsToGeo(box[0]);\n\tconst bottomRightGeo = worldCoordsToGeo(box[1]);\n\tconst centerGeo = worldCoordsToGeo({ x: centerX, y: centerY });\n\n\treturn {\n\t\tlatitude: centerGeo.latitude,\n\t\tlongitude: centerGeo.longitude,\n\t\tlatitudeDelta: Math.abs(topLeftGeo.latitude - bottomRightGeo.latitude),\n\t\tlongitudeDelta: Math.abs(topLeftGeo.longitude - bottomRightGeo.longitude),\n\t};\n}\n\nexport function boundingBoxContains(box: BoundingBox, point: WorldCoordinate): boolean {\n\treturn box[0].x < point.x && point.x < box[1].x && box[0].y < point.y && point.y < box[1].y;\n}\n\nexport function getBoundingBoxCenter(box: BoundingBox): WorldCoordinate {\n\treturn {\n\t\tx: (box[0].x + box[1].x) / 2,\n\t\ty: (box[0].y + box[1].y) / 2,\n\t};\n}\n\nexport function cameraToBoundingBox(center: LatLng, zoomLevel: number, viewDimensions: MapViewDimensions): BoundingBox {\n\tconst scale = 1 << zoomLevel; // Fast way to compute 2 ** Math.floor(zoom)\n\n\tconst halfBoxWidth = Math.min(viewDimensions.widthPx / scale, TILE_SIZE) / 2;\n\tconst halfBoxHeight = Math.min(viewDimensions.heightPx / scale, TILE_SIZE) / 2;\n\tconst convertedCenter = geoToWorldCoords(center);\n\n\treturn [\n\t\t{ x: convertedCenter.x - halfBoxWidth, y: convertedCenter.y - halfBoxHeight },\n\t\t{ x: convertedCenter.x + halfBoxWidth, y: convertedCenter.y + halfBoxHeight },\n\t];\n}\n\nexport function boundingBoxToCamera(box: BoundingBox, viewDimensions: MapViewDimensions, maxZoomLevel: number): SimpleCamera {\n\tconst region = boundingBoxToRegion(box);\n\tconst center = {\n\t\tlatitude: region.latitude,\n\t\tlongitude: region.longitude,\n\t};\n\n\tlet bestZoomLevel = 0;\n\n\tfor (let level = 1; level <= maxZoomLevel; level++) {\n\t\tconst guessedBox = cameraToBoundingBox(center, level, viewDimensions);\n\t\tif (boundingBoxContains(guessedBox, box[0]) && boundingBoxContains(guessedBox, box[1])) {\n\t\t\tbestZoomLevel = level;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn { center, zoom: bestZoomLevel };\n}\n\nexport function cameraToTiles(center: LatLng, zoomLevel: number, viewDimensions: MapViewDimensions): TileCode[] {\n\tconst box = cameraToBoundingBox(center, zoomLevel, viewDimensions);\n\tconst topLeft = worldCoordsToTilePixel(box[0], zoomLevel);\n\tconst bottomRight = worldCoordsToTilePixel(box[1], zoomLevel);\n\n\tconst tiles: TileCode[] = [];\n\n\tfor (let { tileX } = topLeft; tileX <= bottomRight.tileX; tileX++) {\n\t\tfor (let { tileY } = topLeft; tileY <= bottomRight.tileY; tileY++) {\n\t\t\ttiles.push({ tileX, tileY, zoomLevel });\n\t\t}\n\t}\n\n\treturn tiles;\n}\n\nexport function worldDistanceToPixels(distance: number, zoomLevel: number): number {\n\treturn distance * zoomLevelToScale(zoomLevel);\n}\n\nexport function pixelsToWorldDistance(pixels: number, zoomLevel: number): number {\n\treturn pixels / zoomLevelToScale(zoomLevel);\n}\n\nexport function addExactPaddingToBoundingBox(box: BoundingBox, zoomLevel: number, padding: PaddingRem): BoundingBox {\n\tconst paddingPx = toPaddingPx(padding);\n\n\treturn [\n\t\t{\n\t\t\tx: box[0].x - pixelsToWorldDistance(paddingPx.leftPx, zoomLevel),\n\t\t\ty: box[0].y - pixelsToWorldDistance(paddingPx.topPx, zoomLevel),\n\t\t},\n\t\t{\n\t\t\tx: box[1].x + pixelsToWorldDistance(paddingPx.rightPx, zoomLevel),\n\t\t\ty: box[1].y + pixelsToWorldDistance(paddingPx.bottomPx, zoomLevel),\n\t\t},\n\t];\n}\n\nexport function guessCameraZoomForBoundingBox(): number {\n\treturn 17;\n}\n\nexport function addRoughPaddingToBoundingBox(box: BoundingBox, paddingPixels: PaddingRem): BoundingBox {\n\treturn addExactPaddingToBoundingBox(box, guessCameraZoomForBoundingBox(), paddingPixels);\n}\n\nexport function mergeBoundingBoxes(box1: BoundingBox, box2: BoundingBox): BoundingBox {\n\treturn [\n\t\t{ x: Math.min(box1[0].x, box2[0].x), y: Math.min(box1[0].y, box2[0].y) },\n\t\t{ x: Math.max(box1[1].x, box2[1].x), y: Math.max(box1[1].y, box2[1].y) },\n\t];\n}\n\nconst PIN_PADDING = toPaddingPx({\n\tbottom: 16,\n\tleft: 32,\n\tright: 32,\n\ttop: 88,\n});\n\nexport function addEnoughPaddingToEnsurePinsVisible(box: BoundingBox, pins: WorldCoordinate[]): BoundingBox {\n\tif (pins.length === 0) return box;\n\n\tconst zoomLevel = guessCameraZoomForBoundingBox();\n\n\tconst topPadding = pixelsToWorldDistance(PIN_PADDING.topPx, zoomLevel);\n\tconst leftPadding = pixelsToWorldDistance(PIN_PADDING.leftPx, zoomLevel);\n\tconst rightPadding = pixelsToWorldDistance(PIN_PADDING.rightPx, zoomLevel);\n\n\tconst uppermostPinYValue = Math.min(...pins.map((pin) => pin.y));\n\tconst leftmostPinXValue = Math.min(...pins.map((pin) => pin.x));\n\tconst rightmostPinXValue = Math.max(...pins.map((pin) => pin.x));\n\n\treturn [\n\t\t{ x: Math.min(box[0].x, leftmostPinXValue - leftPadding), y: Math.min(box[0].y, uppermostPinYValue - topPadding) },\n\t\t{ x: Math.max(box[1].x, rightmostPinXValue + rightPadding), y: box[1].y },\n\t];\n}\n\nexport function safelyPredictTilesForBoundingBox(box: BoundingBox): TileCode[] {\n\tconst mainZoomLevel = guessCameraZoomForBoundingBox();\n\tconst safeGuessForDimensions: MapViewDimensions = { widthPx: WINDOW_WIDTH_PX * 1.2, heightPx: WINDOW_HEIGHT_PX * 0.9 };\n\tconst center = worldCoordsToGeo(getBoundingBoxCenter(box));\n\n\tlet tiles: TileCode[] = [];\n\n\tfor (let zoomLevel = mainZoomLevel - 1; zoomLevel <= mainZoomLevel + 2; zoomLevel++) {\n\t\ttiles = tiles.concat(cameraToTiles(center, zoomLevel, safeGuessForDimensions));\n\t}\n\n\treturn tiles;\n}\n\n// given an polygon (array of lat/long) calculates the topleft and bottom right bounding box for a polygon in geo coordinates\nexport function overlayBounding(coordinates: Array<[number, number]>): [[number, number], [number, number]] {\n\tlet topLeftX = Infinity;\n\tlet bottomRightX = -Infinity;\n\tlet topLeftY = -Infinity;\n\tlet bottomRightY = Infinity;\n\n\tfor (const point of coordinates) {\n\t\tif (point[0] < topLeftX) topLeftX = point[0];\n\t\tif (point[0] > bottomRightX) bottomRightX = point[0];\n\t\tif (point[1] < bottomRightY) bottomRightY = point[1];\n\t\tif (point[1] > topLeftY) topLeftY = point[1];\n\t}\n\n\treturn [\n\t\t[topLeftY, topLeftX],\n\t\t[bottomRightY, bottomRightX],\n\t];\n}\n\n// given polygon get a rought approximation of the upper center position\nexport function upperCenter(coordinates: Array<[number, number]>): LatLng {\n\tlet topLeftX = Infinity;\n\tlet topLeftY = -Infinity;\n\tlet topRightX = -Infinity;\n\tlet topRightY = -Infinity;\n\n\tfor (const point of coordinates) {\n\t\ttopLeftX = Math.min(topLeftX, point[0]);\n\t\ttopLeftY = Math.max(topLeftY, point[1]);\n\t\ttopRightX = Math.max(topRightX, point[0]);\n\t\ttopRightY = Math.max(topRightY, point[1]);\n\t}\n\n\treturn { longitude: (topLeftX + topRightX) / 2, latitude: (topLeftY + topRightY) / 2 };\n}\n\n// given polygon get a rought approximation of the lower center position\nexport function lowerCenter(coordinates: Array<[number, number]>): LatLng {\n\tlet topLeftX = Infinity;\n\tlet bottomLeftY = Infinity;\n\tlet topRightX = -Infinity;\n\tlet bottomRightY = Infinity;\n\n\tfor (const point of coordinates) {\n\t\ttopLeftX = Math.min(topLeftX, point[0]);\n\t\tbottomLeftY = Math.min(bottomLeftY, point[1]);\n\t\ttopRightX = Math.max(topRightX, point[0]);\n\t\tbottomRightY = Math.min(bottomRightY, point[1]);\n\t}\n\n\treturn { longitude: (topLeftX + topRightX) / 2, latitude: (bottomLeftY + bottomRightY) / 2 };\n}\n\n// given polygon get a rought approximation of the center position\nexport function center(coordinates: Array<[number, number]>): LatLng {\n\tconst up = upperCenter(coordinates);\n\tconst bottom = lowerCenter(coordinates);\n\n\treturn { longitude: (up.longitude + bottom.longitude) / 2, latitude: (up.latitude + bottom.latitude) / 2 };\n}\n"]},"metadata":{},"sourceType":"module"}