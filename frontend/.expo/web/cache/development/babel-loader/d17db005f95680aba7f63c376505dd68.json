{"ast":null,"code":"function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } it = o[Symbol.iterator](); return it.next.bind(it); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport * as Notifications from 'expo-notifications';\nimport Constants from 'expo-constants';\nimport AppState from \"react-native-web/dist/exports/AppState\";\nimport { debug } from \"../debug\";\nimport { parseAgroNotification } from \"./parse-agro-notification\";\nNotifications.setNotificationHandler({\n  handleNotification: function handleNotification(notification) {\n    var parsedNotification, silent;\n    return _regeneratorRuntime.async(function handleNotification$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            parsedNotification = parseAgroNotification(notification);\n            debug('Received notification while in foreground:', {\n              raw: notification,\n              parsed: parsedNotification\n            });\n            silent = parsedNotification.silent;\n            return _context.abrupt(\"return\", {\n              shouldShowAlert: !silent,\n              shouldPlaySound: !silent,\n              shouldSetBadge: !silent\n            });\n\n          case 4:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  },\n  handleSuccess: function handleSuccess(notificationMessageId) {\n    debug(\"Successfully received push notification with FCM ID \" + notificationMessageId);\n  },\n  handleError: function handleError() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    debug('Error handling notification! Args:', args);\n  }\n});\n\nfunction getCurrentlyShowingNotifications() {\n  var rawNotifications;\n  return _regeneratorRuntime.async(function getCurrentlyShowingNotifications$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          _context2.next = 2;\n          return _regeneratorRuntime.awrap(Notifications.getPresentedNotificationsAsync());\n\n        case 2:\n          rawNotifications = _context2.sent;\n          return _context2.abrupt(\"return\", rawNotifications.map(function (rawNotification) {\n            return parseAgroNotification(rawNotification);\n          }));\n\n        case 4:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\n\nvar notificationIdsAlreadyDetected = new Set();\nexport function setupNotificationListeners(listeners) {\n  function appStateChangeHandlerForNotifications(newState) {\n    var currentlyShowingNotifications, newlyDetectedNotifications, _iterator, _step, _notification, _i, _newlyDetectedNotific, _notification2;\n\n    return _regeneratorRuntime.async(function appStateChangeHandlerForNotifications$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            if (!(newState !== 'active')) {\n              _context3.next = 2;\n              break;\n            }\n\n            return _context3.abrupt(\"return\");\n\n          case 2:\n            _context3.next = 4;\n            return _regeneratorRuntime.awrap(getCurrentlyShowingNotifications());\n\n          case 4:\n            currentlyShowingNotifications = _context3.sent;\n            newlyDetectedNotifications = [];\n\n            for (_iterator = _createForOfIteratorHelperLoose(currentlyShowingNotifications); !(_step = _iterator()).done;) {\n              _notification = _step.value;\n\n              if (!notificationIdsAlreadyDetected.has(_notification.fcmMessageId)) {\n                notificationIdsAlreadyDetected.add(_notification.fcmMessageId);\n                newlyDetectedNotifications.push(_notification);\n              }\n            }\n\n            _i = 0, _newlyDetectedNotific = newlyDetectedNotifications;\n\n          case 8:\n            if (!(_i < _newlyDetectedNotific.length)) {\n              _context3.next = 15;\n              break;\n            }\n\n            _notification2 = _newlyDetectedNotific[_i];\n            _context3.next = 12;\n            return _regeneratorRuntime.awrap(listeners.receivedNotForeground == null ? void 0 : listeners.receivedNotForeground(_notification2));\n\n          case 12:\n            _i++;\n            _context3.next = 8;\n            break;\n\n          case 15:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  }\n\n  try {\n    debug('Constants.manifest.id', Constants.manifest.id);\n    var subscription1 = Notifications.addNotificationReceivedListener(function (notification) {\n      var parsed = parseAgroNotification(notification);\n      notificationIdsAlreadyDetected.add(parsed.fcmMessageId);\n      void (listeners.receivedForeground == null ? void 0 : listeners.receivedForeground(parsed));\n    });\n    var subscription2 = Notifications.addNotificationResponseReceivedListener(function (response) {\n      var parsed = parseAgroNotification(response.notification);\n      notificationIdsAlreadyDetected.add(parsed.fcmMessageId);\n      void (listeners.pressed == null ? void 0 : listeners.pressed(parsed));\n    });\n    AppState.addEventListener('change', appStateChangeHandlerForNotifications);\n    return function () {\n      debug('Removing notification listeners...');\n      subscription1.remove();\n      subscription2.remove();\n      AppState.removeEventListener('change', appStateChangeHandlerForNotifications);\n    };\n  } catch (error) {\n    debug('Error setting up notification listeners:', error);\n    return function () {};\n  }\n}","map":{"version":3,"sources":["/home/jmgoncalves/git/agro-x/frontend/src/notifications/setup.ts"],"names":["Notifications","Constants","debug","parseAgroNotification","setNotificationHandler","handleNotification","notification","parsedNotification","raw","parsed","silent","shouldShowAlert","shouldPlaySound","shouldSetBadge","handleSuccess","notificationMessageId","handleError","args","getCurrentlyShowingNotifications","getPresentedNotificationsAsync","rawNotifications","map","rawNotification","notificationIdsAlreadyDetected","Set","setupNotificationListeners","listeners","appStateChangeHandlerForNotifications","newState","currentlyShowingNotifications","newlyDetectedNotifications","has","fcmMessageId","add","push","receivedNotForeground","manifest","id","subscription1","addNotificationReceivedListener","receivedForeground","subscription2","addNotificationResponseReceivedListener","response","pressed","AppState","addEventListener","remove","removeEventListener","error"],"mappings":";;;;;;;AAAA,OAAO,KAAKA,aAAZ,MAA+B,oBAA/B;AACA,OAAOC,SAAP,MAAsB,gBAAtB;;AAEA,SAASC,KAAT;AACA,SAASC,qBAAT;AAEAH,aAAa,CAACI,sBAAd,CAAqC;AAC9BC,EAAAA,kBAD8B,8BACXC,YADW;AAAA;AAAA;AAAA;AAAA;AAAA;AAK7BC,YAAAA,kBAL6B,GAKRJ,qBAAqB,CAACG,YAAD,CALb;AAOnCJ,YAAAA,KAAK,CAAC,4CAAD,EAA+C;AACnDM,cAAAA,GAAG,EAAEF,YAD8C;AAEnDG,cAAAA,MAAM,EAAEF;AAF2C,aAA/C,CAAL;AA6CQG,YAAAA,MApD2B,GAoDhBH,kBApDgB,CAoD3BG,MApD2B;AAAA,6CAsD5B;AACNC,cAAAA,eAAe,EAAE,CAACD,MADZ;AAENE,cAAAA,eAAe,EAAE,CAACF,MAFZ;AAGNG,cAAAA,cAAc,EAAE,CAACH;AAHX,aAtD4B;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA6DpCI,EAAAA,aA7DoC,yBA6DtBC,qBA7DsB,EA6DS;AAE5Cb,IAAAA,KAAK,0DAAwDa,qBAAxD,CAAL;AACA,GAhEmC;AAkEpCC,EAAAA,WAlEoC,yBAkEf;AAAA,sCAANC,IAAM;AAANA,MAAAA,IAAM;AAAA;;AACpBf,IAAAA,KAAK,CAAC,oCAAD,EAAuCe,IAAvC,CAAL;AACA;AApEmC,CAArC;;AAuEA,SAAeC,gCAAf;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,2CACgClB,aAAa,CAACmB,8BAAd,EADhC;;AAAA;AACOC,UAAAA,gBADP;AAAA,4CAEQA,gBAAgB,CAACC,GAAjB,CAAqB,UAACC,eAAD;AAAA,mBAAqBnB,qBAAqB,CAACmB,eAAD,CAA1C;AAAA,WAArB,CAFR;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAyBA,IAAMC,8BAA8B,GAAG,IAAIC,GAAJ,EAAvC;AAKA,OAAO,SAASC,0BAAT,CAAoCC,SAApC,EAAsF;AAC5F,WAAeC,qCAAf,CAAqDC,QAArD;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA,kBACKA,QAAQ,KAAK,QADlB;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA,6CAK6CV,gCAAgC,EAL7E;;AAAA;AAKOW,YAAAA,6BALP;AAOOC,YAAAA,0BAPP,GAO8D,EAP9D;;AASC,6DAA2BD,6BAA3B,iCAA0D;AAA/CvB,cAAAA,aAA+C;;AACzD,kBAAI,CAACiB,8BAA8B,CAACQ,GAA/B,CAAmCzB,aAAY,CAAC0B,YAAhD,CAAL,EAAoE;AACnET,gBAAAA,8BAA8B,CAACU,GAA/B,CAAmC3B,aAAY,CAAC0B,YAAhD;AACAF,gBAAAA,0BAA0B,CAACI,IAA3B,CAAgC5B,aAAhC;AACA;AACD;;AAdF,4CAgB4BwB,0BAhB5B;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAgBYxB,YAAAA,cAhBZ;AAAA;AAAA,6CAiBQoB,SAAS,CAACS,qBAjBlB,oBAiBQT,SAAS,CAACS,qBAAV,CAAkC7B,cAAlC,CAjBR;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAqBA,MAAI;AACHJ,IAAAA,KAAK,CAAC,uBAAD,EAA0BD,SAAS,CAACmC,QAAV,CAAmBC,EAA7C,CAAL;AAEA,QAAMC,aAAa,GAAGtC,aAAa,CAACuC,+BAAd,CAA8C,UAACjC,YAAD,EAAkB;AACrF,UAAMG,MAAM,GAAGN,qBAAqB,CAACG,YAAD,CAApC;AACAiB,MAAAA,8BAA8B,CAACU,GAA/B,CAAmCxB,MAAM,CAACuB,YAA1C;AACA,YAAKN,SAAS,CAACc,kBAAf,oBAAKd,SAAS,CAACc,kBAAV,CAA+B/B,MAA/B,CAAL;AACA,KAJqB,CAAtB;AAMA,QAAMgC,aAAa,GAAGzC,aAAa,CAAC0C,uCAAd,CAAsD,UAACC,QAAD,EAAc;AACzF,UAAMlC,MAAM,GAAGN,qBAAqB,CAACwC,QAAQ,CAACrC,YAAV,CAApC;AACAiB,MAAAA,8BAA8B,CAACU,GAA/B,CAAmCxB,MAAM,CAACuB,YAA1C;AACA,YAAKN,SAAS,CAACkB,OAAf,oBAAKlB,SAAS,CAACkB,OAAV,CAAoBnC,MAApB,CAAL;AACA,KAJqB,CAAtB;AAMAoC,IAAAA,QAAQ,CAACC,gBAAT,CAA0B,QAA1B,EAAoCnB,qCAApC;AAEA,WAAO,YAAM;AACZzB,MAAAA,KAAK,CAAC,oCAAD,CAAL;AACAoC,MAAAA,aAAa,CAACS,MAAd;AACAN,MAAAA,aAAa,CAACM,MAAd;AACAF,MAAAA,QAAQ,CAACG,mBAAT,CAA6B,QAA7B,EAAuCrB,qCAAvC;AACA,KALD;AAMA,GAvBD,CAuBE,OAAOsB,KAAP,EAAc;AACf/C,IAAAA,KAAK,CAAC,0CAAD,EAA6C+C,KAA7C,CAAL;AAEA,WAAO,YAAM,CAAE,CAAf;AACA;AACD","sourcesContent":["import * as Notifications from 'expo-notifications';\nimport Constants from 'expo-constants';\nimport { AppState, AppStateStatus } from 'react-native';\nimport { debug } from '../debug';\nimport { parseAgroNotification, ParsedAgroNotification } from './parse-agro-notification';\n\nNotifications.setNotificationHandler({\n\tasync handleNotification(notification) {\n\t\t// This function is the first thing that runs when a notification is received AND the app is in foreground. It decides what to do.\n\t\t// This function does not run if the app is not in foreground.\n\n\t\tconst parsedNotification = parseAgroNotification(notification);\n\n\t\tdebug('Received notification while in foreground:', {\n\t\t\traw: notification,\n\t\t\tparsed: parsedNotification,\n\t\t});\n\n\t\t/// Raw notification example:\n\t\t///\n\t\t/// {\n\t\t/// \trequest: {\n\t\t/// \t\tcontent: {\n\t\t/// \t\t\tautoDismiss: true,\n\t\t/// \t\t\tsound: 'default',\n\t\t/// \t\t\tdata: { foowowowoow: 'barwiwowoow' },\n\t\t/// \t\t\tbody: 'Hello world! 123',\n\t\t/// \t\t\tbadge: null,\n\t\t/// \t\t\ttitle: 'Hello world? 123',\n\t\t/// \t\t\tsubtitle: null,\n\t\t/// \t\t},\n\t\t/// \t\ttrigger: {\n\t\t/// \t\t\tremoteMessage: {\n\t\t/// \t\t\t\toriginalPriority: 2,\n\t\t/// \t\t\t\tnotification: null,\n\t\t/// \t\t\t\tfrom: '787336713843',\n\t\t/// \t\t\t\tttl: 2419200,\n\t\t/// \t\t\t\tsentTime: 1600622429526,\n\t\t/// \t\t\t\tdata: {\n\t\t/// \t\t\t\t\tmessage: 'Hello world! 123',\n\t\t/// \t\t\t\t\ttitle: 'Hello world? 123',\n\t\t/// \t\t\t\t\ticon: 'https://docs.expo.io/static/images/favicon.ico',\n\t\t/// \t\t\t\t\tbody: '{\"foowowowoow\":\"barwiwowoow\"}',\n\t\t/// \t\t\t\t\texperienceId: '@anonymous/embraer-agro',\n\t\t/// \t\t\t\t},\n\t\t/// \t\t\t\tto: null,\n\t\t/// \t\t\t\tcollapseKey: null,\n\t\t/// \t\t\t\tmessageType: null,\n\t\t/// \t\t\t\tpriority: 2,\n\t\t/// \t\t\t\tmessageId: '0:1600622429538869%374b94d1f9fd7ecd',\n\t\t/// \t\t\t},\n\t\t/// \t\t\ttype: 'push',\n\t\t/// \t\t},\n\t\t/// \t\tidentifier: '0:1600622429538869%374b94d1f9fd7ecd',\n\t\t/// \t},\n\t\t/// \tdate: 1600622429526,\n\t\t/// }\n\n\t\tconst { silent } = parsedNotification;\n\n\t\treturn {\n\t\t\tshouldShowAlert: !silent,\n\t\t\tshouldPlaySound: !silent,\n\t\t\tshouldSetBadge: !silent,\n\t\t};\n\t},\n\n\thandleSuccess(notificationMessageId: string) {\n\t\t// '0:1600620931569895%374b94d1f9fd7ecd'\n\t\tdebug(`Successfully received push notification with FCM ID ${notificationMessageId}`);\n\t},\n\n\thandleError(...args) {\n\t\tdebug('Error handling notification! Args:', args);\n\t},\n});\n\nasync function getCurrentlyShowingNotifications(): Promise<ParsedAgroNotification[]> {\n\tconst rawNotifications = await Notifications.getPresentedNotificationsAsync();\n\treturn rawNotifications.map((rawNotification) => parseAgroNotification(rawNotification));\n}\n\nexport type AgroNotificationListener = (notification: ParsedAgroNotification) => void | Promise<void>;\n\nexport type AgroNotificationListeners = {\n\t/**\n\t * This listener will be called when a notification arrives and the app is in foreground.\n\t */\n\treceivedForeground?: AgroNotificationListener;\n\n\t/**\n\t * This listener will be called when the app comes to foreground and notices one or more notifications that arrived while it was in background.\n\t * The listener will be called once for each notification, in series.\n\t */\n\treceivedNotForeground?: AgroNotificationListener;\n\n\t/**\n\t * This listener will be called when the user presses a notification (regardless the app being in foreground or not)\n\t */\n\tpressed?: AgroNotificationListener;\n};\n\nconst notificationIdsAlreadyDetected = new Set<string>();\n\n/**\n * This function must be called ASAP when the app starts. Ideally inside an `useEffect` in the app root.\n */\nexport function setupNotificationListeners(listeners: AgroNotificationListeners): () => void {\n\tasync function appStateChangeHandlerForNotifications(newState: AppStateStatus) {\n\t\tif (newState !== 'active') return;\n\n\t\t// App has just come to foreground.\n\n\t\tconst currentlyShowingNotifications = await getCurrentlyShowingNotifications();\n\n\t\tconst newlyDetectedNotifications: ParsedAgroNotification[] = [];\n\n\t\tfor (const notification of currentlyShowingNotifications) {\n\t\t\tif (!notificationIdsAlreadyDetected.has(notification.fcmMessageId)) {\n\t\t\t\tnotificationIdsAlreadyDetected.add(notification.fcmMessageId);\n\t\t\t\tnewlyDetectedNotifications.push(notification);\n\t\t\t}\n\t\t}\n\n\t\tfor (const notification of newlyDetectedNotifications) {\n\t\t\tawait listeners.receivedNotForeground?.(notification);\n\t\t}\n\t}\n\n\ttry {\n\t\tdebug('Constants.manifest.id', Constants.manifest.id);\n\n\t\tconst subscription1 = Notifications.addNotificationReceivedListener((notification) => {\n\t\t\tconst parsed = parseAgroNotification(notification);\n\t\t\tnotificationIdsAlreadyDetected.add(parsed.fcmMessageId);\n\t\t\tvoid listeners.receivedForeground?.(parsed);\n\t\t});\n\n\t\tconst subscription2 = Notifications.addNotificationResponseReceivedListener((response) => {\n\t\t\tconst parsed = parseAgroNotification(response.notification);\n\t\t\tnotificationIdsAlreadyDetected.add(parsed.fcmMessageId);\n\t\t\tvoid listeners.pressed?.(parsed);\n\t\t});\n\n\t\tAppState.addEventListener('change', appStateChangeHandlerForNotifications);\n\n\t\treturn () => {\n\t\t\tdebug('Removing notification listeners...');\n\t\t\tsubscription1.remove();\n\t\t\tsubscription2.remove();\n\t\t\tAppState.removeEventListener('change', appStateChangeHandlerForNotifications);\n\t\t};\n\t} catch (error) {\n\t\tdebug('Error setting up notification listeners:', error);\n\t\t// eslint-disable-next-line @typescript-eslint/no-empty-function\n\t\treturn () => {};\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}