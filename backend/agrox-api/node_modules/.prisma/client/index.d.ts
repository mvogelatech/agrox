
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime';

export import DMMF = runtime.DMMF

/**
 * Prisma Errors
 */
export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
export import PrismaClientValidationError = runtime.PrismaClientValidationError

/**
 * Re-export of sql-template-tag
 */
export import sql = runtime.sqltag
export import empty = runtime.empty
export import join = runtime.join
export import raw = runtime.raw
export import Sql = runtime.Sql

/**
 * Decimal.js
 */
export import Decimal = runtime.Decimal

/**
 * Prisma Client JS version: 2.13.1
 * Query Engine version: fcbc4bb2d306c86c28014f596b1e8c7980af8bd4
 */
export type PrismaVersion = {
  client: string
}

export const prismaVersion: PrismaVersion 

/**
 * Utility Types
 */

/**
 * From https://github.com/sindresorhus/type-fest/
 * Matches a JSON object.
 * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
 */
export type JsonObject = {[Key in string]?: JsonValue}
 
/**
 * From https://github.com/sindresorhus/type-fest/
 * Matches a JSON array.
 */
export interface JsonArray extends Array<JsonValue> {}
 
/**
 * From https://github.com/sindresorhus/type-fest/
 * Matches any valid JSON value.
 */
export type JsonValue = string | number | boolean | null | JsonObject | JsonArray

/**
 * Same as JsonObject, but allows undefined
 */
export type InputJsonObject = {[Key in string]?: JsonValue}
 
export interface InputJsonArray extends Array<JsonValue> {}
 
export type InputJsonValue = undefined |  string | number | boolean | null | InputJsonObject | InputJsonArray
 type SelectAndInclude = {
  select: any
  include: any
}
type HasSelect = {
  select: any
}
type HasInclude = {
  include: any
}
type CheckSelect<T, S, U> = T extends SelectAndInclude
  ? 'Please either choose `select` or `include`'
  : T extends HasSelect
  ? U
  : T extends HasInclude
  ? U
  : S

/**
 * Get the type of the value, that the Promise holds.
 */
export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

/**
 * Get the return type of a function which returns a Promise.
 */
export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>


export type Enumerable<T> = T | Array<T>;

export type RequiredKeys<T> = {
  [K in keyof T]-?: {} extends Pick<T, K> ? never : K
}[keyof T]

export type TruthyKeys<T> = {
  [key in keyof T]: T[key] extends false | undefined | null ? never : key
}[keyof T]

export type TrueKeys<T> = TruthyKeys<Pick<T, RequiredKeys<T>>>

/**
 * Subset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
 */
export type Subset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never;
};

type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

/**
 * XOR is needed to have a real mutually exclusive union type
 * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
 */
type XOR<T, U> = (T | U) extends object ? (Without<T, U> & U) | (Without<U, T> & T) : T | U;



/**
 * Used by group by
 */
export type GetScalarType<T, O> = O extends object ? {
  [P in keyof T]: P extends keyof O
    ? O[P]
    : never
} : never

/**
 * Convert tuple to union
 */
type _TupleToUnion<T> = T extends (infer E)[] ? E : never
type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>

/**
 * Like `Pick`, but with an array
 */
type PickArray<T, K extends Array<keyof T>> = Pick<T, TupleToUnion<K>>





/**
 * Model address
 */

export type address = {
  id: number
  street: string
  city: string
  number: number | null
  km: number | null
  postal_code: string | null
  complement: string | null
  neighborhood: string | null
  phone_number: string | null
  contact_name: string | null
  state_id: number
  mobile_number: string | null
  email: string | null
}

/**
 * Model area
 */

export type area = {
  id: number
  code: number
  lat: number
  long: number
  coordinates: Prisma.JsonValue | null
  name: string
  zone: string | null
  state_initials: string | null
  city: string | null
  farm_id: number
  demand: string | null
}

/**
 * Model company
 */

export type company = {
  id: number
  name: string
  works_with_drone: boolean
  works_with_plane: boolean
  works_with_tractor: boolean
  lat: number
  long: number
  address_id: number
}

/**
 * Model crop
 */

export type crop = {
  id: number
  crop_type: string
  variety: string
  sowing_date: Date
  expected_harvest_date: Date
  number: number
  is_diagnosis_hired: boolean | null
  field_id: number
}

/**
 * Model diagnosis
 */

export type diagnosis = {
  id: number
  report_date: Date
  affected_area_ha: number
  crop_id: number | null
}

/**
 * Model email
 */

export type email = {
  id: number
  email: string
}

/**
 * Model farm
 */

export type farm = {
  id: number
  cnpj: string | null
  social_name: string | null
  fantasy_name: string
  lat: number | null
  long: number | null
  address_id: number
}

/**
 * Model field
 */

export type field = {
  id: number
  code: number
  area_ha: number
  lat: number
  long: number
  coordinates: Prisma.JsonValue
  name: string
  image_uri: string | null
  area_id: number
  visiona_area_id: number | null
  event: string | null
}

/**
 * Model imaging
 */

export type imaging = {
  id: number
  directory: string
  processing_timestamp: Date
  imaging_date: Date
  farm_id: number | null
}

/**
 * Model infestation
 */

export type infestation = {
  id: number
  area_ha: number
  points: Prisma.JsonValue | null
  diagnosis_id: number
  plague_id: number
}

/**
 * Model many_quotation_modal_package_has_many_field
 */

export type many_quotation_modal_package_has_many_field = {
  id_quotation_modal_package: number
  id_field: number
}

/**
 * Model many_user_has_many_farm
 */

export type many_user_has_many_farm = {
  user_id: number
  farm_id: number
}

/**
 * Model notification
 */

export type notification = {
  id: number
  type: number
  body: Prisma.JsonValue
  sent_date: Date
  read_date: Date | null
  delivered_date: Date | null
  user_id: number
}

/**
 * Model plague
 */

export type plague = {
  id: number
  name: string
  display_name: string | null
  color: string
  in_use: boolean | null
  relevance_order: number | null
}

/**
 * Model prescription
 */

export type prescription = {
  id: number
  date: Date
  content: Prisma.JsonValue
  pulverization_method: number
  author: string | null
  phone_number: string | null
  diagnosis_id: number
}

/**
 * Model privacy_policy
 */

export type privacy_policy = {
  id: number
  content: string
  publish_date: Date
}

/**
 * Model quotation
 */

export type quotation = {
  id: number
  response_date: Date | null
  expiration_date: Date | null
  antecipated_price: number | null
  cash_price: number | null
  delayed_price: number | null
  company_id: number
  quotation_modal_package_id: number
}

/**
 * Model quotation_checkout
 */

export type quotation_checkout = {
  id: number
  checkout_date: Date
  selected_price: number
  quotation_id: number
}

/**
 * Model quotation_modal_package
 */

export type quotation_modal_package = {
  id: number
  pulverization_method: number
  quotation_package_id: number
}

/**
 * Model quotation_package
 */

export type quotation_package = {
  id: number
  code: number
  request_date: Date
  pulverization_start_date: Date
  pulverization_end_date: Date
}

/**
 * Model role
 */

export type role = {
  id: number
  name: string | null
}

/**
 * Model seed_revision
 */

export type seed_revision = {
  id: number
  revision: number
  seeding_timestamp: Date
  version_major: number | null
  version_minor: number | null
  version_patch: number | null
}

/**
 * Model state
 */

export type state = {
  id: number
  initials: string
  name: string
  ibge_code: number | null
  country_code: number | null
  area_code: Prisma.JsonValue | null
}

/**
 * Model terms_and_conditions
 */

export type terms_and_conditions = {
  id: number
  content: string
  publish_date: Date
}

/**
 * Model user
 */

export type user = {
  id: number
  first_name: string
  last_name: string
  username: string
  password: string
  cpf: string | null
  phone_number: string
  email: string | null
  active: boolean
  creation_date: Date
  access_date: Date
  update_date: Date
  yellow_threshold: number
  red_threshold: number
  fcm_token: string | null
  avatar: string | null
}

/**
 * Model user_accepted_privacy_policy
 */

export type user_accepted_privacy_policy = {
  id: number
  accepted_date: Date
  id_privacy_policy: number
  id_user: number
}

/**
 * Model user_accepted_terms
 */

export type user_accepted_terms = {
  id: number
  accepted_date: Date
  id_user: number
  id_terms_and_conditions: number
}

/**
 * Model user_role
 */

export type user_role = {
  id: number
  user_id: number
  role_id: number
}


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js (ORM replacement)
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Addresses
 * const addresses = await prisma.address.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never
      > {
      /**
       * @private
       */
      private fetcher;
      /**
       * @private
       */
      private readonly dmmf;
      /**
       * @private
       */
      private connectionPromise?;
      /**
       * @private
       */
      private disconnectionPromise?;
      /**
       * @private
       */
      private readonly engineConfig;
      /**
       * @private
       */
      private readonly measurePerformance;

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js (ORM replacement)
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Addresses
   * const addresses = await prisma.address.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: T);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<any>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

  /**
   * Executes a raw query and returns the number of affected rows
   * @example
   * ```
   * // With parameters use prisma.executeRaw``, values will be escaped automatically
   * const result = await prisma.executeRaw`UPDATE User SET cool = ${true} WHERE id = ${1};`
   * // Or
   * const result = await prisma.executeRaw('UPDATE User SET cool = $1 WHERE id = $2 ;', true, 1)
  * ```
  * 
  * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
  */
  $executeRaw < T = any > (query: string | TemplateStringsArray | Prisma.Sql, ...values: any[]): Promise<number>;

  /**
   * Performs a raw query and returns the SELECT data
   * @example
   * ```
   * // With parameters use prisma.queryRaw``, values will be escaped automatically
   * const result = await prisma.queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'ema.il'};`
   * // Or
   * const result = await prisma.queryRaw('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'ema.il')
  * ```
  * 
  * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
  */
  $queryRaw < T = any > (query: string | TemplateStringsArray | Prisma.Sql, ...values: any[]): Promise<T>;

  /**
   * Execute queries in a transaction
   * @example
   * ```
   * const [george, bob, alice] = await prisma.transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   */
  $transaction: PromiseConstructor['all']

      /**
   * `prisma.address`: Exposes CRUD operations for the **address** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Addresses
    * const addresses = await prisma.address.findMany()
    * ```
    */
  get address(): Prisma.addressDelegate;

  /**
   * `prisma.area`: Exposes CRUD operations for the **area** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Areas
    * const areas = await prisma.area.findMany()
    * ```
    */
  get area(): Prisma.areaDelegate;

  /**
   * `prisma.company`: Exposes CRUD operations for the **company** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Companies
    * const companies = await prisma.company.findMany()
    * ```
    */
  get company(): Prisma.companyDelegate;

  /**
   * `prisma.crop`: Exposes CRUD operations for the **crop** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Crops
    * const crops = await prisma.crop.findMany()
    * ```
    */
  get crop(): Prisma.cropDelegate;

  /**
   * `prisma.diagnosis`: Exposes CRUD operations for the **diagnosis** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Diagnoses
    * const diagnoses = await prisma.diagnosis.findMany()
    * ```
    */
  get diagnosis(): Prisma.diagnosisDelegate;

  /**
   * `prisma.email`: Exposes CRUD operations for the **email** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Emails
    * const emails = await prisma.email.findMany()
    * ```
    */
  get email(): Prisma.emailDelegate;

  /**
   * `prisma.farm`: Exposes CRUD operations for the **farm** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Farms
    * const farms = await prisma.farm.findMany()
    * ```
    */
  get farm(): Prisma.farmDelegate;

  /**
   * `prisma.field`: Exposes CRUD operations for the **field** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Fields
    * const fields = await prisma.field.findMany()
    * ```
    */
  get field(): Prisma.fieldDelegate;

  /**
   * `prisma.imaging`: Exposes CRUD operations for the **imaging** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Imagings
    * const imagings = await prisma.imaging.findMany()
    * ```
    */
  get imaging(): Prisma.imagingDelegate;

  /**
   * `prisma.infestation`: Exposes CRUD operations for the **infestation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Infestations
    * const infestations = await prisma.infestation.findMany()
    * ```
    */
  get infestation(): Prisma.infestationDelegate;

  /**
   * `prisma.many_quotation_modal_package_has_many_field`: Exposes CRUD operations for the **many_quotation_modal_package_has_many_field** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Many_quotation_modal_package_has_many_fields
    * const many_quotation_modal_package_has_many_fields = await prisma.many_quotation_modal_package_has_many_field.findMany()
    * ```
    */
  get many_quotation_modal_package_has_many_field(): Prisma.many_quotation_modal_package_has_many_fieldDelegate;

  /**
   * `prisma.many_user_has_many_farm`: Exposes CRUD operations for the **many_user_has_many_farm** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Many_user_has_many_farms
    * const many_user_has_many_farms = await prisma.many_user_has_many_farm.findMany()
    * ```
    */
  get many_user_has_many_farm(): Prisma.many_user_has_many_farmDelegate;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.notificationDelegate;

  /**
   * `prisma.plague`: Exposes CRUD operations for the **plague** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Plagues
    * const plagues = await prisma.plague.findMany()
    * ```
    */
  get plague(): Prisma.plagueDelegate;

  /**
   * `prisma.prescription`: Exposes CRUD operations for the **prescription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Prescriptions
    * const prescriptions = await prisma.prescription.findMany()
    * ```
    */
  get prescription(): Prisma.prescriptionDelegate;

  /**
   * `prisma.privacy_policy`: Exposes CRUD operations for the **privacy_policy** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Privacy_policies
    * const privacy_policies = await prisma.privacy_policy.findMany()
    * ```
    */
  get privacy_policy(): Prisma.privacy_policyDelegate;

  /**
   * `prisma.quotation`: Exposes CRUD operations for the **quotation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Quotations
    * const quotations = await prisma.quotation.findMany()
    * ```
    */
  get quotation(): Prisma.quotationDelegate;

  /**
   * `prisma.quotation_checkout`: Exposes CRUD operations for the **quotation_checkout** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Quotation_checkouts
    * const quotation_checkouts = await prisma.quotation_checkout.findMany()
    * ```
    */
  get quotation_checkout(): Prisma.quotation_checkoutDelegate;

  /**
   * `prisma.quotation_modal_package`: Exposes CRUD operations for the **quotation_modal_package** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Quotation_modal_packages
    * const quotation_modal_packages = await prisma.quotation_modal_package.findMany()
    * ```
    */
  get quotation_modal_package(): Prisma.quotation_modal_packageDelegate;

  /**
   * `prisma.quotation_package`: Exposes CRUD operations for the **quotation_package** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Quotation_packages
    * const quotation_packages = await prisma.quotation_package.findMany()
    * ```
    */
  get quotation_package(): Prisma.quotation_packageDelegate;

  /**
   * `prisma.role`: Exposes CRUD operations for the **role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.roleDelegate;

  /**
   * `prisma.seed_revision`: Exposes CRUD operations for the **seed_revision** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Seed_revisions
    * const seed_revisions = await prisma.seed_revision.findMany()
    * ```
    */
  get seed_revision(): Prisma.seed_revisionDelegate;

  /**
   * `prisma.state`: Exposes CRUD operations for the **state** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more States
    * const states = await prisma.state.findMany()
    * ```
    */
  get state(): Prisma.stateDelegate;

  /**
   * `prisma.terms_and_conditions`: Exposes CRUD operations for the **terms_and_conditions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Terms_and_conditions
    * const terms_and_conditions = await prisma.terms_and_conditions.findMany()
    * ```
    */
  get terms_and_conditions(): Prisma.terms_and_conditionsDelegate;

  /**
   * `prisma.user`: Exposes CRUD operations for the **user** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.userDelegate;

  /**
   * `prisma.user_accepted_privacy_policy`: Exposes CRUD operations for the **user_accepted_privacy_policy** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more User_accepted_privacy_policies
    * const user_accepted_privacy_policies = await prisma.user_accepted_privacy_policy.findMany()
    * ```
    */
  get user_accepted_privacy_policy(): Prisma.user_accepted_privacy_policyDelegate;

  /**
   * `prisma.user_accepted_terms`: Exposes CRUD operations for the **user_accepted_terms** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more User_accepted_terms
    * const user_accepted_terms = await prisma.user_accepted_terms.findMany()
    * ```
    */
  get user_accepted_terms(): Prisma.user_accepted_termsDelegate;

  /**
   * `prisma.user_role`: Exposes CRUD operations for the **user_role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more User_roles
    * const user_roles = await prisma.user_role.findMany()
    * ```
    */
  get user_role(): Prisma.user_roleDelegate;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  /**
   * Prisma Client JS version: 2.13.1
   * Query Engine version: fcbc4bb2d306c86c28014f596b1e8c7980af8bd4
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}
 
  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}
 
  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | null | JsonObject | JsonArray

  /**
   * Same as JsonObject, but allows undefined
   */
  export type InputJsonObject = {[Key in string]?: JsonValue}
 
  export interface InputJsonArray extends Array<JsonValue> {}
 
  export type InputJsonValue = undefined |  string | number | boolean | null | InputJsonObject | InputJsonArray
   type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = {
    [key in keyof T]: T[key] extends false | undefined | null ? never : key
  }[keyof T]

  export type TrueKeys<T> = TruthyKeys<Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> = (T | U) extends object ? (Without<T, U> & U) | (Without<U, T> & T) : T | U;



  /**
   * Used by group by
   */
  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Pick<T, TupleToUnion<K>>

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    address: 'address',
    area: 'area',
    company: 'company',
    crop: 'crop',
    diagnosis: 'diagnosis',
    email: 'email',
    farm: 'farm',
    field: 'field',
    imaging: 'imaging',
    infestation: 'infestation',
    many_quotation_modal_package_has_many_field: 'many_quotation_modal_package_has_many_field',
    many_user_has_many_farm: 'many_user_has_many_farm',
    notification: 'notification',
    plague: 'plague',
    prescription: 'prescription',
    privacy_policy: 'privacy_policy',
    quotation: 'quotation',
    quotation_checkout: 'quotation_checkout',
    quotation_modal_package: 'quotation_modal_package',
    quotation_package: 'quotation_package',
    role: 'role',
    seed_revision: 'seed_revision',
    state: 'state',
    terms_and_conditions: 'terms_and_conditions',
    user: 'user',
    user_accepted_privacy_policy: 'user_accepted_privacy_policy',
    user_accepted_terms: 'user_accepted_terms',
    user_role: 'user_role'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your prisma.schema file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'

  /**
   * These options are being passed in to the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined; 
  export type Datasource = {
    url?: string
  }


  /**
   * Model address
   */


  export type AggregateAddress = {
    count: number | null
    avg: AddressAvgAggregateOutputType | null
    sum: AddressSumAggregateOutputType | null
    min: AddressMinAggregateOutputType | null
    max: AddressMaxAggregateOutputType | null
  }

  export type AddressAvgAggregateOutputType = {
    id: number
    number: number | null
    km: number | null
    state_id: number
  }

  export type AddressSumAggregateOutputType = {
    id: number
    number: number | null
    km: number | null
    state_id: number
  }

  export type AddressMinAggregateOutputType = {
    id: number
    street: string | null
    city: string | null
    number: number | null
    km: number | null
    postal_code: string | null
    complement: string | null
    neighborhood: string | null
    phone_number: string | null
    contact_name: string | null
    state_id: number
    mobile_number: string | null
    email: string | null
  }

  export type AddressMaxAggregateOutputType = {
    id: number
    street: string | null
    city: string | null
    number: number | null
    km: number | null
    postal_code: string | null
    complement: string | null
    neighborhood: string | null
    phone_number: string | null
    contact_name: string | null
    state_id: number
    mobile_number: string | null
    email: string | null
  }

  export type AddressCountAggregateOutputType = {
    id: number
    street: number | null
    city: number | null
    number: number | null
    km: number | null
    postal_code: number | null
    complement: number | null
    neighborhood: number | null
    phone_number: number | null
    contact_name: number | null
    state_id: number
    mobile_number: number | null
    email: number | null
    _all: number
  }


  export type AddressAvgAggregateInputType = {
    id?: true
    number?: true
    km?: true
    state_id?: true
  }

  export type AddressSumAggregateInputType = {
    id?: true
    number?: true
    km?: true
    state_id?: true
  }

  export type AddressMinAggregateInputType = {
    id?: true
    street?: true
    city?: true
    number?: true
    km?: true
    postal_code?: true
    complement?: true
    neighborhood?: true
    phone_number?: true
    contact_name?: true
    state_id?: true
    mobile_number?: true
    email?: true
  }

  export type AddressMaxAggregateInputType = {
    id?: true
    street?: true
    city?: true
    number?: true
    km?: true
    postal_code?: true
    complement?: true
    neighborhood?: true
    phone_number?: true
    contact_name?: true
    state_id?: true
    mobile_number?: true
    email?: true
  }

  export type AddressCountAggregateInputType = {
    id?: true
    street?: true
    city?: true
    number?: true
    km?: true
    postal_code?: true
    complement?: true
    neighborhood?: true
    phone_number?: true
    contact_name?: true
    state_id?: true
    mobile_number?: true
    email?: true
    _all?: true
  }

  export type AggregateAddressArgs = {
    where?: addressWhereInput
    orderBy?: Enumerable<addressOrderByInput>
    cursor?: addressWhereUniqueInput
    take?: number
    skip?: number
    count?: true
    avg?: AddressAvgAggregateInputType
    sum?: AddressSumAggregateInputType
    min?: AddressMinAggregateInputType
    max?: AddressMaxAggregateInputType
  }

  export type GetAddressAggregateType<T extends AggregateAddressArgs> = {
    [P in keyof T]: P extends 'count' ? number : GetAddressAggregateScalarType<T[P]>
  }

  export type GetAddressAggregateScalarType<T extends any> = {
    [P in keyof T]: P extends keyof AddressAvgAggregateOutputType ? AddressAvgAggregateOutputType[P] : never
  }

    



  export type addressSelect = {
    id?: boolean
    street?: boolean
    city?: boolean
    number?: boolean
    km?: boolean
    postal_code?: boolean
    complement?: boolean
    neighborhood?: boolean
    phone_number?: boolean
    contact_name?: boolean
    state_id?: boolean
    mobile_number?: boolean
    email?: boolean
    state?: boolean | stateArgs
    company?: boolean | FindManycompanyArgs
    farm?: boolean | FindManyfarmArgs
  }

  export type addressInclude = {
    state?: boolean | stateArgs
    company?: boolean | FindManycompanyArgs
    farm?: boolean | FindManyfarmArgs
  }

  export type addressGetPayload<
    S extends boolean | null | undefined | addressArgs,
    U = keyof S
      > = S extends true
        ? address
    : S extends undefined
    ? never
    : S extends addressArgs | FindManyaddressArgs
    ?'include' extends U
    ? address  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'state'
        ? stateGetPayload<S['include'][P]> :
        P extends 'company'
        ? Array < companyGetPayload<S['include'][P]>>  :
        P extends 'farm'
        ? Array < farmGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof address ?address [P]
  : 
          P extends 'state'
        ? stateGetPayload<S['select'][P]> :
        P extends 'company'
        ? Array < companyGetPayload<S['select'][P]>>  :
        P extends 'farm'
        ? Array < farmGetPayload<S['select'][P]>>  : never
  } 
    : address
  : address


  export interface addressDelegate {
    /**
     * Find zero or one Address that matches the filter.
     * @param {FindUniqueaddressArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FindUniqueaddressArgs>(
      args: Subset<T, FindUniqueaddressArgs>
    ): CheckSelect<T, Prisma__addressClient<address | null>, Prisma__addressClient<addressGetPayload<T> | null>>
    /**
     * Find the first Address that matches the filter.
     * @param {FindFirstaddressArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FindFirstaddressArgs>(
      args?: Subset<T, FindFirstaddressArgs>
    ): CheckSelect<T, Prisma__addressClient<address | null>, Prisma__addressClient<addressGetPayload<T> | null>>
    /**
     * Find zero or more Addresses that matches the filter.
     * @param {FindManyaddressArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Addresses
     * const addresses = await prisma.address.findMany()
     * 
     * // Get first 10 Addresses
     * const addresses = await prisma.address.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const addressWithIdOnly = await prisma.address.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FindManyaddressArgs>(
      args?: Subset<T, FindManyaddressArgs>
    ): CheckSelect<T, Promise<Array<address>>, Promise<Array<addressGetPayload<T>>>>
    /**
     * Create a Address.
     * @param {addressCreateArgs} args - Arguments to create a Address.
     * @example
     * // Create one Address
     * const Address = await prisma.address.create({
     *   data: {
     *     // ... data to create a Address
     *   }
     * })
     * 
    **/
    create<T extends addressCreateArgs>(
      args: Subset<T, addressCreateArgs>
    ): CheckSelect<T, Prisma__addressClient<address>, Prisma__addressClient<addressGetPayload<T>>>
    /**
     * Delete a Address.
     * @param {addressDeleteArgs} args - Arguments to delete one Address.
     * @example
     * // Delete one Address
     * const Address = await prisma.address.delete({
     *   where: {
     *     // ... filter to delete one Address
     *   }
     * })
     * 
    **/
    delete<T extends addressDeleteArgs>(
      args: Subset<T, addressDeleteArgs>
    ): CheckSelect<T, Prisma__addressClient<address>, Prisma__addressClient<addressGetPayload<T>>>
    /**
     * Update one Address.
     * @param {addressUpdateArgs} args - Arguments to update one Address.
     * @example
     * // Update one Address
     * const address = await prisma.address.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends addressUpdateArgs>(
      args: Subset<T, addressUpdateArgs>
    ): CheckSelect<T, Prisma__addressClient<address>, Prisma__addressClient<addressGetPayload<T>>>
    /**
     * Delete zero or more Addresses.
     * @param {addressDeleteManyArgs} args - Arguments to filter Addresses to delete.
     * @example
     * // Delete a few Addresses
     * const { count } = await prisma.address.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends addressDeleteManyArgs>(
      args?: Subset<T, addressDeleteManyArgs>
    ): Promise<BatchPayload>
    /**
     * Update zero or more Addresses.
     * @param {addressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Addresses
     * const address = await prisma.address.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends addressUpdateManyArgs>(
      args: Subset<T, addressUpdateManyArgs>
    ): Promise<BatchPayload>
    /**
     * Create or update one Address.
     * @param {addressUpsertArgs} args - Arguments to update or create a Address.
     * @example
     * // Update or create a Address
     * const address = await prisma.address.upsert({
     *   create: {
     *     // ... data to create a Address
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Address we want to update
     *   }
     * })
    **/
    upsert<T extends addressUpsertArgs>(
      args: Subset<T, addressUpsertArgs>
    ): CheckSelect<T, Prisma__addressClient<address>, Prisma__addressClient<addressGetPayload<T>>>
    /**
     * Find zero or one Address that matches the filter.
     * @param {FindUniqueaddressArgs} args - Arguments to find a Address
     * @deprecated This will be deprecated please use prisma.address.findUnique
     * @example
     * // Get one Address
     * const address = await prisma.address.findOne({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findOne<T extends FindUniqueaddressArgs>(
      args: Subset<T, FindUniqueaddressArgs>
    ): CheckSelect<T, Prisma__addressClient<address | null>, Prisma__addressClient<addressGetPayload<T> | null>>
    /**
     * Count
     */
    count(args?: Omit<FindManyaddressArgs, 'select' | 'include'>): Promise<number>

  

    /**
     * Aggregate
     */
    aggregate<T extends AggregateAddressArgs>(args: Subset<T, AggregateAddressArgs>): Promise<GetAddressAggregateType<T>>
  }

  /**
   * The delegate class that acts as a "Promise-like" for address.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__addressClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    state<T extends stateArgs = {}>(args?: Subset<T, stateArgs>): CheckSelect<T, Prisma__stateClient<state | null>, Prisma__stateClient<stateGetPayload<T> | null>>;

    company<T extends FindManycompanyArgs = {}>(args?: Subset<T, FindManycompanyArgs>): CheckSelect<T, Promise<Array<company>>, Promise<Array<companyGetPayload<T>>>>;

    farm<T extends FindManyfarmArgs = {}>(args?: Subset<T, FindManyfarmArgs>): CheckSelect<T, Promise<Array<farm>>, Promise<Array<farmGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * address findUnique
   */
  export type FindUniqueaddressArgs = {
    /**
     * Select specific fields to fetch from the address
    **/
    select?: addressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: addressInclude | null
    /**
     * Filter, which address to fetch.
    **/
    where: addressWhereUniqueInput
  }


  /**
   * address findFirst
   */
  export type FindFirstaddressArgs = {
    /**
     * Select specific fields to fetch from the address
    **/
    select?: addressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: addressInclude | null
    /**
     * Filter, which address to fetch.
    **/
    where?: addressWhereInput
    orderBy?: Enumerable<addressOrderByInput>
    cursor?: addressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<AddressScalarFieldEnum>
  }


  /**
   * address findMany
   */
  export type FindManyaddressArgs = {
    /**
     * Select specific fields to fetch from the address
    **/
    select?: addressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: addressInclude | null
    /**
     * Filter, which addresses to fetch.
    **/
    where?: addressWhereInput
    /**
     * Determine the order of the addresses to fetch.
    **/
    orderBy?: Enumerable<addressOrderByInput>
    /**
     * Sets the position for listing addresses.
    **/
    cursor?: addressWhereUniqueInput
    /**
     * The number of addresses to fetch. If negative number, it will take addresses before the `cursor`.
    **/
    take?: number
    /**
     * Skip the first `n` addresses.
    **/
    skip?: number
    distinct?: Enumerable<AddressScalarFieldEnum>
  }


  /**
   * address create
   */
  export type addressCreateArgs = {
    /**
     * Select specific fields to fetch from the address
    **/
    select?: addressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: addressInclude | null
    /**
     * The data needed to create a address.
    **/
    data: addressCreateInput
  }


  /**
   * address update
   */
  export type addressUpdateArgs = {
    /**
     * Select specific fields to fetch from the address
    **/
    select?: addressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: addressInclude | null
    /**
     * The data needed to update a address.
    **/
    data: addressUpdateInput
    /**
     * Choose, which address to update.
    **/
    where: addressWhereUniqueInput
  }


  /**
   * address updateMany
   */
  export type addressUpdateManyArgs = {
    data: addressUpdateManyMutationInput
    where?: addressWhereInput
  }


  /**
   * address upsert
   */
  export type addressUpsertArgs = {
    /**
     * Select specific fields to fetch from the address
    **/
    select?: addressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: addressInclude | null
    /**
     * The filter to search for the address to update in case it exists.
    **/
    where: addressWhereUniqueInput
    /**
     * In case the address found by the `where` argument doesn't exist, create a new address with this data.
    **/
    create: addressCreateInput
    /**
     * In case the address was found with the provided `where` argument, update it with this data.
    **/
    update: addressUpdateInput
  }


  /**
   * address delete
   */
  export type addressDeleteArgs = {
    /**
     * Select specific fields to fetch from the address
    **/
    select?: addressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: addressInclude | null
    /**
     * Filter which address to delete.
    **/
    where: addressWhereUniqueInput
  }


  /**
   * address deleteMany
   */
  export type addressDeleteManyArgs = {
    where?: addressWhereInput
  }


  /**
   * address without action
   */
  export type addressArgs = {
    /**
     * Select specific fields to fetch from the address
    **/
    select?: addressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: addressInclude | null
  }



  /**
   * Model area
   */


  export type AggregateArea = {
    count: number | null
    avg: AreaAvgAggregateOutputType | null
    sum: AreaSumAggregateOutputType | null
    min: AreaMinAggregateOutputType | null
    max: AreaMaxAggregateOutputType | null
  }

  export type AreaAvgAggregateOutputType = {
    id: number
    code: number
    lat: number
    long: number
    farm_id: number
  }

  export type AreaSumAggregateOutputType = {
    id: number
    code: number
    lat: number
    long: number
    farm_id: number
  }

  export type AreaMinAggregateOutputType = {
    id: number
    code: number
    lat: number
    long: number
    coordinates: JsonValue | null
    name: string | null
    zone: string | null
    state_initials: string | null
    city: string | null
    farm_id: number
    demand: string | null
  }

  export type AreaMaxAggregateOutputType = {
    id: number
    code: number
    lat: number
    long: number
    coordinates: JsonValue | null
    name: string | null
    zone: string | null
    state_initials: string | null
    city: string | null
    farm_id: number
    demand: string | null
  }

  export type AreaCountAggregateOutputType = {
    id: number
    code: number
    lat: number
    long: number
    coordinates: number | null
    name: number | null
    zone: number | null
    state_initials: number | null
    city: number | null
    farm_id: number
    demand: number | null
    _all: number
  }


  export type AreaAvgAggregateInputType = {
    id?: true
    code?: true
    lat?: true
    long?: true
    farm_id?: true
  }

  export type AreaSumAggregateInputType = {
    id?: true
    code?: true
    lat?: true
    long?: true
    farm_id?: true
  }

  export type AreaMinAggregateInputType = {
    id?: true
    code?: true
    lat?: true
    long?: true
    coordinates?: true
    name?: true
    zone?: true
    state_initials?: true
    city?: true
    farm_id?: true
    demand?: true
  }

  export type AreaMaxAggregateInputType = {
    id?: true
    code?: true
    lat?: true
    long?: true
    coordinates?: true
    name?: true
    zone?: true
    state_initials?: true
    city?: true
    farm_id?: true
    demand?: true
  }

  export type AreaCountAggregateInputType = {
    id?: true
    code?: true
    lat?: true
    long?: true
    coordinates?: true
    name?: true
    zone?: true
    state_initials?: true
    city?: true
    farm_id?: true
    demand?: true
    _all?: true
  }

  export type AggregateAreaArgs = {
    where?: areaWhereInput
    orderBy?: Enumerable<areaOrderByInput>
    cursor?: areaWhereUniqueInput
    take?: number
    skip?: number
    count?: true
    avg?: AreaAvgAggregateInputType
    sum?: AreaSumAggregateInputType
    min?: AreaMinAggregateInputType
    max?: AreaMaxAggregateInputType
  }

  export type GetAreaAggregateType<T extends AggregateAreaArgs> = {
    [P in keyof T]: P extends 'count' ? number : GetAreaAggregateScalarType<T[P]>
  }

  export type GetAreaAggregateScalarType<T extends any> = {
    [P in keyof T]: P extends keyof AreaAvgAggregateOutputType ? AreaAvgAggregateOutputType[P] : never
  }

    



  export type areaSelect = {
    id?: boolean
    code?: boolean
    lat?: boolean
    long?: boolean
    coordinates?: boolean
    name?: boolean
    zone?: boolean
    state_initials?: boolean
    city?: boolean
    farm_id?: boolean
    demand?: boolean
    farm?: boolean | farmArgs
    field?: boolean | FindManyfieldArgs
  }

  export type areaInclude = {
    farm?: boolean | farmArgs
    field?: boolean | FindManyfieldArgs
  }

  export type areaGetPayload<
    S extends boolean | null | undefined | areaArgs,
    U = keyof S
      > = S extends true
        ? area
    : S extends undefined
    ? never
    : S extends areaArgs | FindManyareaArgs
    ?'include' extends U
    ? area  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'farm'
        ? farmGetPayload<S['include'][P]> :
        P extends 'field'
        ? Array < fieldGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof area ?area [P]
  : 
          P extends 'farm'
        ? farmGetPayload<S['select'][P]> :
        P extends 'field'
        ? Array < fieldGetPayload<S['select'][P]>>  : never
  } 
    : area
  : area


  export interface areaDelegate {
    /**
     * Find zero or one Area that matches the filter.
     * @param {FindUniqueareaArgs} args - Arguments to find a Area
     * @example
     * // Get one Area
     * const area = await prisma.area.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FindUniqueareaArgs>(
      args: Subset<T, FindUniqueareaArgs>
    ): CheckSelect<T, Prisma__areaClient<area | null>, Prisma__areaClient<areaGetPayload<T> | null>>
    /**
     * Find the first Area that matches the filter.
     * @param {FindFirstareaArgs} args - Arguments to find a Area
     * @example
     * // Get one Area
     * const area = await prisma.area.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FindFirstareaArgs>(
      args?: Subset<T, FindFirstareaArgs>
    ): CheckSelect<T, Prisma__areaClient<area | null>, Prisma__areaClient<areaGetPayload<T> | null>>
    /**
     * Find zero or more Areas that matches the filter.
     * @param {FindManyareaArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Areas
     * const areas = await prisma.area.findMany()
     * 
     * // Get first 10 Areas
     * const areas = await prisma.area.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const areaWithIdOnly = await prisma.area.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FindManyareaArgs>(
      args?: Subset<T, FindManyareaArgs>
    ): CheckSelect<T, Promise<Array<area>>, Promise<Array<areaGetPayload<T>>>>
    /**
     * Create a Area.
     * @param {areaCreateArgs} args - Arguments to create a Area.
     * @example
     * // Create one Area
     * const Area = await prisma.area.create({
     *   data: {
     *     // ... data to create a Area
     *   }
     * })
     * 
    **/
    create<T extends areaCreateArgs>(
      args: Subset<T, areaCreateArgs>
    ): CheckSelect<T, Prisma__areaClient<area>, Prisma__areaClient<areaGetPayload<T>>>
    /**
     * Delete a Area.
     * @param {areaDeleteArgs} args - Arguments to delete one Area.
     * @example
     * // Delete one Area
     * const Area = await prisma.area.delete({
     *   where: {
     *     // ... filter to delete one Area
     *   }
     * })
     * 
    **/
    delete<T extends areaDeleteArgs>(
      args: Subset<T, areaDeleteArgs>
    ): CheckSelect<T, Prisma__areaClient<area>, Prisma__areaClient<areaGetPayload<T>>>
    /**
     * Update one Area.
     * @param {areaUpdateArgs} args - Arguments to update one Area.
     * @example
     * // Update one Area
     * const area = await prisma.area.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends areaUpdateArgs>(
      args: Subset<T, areaUpdateArgs>
    ): CheckSelect<T, Prisma__areaClient<area>, Prisma__areaClient<areaGetPayload<T>>>
    /**
     * Delete zero or more Areas.
     * @param {areaDeleteManyArgs} args - Arguments to filter Areas to delete.
     * @example
     * // Delete a few Areas
     * const { count } = await prisma.area.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends areaDeleteManyArgs>(
      args?: Subset<T, areaDeleteManyArgs>
    ): Promise<BatchPayload>
    /**
     * Update zero or more Areas.
     * @param {areaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Areas
     * const area = await prisma.area.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends areaUpdateManyArgs>(
      args: Subset<T, areaUpdateManyArgs>
    ): Promise<BatchPayload>
    /**
     * Create or update one Area.
     * @param {areaUpsertArgs} args - Arguments to update or create a Area.
     * @example
     * // Update or create a Area
     * const area = await prisma.area.upsert({
     *   create: {
     *     // ... data to create a Area
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Area we want to update
     *   }
     * })
    **/
    upsert<T extends areaUpsertArgs>(
      args: Subset<T, areaUpsertArgs>
    ): CheckSelect<T, Prisma__areaClient<area>, Prisma__areaClient<areaGetPayload<T>>>
    /**
     * Find zero or one Area that matches the filter.
     * @param {FindUniqueareaArgs} args - Arguments to find a Area
     * @deprecated This will be deprecated please use prisma.area.findUnique
     * @example
     * // Get one Area
     * const area = await prisma.area.findOne({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findOne<T extends FindUniqueareaArgs>(
      args: Subset<T, FindUniqueareaArgs>
    ): CheckSelect<T, Prisma__areaClient<area | null>, Prisma__areaClient<areaGetPayload<T> | null>>
    /**
     * Count
     */
    count(args?: Omit<FindManyareaArgs, 'select' | 'include'>): Promise<number>

  

    /**
     * Aggregate
     */
    aggregate<T extends AggregateAreaArgs>(args: Subset<T, AggregateAreaArgs>): Promise<GetAreaAggregateType<T>>
  }

  /**
   * The delegate class that acts as a "Promise-like" for area.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__areaClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    farm<T extends farmArgs = {}>(args?: Subset<T, farmArgs>): CheckSelect<T, Prisma__farmClient<farm | null>, Prisma__farmClient<farmGetPayload<T> | null>>;

    field<T extends FindManyfieldArgs = {}>(args?: Subset<T, FindManyfieldArgs>): CheckSelect<T, Promise<Array<field>>, Promise<Array<fieldGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * area findUnique
   */
  export type FindUniqueareaArgs = {
    /**
     * Select specific fields to fetch from the area
    **/
    select?: areaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: areaInclude | null
    /**
     * Filter, which area to fetch.
    **/
    where: areaWhereUniqueInput
  }


  /**
   * area findFirst
   */
  export type FindFirstareaArgs = {
    /**
     * Select specific fields to fetch from the area
    **/
    select?: areaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: areaInclude | null
    /**
     * Filter, which area to fetch.
    **/
    where?: areaWhereInput
    orderBy?: Enumerable<areaOrderByInput>
    cursor?: areaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<AreaScalarFieldEnum>
  }


  /**
   * area findMany
   */
  export type FindManyareaArgs = {
    /**
     * Select specific fields to fetch from the area
    **/
    select?: areaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: areaInclude | null
    /**
     * Filter, which areas to fetch.
    **/
    where?: areaWhereInput
    /**
     * Determine the order of the areas to fetch.
    **/
    orderBy?: Enumerable<areaOrderByInput>
    /**
     * Sets the position for listing areas.
    **/
    cursor?: areaWhereUniqueInput
    /**
     * The number of areas to fetch. If negative number, it will take areas before the `cursor`.
    **/
    take?: number
    /**
     * Skip the first `n` areas.
    **/
    skip?: number
    distinct?: Enumerable<AreaScalarFieldEnum>
  }


  /**
   * area create
   */
  export type areaCreateArgs = {
    /**
     * Select specific fields to fetch from the area
    **/
    select?: areaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: areaInclude | null
    /**
     * The data needed to create a area.
    **/
    data: areaCreateInput
  }


  /**
   * area update
   */
  export type areaUpdateArgs = {
    /**
     * Select specific fields to fetch from the area
    **/
    select?: areaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: areaInclude | null
    /**
     * The data needed to update a area.
    **/
    data: areaUpdateInput
    /**
     * Choose, which area to update.
    **/
    where: areaWhereUniqueInput
  }


  /**
   * area updateMany
   */
  export type areaUpdateManyArgs = {
    data: areaUpdateManyMutationInput
    where?: areaWhereInput
  }


  /**
   * area upsert
   */
  export type areaUpsertArgs = {
    /**
     * Select specific fields to fetch from the area
    **/
    select?: areaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: areaInclude | null
    /**
     * The filter to search for the area to update in case it exists.
    **/
    where: areaWhereUniqueInput
    /**
     * In case the area found by the `where` argument doesn't exist, create a new area with this data.
    **/
    create: areaCreateInput
    /**
     * In case the area was found with the provided `where` argument, update it with this data.
    **/
    update: areaUpdateInput
  }


  /**
   * area delete
   */
  export type areaDeleteArgs = {
    /**
     * Select specific fields to fetch from the area
    **/
    select?: areaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: areaInclude | null
    /**
     * Filter which area to delete.
    **/
    where: areaWhereUniqueInput
  }


  /**
   * area deleteMany
   */
  export type areaDeleteManyArgs = {
    where?: areaWhereInput
  }


  /**
   * area without action
   */
  export type areaArgs = {
    /**
     * Select specific fields to fetch from the area
    **/
    select?: areaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: areaInclude | null
  }



  /**
   * Model company
   */


  export type AggregateCompany = {
    count: number | null
    avg: CompanyAvgAggregateOutputType | null
    sum: CompanySumAggregateOutputType | null
    min: CompanyMinAggregateOutputType | null
    max: CompanyMaxAggregateOutputType | null
  }

  export type CompanyAvgAggregateOutputType = {
    id: number
    lat: number
    long: number
    address_id: number
  }

  export type CompanySumAggregateOutputType = {
    id: number
    lat: number
    long: number
    address_id: number
  }

  export type CompanyMinAggregateOutputType = {
    id: number
    name: string | null
    works_with_drone: boolean | null
    works_with_plane: boolean | null
    works_with_tractor: boolean | null
    lat: number
    long: number
    address_id: number
  }

  export type CompanyMaxAggregateOutputType = {
    id: number
    name: string | null
    works_with_drone: boolean | null
    works_with_plane: boolean | null
    works_with_tractor: boolean | null
    lat: number
    long: number
    address_id: number
  }

  export type CompanyCountAggregateOutputType = {
    id: number
    name: number | null
    works_with_drone: number | null
    works_with_plane: number | null
    works_with_tractor: number | null
    lat: number
    long: number
    address_id: number
    _all: number
  }


  export type CompanyAvgAggregateInputType = {
    id?: true
    lat?: true
    long?: true
    address_id?: true
  }

  export type CompanySumAggregateInputType = {
    id?: true
    lat?: true
    long?: true
    address_id?: true
  }

  export type CompanyMinAggregateInputType = {
    id?: true
    name?: true
    works_with_drone?: true
    works_with_plane?: true
    works_with_tractor?: true
    lat?: true
    long?: true
    address_id?: true
  }

  export type CompanyMaxAggregateInputType = {
    id?: true
    name?: true
    works_with_drone?: true
    works_with_plane?: true
    works_with_tractor?: true
    lat?: true
    long?: true
    address_id?: true
  }

  export type CompanyCountAggregateInputType = {
    id?: true
    name?: true
    works_with_drone?: true
    works_with_plane?: true
    works_with_tractor?: true
    lat?: true
    long?: true
    address_id?: true
    _all?: true
  }

  export type AggregateCompanyArgs = {
    where?: companyWhereInput
    orderBy?: Enumerable<companyOrderByInput>
    cursor?: companyWhereUniqueInput
    take?: number
    skip?: number
    count?: true
    avg?: CompanyAvgAggregateInputType
    sum?: CompanySumAggregateInputType
    min?: CompanyMinAggregateInputType
    max?: CompanyMaxAggregateInputType
  }

  export type GetCompanyAggregateType<T extends AggregateCompanyArgs> = {
    [P in keyof T]: P extends 'count' ? number : GetCompanyAggregateScalarType<T[P]>
  }

  export type GetCompanyAggregateScalarType<T extends any> = {
    [P in keyof T]: P extends keyof CompanyAvgAggregateOutputType ? CompanyAvgAggregateOutputType[P] : never
  }

    



  export type companySelect = {
    id?: boolean
    name?: boolean
    works_with_drone?: boolean
    works_with_plane?: boolean
    works_with_tractor?: boolean
    lat?: boolean
    long?: boolean
    address_id?: boolean
    address?: boolean | addressArgs
    quotation?: boolean | FindManyquotationArgs
  }

  export type companyInclude = {
    address?: boolean | addressArgs
    quotation?: boolean | FindManyquotationArgs
  }

  export type companyGetPayload<
    S extends boolean | null | undefined | companyArgs,
    U = keyof S
      > = S extends true
        ? company
    : S extends undefined
    ? never
    : S extends companyArgs | FindManycompanyArgs
    ?'include' extends U
    ? company  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'address'
        ? addressGetPayload<S['include'][P]> :
        P extends 'quotation'
        ? Array < quotationGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof company ?company [P]
  : 
          P extends 'address'
        ? addressGetPayload<S['select'][P]> :
        P extends 'quotation'
        ? Array < quotationGetPayload<S['select'][P]>>  : never
  } 
    : company
  : company


  export interface companyDelegate {
    /**
     * Find zero or one Company that matches the filter.
     * @param {FindUniquecompanyArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FindUniquecompanyArgs>(
      args: Subset<T, FindUniquecompanyArgs>
    ): CheckSelect<T, Prisma__companyClient<company | null>, Prisma__companyClient<companyGetPayload<T> | null>>
    /**
     * Find the first Company that matches the filter.
     * @param {FindFirstcompanyArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FindFirstcompanyArgs>(
      args?: Subset<T, FindFirstcompanyArgs>
    ): CheckSelect<T, Prisma__companyClient<company | null>, Prisma__companyClient<companyGetPayload<T> | null>>
    /**
     * Find zero or more Companies that matches the filter.
     * @param {FindManycompanyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Companies
     * const companies = await prisma.company.findMany()
     * 
     * // Get first 10 Companies
     * const companies = await prisma.company.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companyWithIdOnly = await prisma.company.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FindManycompanyArgs>(
      args?: Subset<T, FindManycompanyArgs>
    ): CheckSelect<T, Promise<Array<company>>, Promise<Array<companyGetPayload<T>>>>
    /**
     * Create a Company.
     * @param {companyCreateArgs} args - Arguments to create a Company.
     * @example
     * // Create one Company
     * const Company = await prisma.company.create({
     *   data: {
     *     // ... data to create a Company
     *   }
     * })
     * 
    **/
    create<T extends companyCreateArgs>(
      args: Subset<T, companyCreateArgs>
    ): CheckSelect<T, Prisma__companyClient<company>, Prisma__companyClient<companyGetPayload<T>>>
    /**
     * Delete a Company.
     * @param {companyDeleteArgs} args - Arguments to delete one Company.
     * @example
     * // Delete one Company
     * const Company = await prisma.company.delete({
     *   where: {
     *     // ... filter to delete one Company
     *   }
     * })
     * 
    **/
    delete<T extends companyDeleteArgs>(
      args: Subset<T, companyDeleteArgs>
    ): CheckSelect<T, Prisma__companyClient<company>, Prisma__companyClient<companyGetPayload<T>>>
    /**
     * Update one Company.
     * @param {companyUpdateArgs} args - Arguments to update one Company.
     * @example
     * // Update one Company
     * const company = await prisma.company.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends companyUpdateArgs>(
      args: Subset<T, companyUpdateArgs>
    ): CheckSelect<T, Prisma__companyClient<company>, Prisma__companyClient<companyGetPayload<T>>>
    /**
     * Delete zero or more Companies.
     * @param {companyDeleteManyArgs} args - Arguments to filter Companies to delete.
     * @example
     * // Delete a few Companies
     * const { count } = await prisma.company.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends companyDeleteManyArgs>(
      args?: Subset<T, companyDeleteManyArgs>
    ): Promise<BatchPayload>
    /**
     * Update zero or more Companies.
     * @param {companyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Companies
     * const company = await prisma.company.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends companyUpdateManyArgs>(
      args: Subset<T, companyUpdateManyArgs>
    ): Promise<BatchPayload>
    /**
     * Create or update one Company.
     * @param {companyUpsertArgs} args - Arguments to update or create a Company.
     * @example
     * // Update or create a Company
     * const company = await prisma.company.upsert({
     *   create: {
     *     // ... data to create a Company
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Company we want to update
     *   }
     * })
    **/
    upsert<T extends companyUpsertArgs>(
      args: Subset<T, companyUpsertArgs>
    ): CheckSelect<T, Prisma__companyClient<company>, Prisma__companyClient<companyGetPayload<T>>>
    /**
     * Find zero or one Company that matches the filter.
     * @param {FindUniquecompanyArgs} args - Arguments to find a Company
     * @deprecated This will be deprecated please use prisma.company.findUnique
     * @example
     * // Get one Company
     * const company = await prisma.company.findOne({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findOne<T extends FindUniquecompanyArgs>(
      args: Subset<T, FindUniquecompanyArgs>
    ): CheckSelect<T, Prisma__companyClient<company | null>, Prisma__companyClient<companyGetPayload<T> | null>>
    /**
     * Count
     */
    count(args?: Omit<FindManycompanyArgs, 'select' | 'include'>): Promise<number>

  

    /**
     * Aggregate
     */
    aggregate<T extends AggregateCompanyArgs>(args: Subset<T, AggregateCompanyArgs>): Promise<GetCompanyAggregateType<T>>
  }

  /**
   * The delegate class that acts as a "Promise-like" for company.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__companyClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    address<T extends addressArgs = {}>(args?: Subset<T, addressArgs>): CheckSelect<T, Prisma__addressClient<address | null>, Prisma__addressClient<addressGetPayload<T> | null>>;

    quotation<T extends FindManyquotationArgs = {}>(args?: Subset<T, FindManyquotationArgs>): CheckSelect<T, Promise<Array<quotation>>, Promise<Array<quotationGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * company findUnique
   */
  export type FindUniquecompanyArgs = {
    /**
     * Select specific fields to fetch from the company
    **/
    select?: companySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: companyInclude | null
    /**
     * Filter, which company to fetch.
    **/
    where: companyWhereUniqueInput
  }


  /**
   * company findFirst
   */
  export type FindFirstcompanyArgs = {
    /**
     * Select specific fields to fetch from the company
    **/
    select?: companySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: companyInclude | null
    /**
     * Filter, which company to fetch.
    **/
    where?: companyWhereInput
    orderBy?: Enumerable<companyOrderByInput>
    cursor?: companyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<CompanyScalarFieldEnum>
  }


  /**
   * company findMany
   */
  export type FindManycompanyArgs = {
    /**
     * Select specific fields to fetch from the company
    **/
    select?: companySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: companyInclude | null
    /**
     * Filter, which companies to fetch.
    **/
    where?: companyWhereInput
    /**
     * Determine the order of the companies to fetch.
    **/
    orderBy?: Enumerable<companyOrderByInput>
    /**
     * Sets the position for listing companies.
    **/
    cursor?: companyWhereUniqueInput
    /**
     * The number of companies to fetch. If negative number, it will take companies before the `cursor`.
    **/
    take?: number
    /**
     * Skip the first `n` companies.
    **/
    skip?: number
    distinct?: Enumerable<CompanyScalarFieldEnum>
  }


  /**
   * company create
   */
  export type companyCreateArgs = {
    /**
     * Select specific fields to fetch from the company
    **/
    select?: companySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: companyInclude | null
    /**
     * The data needed to create a company.
    **/
    data: companyCreateInput
  }


  /**
   * company update
   */
  export type companyUpdateArgs = {
    /**
     * Select specific fields to fetch from the company
    **/
    select?: companySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: companyInclude | null
    /**
     * The data needed to update a company.
    **/
    data: companyUpdateInput
    /**
     * Choose, which company to update.
    **/
    where: companyWhereUniqueInput
  }


  /**
   * company updateMany
   */
  export type companyUpdateManyArgs = {
    data: companyUpdateManyMutationInput
    where?: companyWhereInput
  }


  /**
   * company upsert
   */
  export type companyUpsertArgs = {
    /**
     * Select specific fields to fetch from the company
    **/
    select?: companySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: companyInclude | null
    /**
     * The filter to search for the company to update in case it exists.
    **/
    where: companyWhereUniqueInput
    /**
     * In case the company found by the `where` argument doesn't exist, create a new company with this data.
    **/
    create: companyCreateInput
    /**
     * In case the company was found with the provided `where` argument, update it with this data.
    **/
    update: companyUpdateInput
  }


  /**
   * company delete
   */
  export type companyDeleteArgs = {
    /**
     * Select specific fields to fetch from the company
    **/
    select?: companySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: companyInclude | null
    /**
     * Filter which company to delete.
    **/
    where: companyWhereUniqueInput
  }


  /**
   * company deleteMany
   */
  export type companyDeleteManyArgs = {
    where?: companyWhereInput
  }


  /**
   * company without action
   */
  export type companyArgs = {
    /**
     * Select specific fields to fetch from the company
    **/
    select?: companySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: companyInclude | null
  }



  /**
   * Model crop
   */


  export type AggregateCrop = {
    count: number | null
    avg: CropAvgAggregateOutputType | null
    sum: CropSumAggregateOutputType | null
    min: CropMinAggregateOutputType | null
    max: CropMaxAggregateOutputType | null
  }

  export type CropAvgAggregateOutputType = {
    id: number
    number: number
    field_id: number
  }

  export type CropSumAggregateOutputType = {
    id: number
    number: number
    field_id: number
  }

  export type CropMinAggregateOutputType = {
    id: number
    crop_type: string | null
    variety: string | null
    sowing_date: Date | null
    expected_harvest_date: Date | null
    number: number
    is_diagnosis_hired: boolean | null
    field_id: number
  }

  export type CropMaxAggregateOutputType = {
    id: number
    crop_type: string | null
    variety: string | null
    sowing_date: Date | null
    expected_harvest_date: Date | null
    number: number
    is_diagnosis_hired: boolean | null
    field_id: number
  }

  export type CropCountAggregateOutputType = {
    id: number
    crop_type: number | null
    variety: number | null
    sowing_date: number | null
    expected_harvest_date: number | null
    number: number
    is_diagnosis_hired: number | null
    field_id: number
    _all: number
  }


  export type CropAvgAggregateInputType = {
    id?: true
    number?: true
    field_id?: true
  }

  export type CropSumAggregateInputType = {
    id?: true
    number?: true
    field_id?: true
  }

  export type CropMinAggregateInputType = {
    id?: true
    crop_type?: true
    variety?: true
    sowing_date?: true
    expected_harvest_date?: true
    number?: true
    is_diagnosis_hired?: true
    field_id?: true
  }

  export type CropMaxAggregateInputType = {
    id?: true
    crop_type?: true
    variety?: true
    sowing_date?: true
    expected_harvest_date?: true
    number?: true
    is_diagnosis_hired?: true
    field_id?: true
  }

  export type CropCountAggregateInputType = {
    id?: true
    crop_type?: true
    variety?: true
    sowing_date?: true
    expected_harvest_date?: true
    number?: true
    is_diagnosis_hired?: true
    field_id?: true
    _all?: true
  }

  export type AggregateCropArgs = {
    where?: cropWhereInput
    orderBy?: Enumerable<cropOrderByInput>
    cursor?: cropWhereUniqueInput
    take?: number
    skip?: number
    count?: true
    avg?: CropAvgAggregateInputType
    sum?: CropSumAggregateInputType
    min?: CropMinAggregateInputType
    max?: CropMaxAggregateInputType
  }

  export type GetCropAggregateType<T extends AggregateCropArgs> = {
    [P in keyof T]: P extends 'count' ? number : GetCropAggregateScalarType<T[P]>
  }

  export type GetCropAggregateScalarType<T extends any> = {
    [P in keyof T]: P extends keyof CropAvgAggregateOutputType ? CropAvgAggregateOutputType[P] : never
  }

    



  export type cropSelect = {
    id?: boolean
    crop_type?: boolean
    variety?: boolean
    sowing_date?: boolean
    expected_harvest_date?: boolean
    number?: boolean
    is_diagnosis_hired?: boolean
    field_id?: boolean
    field?: boolean | fieldArgs
    diagnosis?: boolean | FindManydiagnosisArgs
  }

  export type cropInclude = {
    field?: boolean | fieldArgs
    diagnosis?: boolean | FindManydiagnosisArgs
  }

  export type cropGetPayload<
    S extends boolean | null | undefined | cropArgs,
    U = keyof S
      > = S extends true
        ? crop
    : S extends undefined
    ? never
    : S extends cropArgs | FindManycropArgs
    ?'include' extends U
    ? crop  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'field'
        ? fieldGetPayload<S['include'][P]> :
        P extends 'diagnosis'
        ? Array < diagnosisGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof crop ?crop [P]
  : 
          P extends 'field'
        ? fieldGetPayload<S['select'][P]> :
        P extends 'diagnosis'
        ? Array < diagnosisGetPayload<S['select'][P]>>  : never
  } 
    : crop
  : crop


  export interface cropDelegate {
    /**
     * Find zero or one Crop that matches the filter.
     * @param {FindUniquecropArgs} args - Arguments to find a Crop
     * @example
     * // Get one Crop
     * const crop = await prisma.crop.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FindUniquecropArgs>(
      args: Subset<T, FindUniquecropArgs>
    ): CheckSelect<T, Prisma__cropClient<crop | null>, Prisma__cropClient<cropGetPayload<T> | null>>
    /**
     * Find the first Crop that matches the filter.
     * @param {FindFirstcropArgs} args - Arguments to find a Crop
     * @example
     * // Get one Crop
     * const crop = await prisma.crop.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FindFirstcropArgs>(
      args?: Subset<T, FindFirstcropArgs>
    ): CheckSelect<T, Prisma__cropClient<crop | null>, Prisma__cropClient<cropGetPayload<T> | null>>
    /**
     * Find zero or more Crops that matches the filter.
     * @param {FindManycropArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Crops
     * const crops = await prisma.crop.findMany()
     * 
     * // Get first 10 Crops
     * const crops = await prisma.crop.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cropWithIdOnly = await prisma.crop.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FindManycropArgs>(
      args?: Subset<T, FindManycropArgs>
    ): CheckSelect<T, Promise<Array<crop>>, Promise<Array<cropGetPayload<T>>>>
    /**
     * Create a Crop.
     * @param {cropCreateArgs} args - Arguments to create a Crop.
     * @example
     * // Create one Crop
     * const Crop = await prisma.crop.create({
     *   data: {
     *     // ... data to create a Crop
     *   }
     * })
     * 
    **/
    create<T extends cropCreateArgs>(
      args: Subset<T, cropCreateArgs>
    ): CheckSelect<T, Prisma__cropClient<crop>, Prisma__cropClient<cropGetPayload<T>>>
    /**
     * Delete a Crop.
     * @param {cropDeleteArgs} args - Arguments to delete one Crop.
     * @example
     * // Delete one Crop
     * const Crop = await prisma.crop.delete({
     *   where: {
     *     // ... filter to delete one Crop
     *   }
     * })
     * 
    **/
    delete<T extends cropDeleteArgs>(
      args: Subset<T, cropDeleteArgs>
    ): CheckSelect<T, Prisma__cropClient<crop>, Prisma__cropClient<cropGetPayload<T>>>
    /**
     * Update one Crop.
     * @param {cropUpdateArgs} args - Arguments to update one Crop.
     * @example
     * // Update one Crop
     * const crop = await prisma.crop.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends cropUpdateArgs>(
      args: Subset<T, cropUpdateArgs>
    ): CheckSelect<T, Prisma__cropClient<crop>, Prisma__cropClient<cropGetPayload<T>>>
    /**
     * Delete zero or more Crops.
     * @param {cropDeleteManyArgs} args - Arguments to filter Crops to delete.
     * @example
     * // Delete a few Crops
     * const { count } = await prisma.crop.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends cropDeleteManyArgs>(
      args?: Subset<T, cropDeleteManyArgs>
    ): Promise<BatchPayload>
    /**
     * Update zero or more Crops.
     * @param {cropUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Crops
     * const crop = await prisma.crop.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends cropUpdateManyArgs>(
      args: Subset<T, cropUpdateManyArgs>
    ): Promise<BatchPayload>
    /**
     * Create or update one Crop.
     * @param {cropUpsertArgs} args - Arguments to update or create a Crop.
     * @example
     * // Update or create a Crop
     * const crop = await prisma.crop.upsert({
     *   create: {
     *     // ... data to create a Crop
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Crop we want to update
     *   }
     * })
    **/
    upsert<T extends cropUpsertArgs>(
      args: Subset<T, cropUpsertArgs>
    ): CheckSelect<T, Prisma__cropClient<crop>, Prisma__cropClient<cropGetPayload<T>>>
    /**
     * Find zero or one Crop that matches the filter.
     * @param {FindUniquecropArgs} args - Arguments to find a Crop
     * @deprecated This will be deprecated please use prisma.crop.findUnique
     * @example
     * // Get one Crop
     * const crop = await prisma.crop.findOne({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findOne<T extends FindUniquecropArgs>(
      args: Subset<T, FindUniquecropArgs>
    ): CheckSelect<T, Prisma__cropClient<crop | null>, Prisma__cropClient<cropGetPayload<T> | null>>
    /**
     * Count
     */
    count(args?: Omit<FindManycropArgs, 'select' | 'include'>): Promise<number>

  

    /**
     * Aggregate
     */
    aggregate<T extends AggregateCropArgs>(args: Subset<T, AggregateCropArgs>): Promise<GetCropAggregateType<T>>
  }

  /**
   * The delegate class that acts as a "Promise-like" for crop.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__cropClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    field<T extends fieldArgs = {}>(args?: Subset<T, fieldArgs>): CheckSelect<T, Prisma__fieldClient<field | null>, Prisma__fieldClient<fieldGetPayload<T> | null>>;

    diagnosis<T extends FindManydiagnosisArgs = {}>(args?: Subset<T, FindManydiagnosisArgs>): CheckSelect<T, Promise<Array<diagnosis>>, Promise<Array<diagnosisGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * crop findUnique
   */
  export type FindUniquecropArgs = {
    /**
     * Select specific fields to fetch from the crop
    **/
    select?: cropSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: cropInclude | null
    /**
     * Filter, which crop to fetch.
    **/
    where: cropWhereUniqueInput
  }


  /**
   * crop findFirst
   */
  export type FindFirstcropArgs = {
    /**
     * Select specific fields to fetch from the crop
    **/
    select?: cropSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: cropInclude | null
    /**
     * Filter, which crop to fetch.
    **/
    where?: cropWhereInput
    orderBy?: Enumerable<cropOrderByInput>
    cursor?: cropWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<CropScalarFieldEnum>
  }


  /**
   * crop findMany
   */
  export type FindManycropArgs = {
    /**
     * Select specific fields to fetch from the crop
    **/
    select?: cropSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: cropInclude | null
    /**
     * Filter, which crops to fetch.
    **/
    where?: cropWhereInput
    /**
     * Determine the order of the crops to fetch.
    **/
    orderBy?: Enumerable<cropOrderByInput>
    /**
     * Sets the position for listing crops.
    **/
    cursor?: cropWhereUniqueInput
    /**
     * The number of crops to fetch. If negative number, it will take crops before the `cursor`.
    **/
    take?: number
    /**
     * Skip the first `n` crops.
    **/
    skip?: number
    distinct?: Enumerable<CropScalarFieldEnum>
  }


  /**
   * crop create
   */
  export type cropCreateArgs = {
    /**
     * Select specific fields to fetch from the crop
    **/
    select?: cropSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: cropInclude | null
    /**
     * The data needed to create a crop.
    **/
    data: cropCreateInput
  }


  /**
   * crop update
   */
  export type cropUpdateArgs = {
    /**
     * Select specific fields to fetch from the crop
    **/
    select?: cropSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: cropInclude | null
    /**
     * The data needed to update a crop.
    **/
    data: cropUpdateInput
    /**
     * Choose, which crop to update.
    **/
    where: cropWhereUniqueInput
  }


  /**
   * crop updateMany
   */
  export type cropUpdateManyArgs = {
    data: cropUpdateManyMutationInput
    where?: cropWhereInput
  }


  /**
   * crop upsert
   */
  export type cropUpsertArgs = {
    /**
     * Select specific fields to fetch from the crop
    **/
    select?: cropSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: cropInclude | null
    /**
     * The filter to search for the crop to update in case it exists.
    **/
    where: cropWhereUniqueInput
    /**
     * In case the crop found by the `where` argument doesn't exist, create a new crop with this data.
    **/
    create: cropCreateInput
    /**
     * In case the crop was found with the provided `where` argument, update it with this data.
    **/
    update: cropUpdateInput
  }


  /**
   * crop delete
   */
  export type cropDeleteArgs = {
    /**
     * Select specific fields to fetch from the crop
    **/
    select?: cropSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: cropInclude | null
    /**
     * Filter which crop to delete.
    **/
    where: cropWhereUniqueInput
  }


  /**
   * crop deleteMany
   */
  export type cropDeleteManyArgs = {
    where?: cropWhereInput
  }


  /**
   * crop without action
   */
  export type cropArgs = {
    /**
     * Select specific fields to fetch from the crop
    **/
    select?: cropSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: cropInclude | null
  }



  /**
   * Model diagnosis
   */


  export type AggregateDiagnosis = {
    count: number | null
    avg: DiagnosisAvgAggregateOutputType | null
    sum: DiagnosisSumAggregateOutputType | null
    min: DiagnosisMinAggregateOutputType | null
    max: DiagnosisMaxAggregateOutputType | null
  }

  export type DiagnosisAvgAggregateOutputType = {
    id: number
    affected_area_ha: number
    crop_id: number | null
  }

  export type DiagnosisSumAggregateOutputType = {
    id: number
    affected_area_ha: number
    crop_id: number | null
  }

  export type DiagnosisMinAggregateOutputType = {
    id: number
    report_date: Date | null
    affected_area_ha: number
    crop_id: number | null
  }

  export type DiagnosisMaxAggregateOutputType = {
    id: number
    report_date: Date | null
    affected_area_ha: number
    crop_id: number | null
  }

  export type DiagnosisCountAggregateOutputType = {
    id: number
    report_date: number | null
    affected_area_ha: number
    crop_id: number | null
    _all: number
  }


  export type DiagnosisAvgAggregateInputType = {
    id?: true
    affected_area_ha?: true
    crop_id?: true
  }

  export type DiagnosisSumAggregateInputType = {
    id?: true
    affected_area_ha?: true
    crop_id?: true
  }

  export type DiagnosisMinAggregateInputType = {
    id?: true
    report_date?: true
    affected_area_ha?: true
    crop_id?: true
  }

  export type DiagnosisMaxAggregateInputType = {
    id?: true
    report_date?: true
    affected_area_ha?: true
    crop_id?: true
  }

  export type DiagnosisCountAggregateInputType = {
    id?: true
    report_date?: true
    affected_area_ha?: true
    crop_id?: true
    _all?: true
  }

  export type AggregateDiagnosisArgs = {
    where?: diagnosisWhereInput
    orderBy?: Enumerable<diagnosisOrderByInput>
    cursor?: diagnosisWhereUniqueInput
    take?: number
    skip?: number
    count?: true
    avg?: DiagnosisAvgAggregateInputType
    sum?: DiagnosisSumAggregateInputType
    min?: DiagnosisMinAggregateInputType
    max?: DiagnosisMaxAggregateInputType
  }

  export type GetDiagnosisAggregateType<T extends AggregateDiagnosisArgs> = {
    [P in keyof T]: P extends 'count' ? number : GetDiagnosisAggregateScalarType<T[P]>
  }

  export type GetDiagnosisAggregateScalarType<T extends any> = {
    [P in keyof T]: P extends keyof DiagnosisAvgAggregateOutputType ? DiagnosisAvgAggregateOutputType[P] : never
  }

    



  export type diagnosisSelect = {
    id?: boolean
    report_date?: boolean
    affected_area_ha?: boolean
    crop_id?: boolean
    crop?: boolean | cropArgs
    infestation?: boolean | FindManyinfestationArgs
    prescription?: boolean | FindManyprescriptionArgs
  }

  export type diagnosisInclude = {
    crop?: boolean | cropArgs
    infestation?: boolean | FindManyinfestationArgs
    prescription?: boolean | FindManyprescriptionArgs
  }

  export type diagnosisGetPayload<
    S extends boolean | null | undefined | diagnosisArgs,
    U = keyof S
      > = S extends true
        ? diagnosis
    : S extends undefined
    ? never
    : S extends diagnosisArgs | FindManydiagnosisArgs
    ?'include' extends U
    ? diagnosis  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'crop'
        ? cropGetPayload<S['include'][P]> | null :
        P extends 'infestation'
        ? Array < infestationGetPayload<S['include'][P]>>  :
        P extends 'prescription'
        ? Array < prescriptionGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof diagnosis ?diagnosis [P]
  : 
          P extends 'crop'
        ? cropGetPayload<S['select'][P]> | null :
        P extends 'infestation'
        ? Array < infestationGetPayload<S['select'][P]>>  :
        P extends 'prescription'
        ? Array < prescriptionGetPayload<S['select'][P]>>  : never
  } 
    : diagnosis
  : diagnosis


  export interface diagnosisDelegate {
    /**
     * Find zero or one Diagnosis that matches the filter.
     * @param {FindUniquediagnosisArgs} args - Arguments to find a Diagnosis
     * @example
     * // Get one Diagnosis
     * const diagnosis = await prisma.diagnosis.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FindUniquediagnosisArgs>(
      args: Subset<T, FindUniquediagnosisArgs>
    ): CheckSelect<T, Prisma__diagnosisClient<diagnosis | null>, Prisma__diagnosisClient<diagnosisGetPayload<T> | null>>
    /**
     * Find the first Diagnosis that matches the filter.
     * @param {FindFirstdiagnosisArgs} args - Arguments to find a Diagnosis
     * @example
     * // Get one Diagnosis
     * const diagnosis = await prisma.diagnosis.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FindFirstdiagnosisArgs>(
      args?: Subset<T, FindFirstdiagnosisArgs>
    ): CheckSelect<T, Prisma__diagnosisClient<diagnosis | null>, Prisma__diagnosisClient<diagnosisGetPayload<T> | null>>
    /**
     * Find zero or more Diagnoses that matches the filter.
     * @param {FindManydiagnosisArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Diagnoses
     * const diagnoses = await prisma.diagnosis.findMany()
     * 
     * // Get first 10 Diagnoses
     * const diagnoses = await prisma.diagnosis.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const diagnosisWithIdOnly = await prisma.diagnosis.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FindManydiagnosisArgs>(
      args?: Subset<T, FindManydiagnosisArgs>
    ): CheckSelect<T, Promise<Array<diagnosis>>, Promise<Array<diagnosisGetPayload<T>>>>
    /**
     * Create a Diagnosis.
     * @param {diagnosisCreateArgs} args - Arguments to create a Diagnosis.
     * @example
     * // Create one Diagnosis
     * const Diagnosis = await prisma.diagnosis.create({
     *   data: {
     *     // ... data to create a Diagnosis
     *   }
     * })
     * 
    **/
    create<T extends diagnosisCreateArgs>(
      args: Subset<T, diagnosisCreateArgs>
    ): CheckSelect<T, Prisma__diagnosisClient<diagnosis>, Prisma__diagnosisClient<diagnosisGetPayload<T>>>
    /**
     * Delete a Diagnosis.
     * @param {diagnosisDeleteArgs} args - Arguments to delete one Diagnosis.
     * @example
     * // Delete one Diagnosis
     * const Diagnosis = await prisma.diagnosis.delete({
     *   where: {
     *     // ... filter to delete one Diagnosis
     *   }
     * })
     * 
    **/
    delete<T extends diagnosisDeleteArgs>(
      args: Subset<T, diagnosisDeleteArgs>
    ): CheckSelect<T, Prisma__diagnosisClient<diagnosis>, Prisma__diagnosisClient<diagnosisGetPayload<T>>>
    /**
     * Update one Diagnosis.
     * @param {diagnosisUpdateArgs} args - Arguments to update one Diagnosis.
     * @example
     * // Update one Diagnosis
     * const diagnosis = await prisma.diagnosis.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends diagnosisUpdateArgs>(
      args: Subset<T, diagnosisUpdateArgs>
    ): CheckSelect<T, Prisma__diagnosisClient<diagnosis>, Prisma__diagnosisClient<diagnosisGetPayload<T>>>
    /**
     * Delete zero or more Diagnoses.
     * @param {diagnosisDeleteManyArgs} args - Arguments to filter Diagnoses to delete.
     * @example
     * // Delete a few Diagnoses
     * const { count } = await prisma.diagnosis.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends diagnosisDeleteManyArgs>(
      args?: Subset<T, diagnosisDeleteManyArgs>
    ): Promise<BatchPayload>
    /**
     * Update zero or more Diagnoses.
     * @param {diagnosisUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Diagnoses
     * const diagnosis = await prisma.diagnosis.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends diagnosisUpdateManyArgs>(
      args: Subset<T, diagnosisUpdateManyArgs>
    ): Promise<BatchPayload>
    /**
     * Create or update one Diagnosis.
     * @param {diagnosisUpsertArgs} args - Arguments to update or create a Diagnosis.
     * @example
     * // Update or create a Diagnosis
     * const diagnosis = await prisma.diagnosis.upsert({
     *   create: {
     *     // ... data to create a Diagnosis
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Diagnosis we want to update
     *   }
     * })
    **/
    upsert<T extends diagnosisUpsertArgs>(
      args: Subset<T, diagnosisUpsertArgs>
    ): CheckSelect<T, Prisma__diagnosisClient<diagnosis>, Prisma__diagnosisClient<diagnosisGetPayload<T>>>
    /**
     * Find zero or one Diagnosis that matches the filter.
     * @param {FindUniquediagnosisArgs} args - Arguments to find a Diagnosis
     * @deprecated This will be deprecated please use prisma.diagnosis.findUnique
     * @example
     * // Get one Diagnosis
     * const diagnosis = await prisma.diagnosis.findOne({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findOne<T extends FindUniquediagnosisArgs>(
      args: Subset<T, FindUniquediagnosisArgs>
    ): CheckSelect<T, Prisma__diagnosisClient<diagnosis | null>, Prisma__diagnosisClient<diagnosisGetPayload<T> | null>>
    /**
     * Count
     */
    count(args?: Omit<FindManydiagnosisArgs, 'select' | 'include'>): Promise<number>

  

    /**
     * Aggregate
     */
    aggregate<T extends AggregateDiagnosisArgs>(args: Subset<T, AggregateDiagnosisArgs>): Promise<GetDiagnosisAggregateType<T>>
  }

  /**
   * The delegate class that acts as a "Promise-like" for diagnosis.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__diagnosisClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    crop<T extends cropArgs = {}>(args?: Subset<T, cropArgs>): CheckSelect<T, Prisma__cropClient<crop | null>, Prisma__cropClient<cropGetPayload<T> | null>>;

    infestation<T extends FindManyinfestationArgs = {}>(args?: Subset<T, FindManyinfestationArgs>): CheckSelect<T, Promise<Array<infestation>>, Promise<Array<infestationGetPayload<T>>>>;

    prescription<T extends FindManyprescriptionArgs = {}>(args?: Subset<T, FindManyprescriptionArgs>): CheckSelect<T, Promise<Array<prescription>>, Promise<Array<prescriptionGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * diagnosis findUnique
   */
  export type FindUniquediagnosisArgs = {
    /**
     * Select specific fields to fetch from the diagnosis
    **/
    select?: diagnosisSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: diagnosisInclude | null
    /**
     * Filter, which diagnosis to fetch.
    **/
    where: diagnosisWhereUniqueInput
  }


  /**
   * diagnosis findFirst
   */
  export type FindFirstdiagnosisArgs = {
    /**
     * Select specific fields to fetch from the diagnosis
    **/
    select?: diagnosisSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: diagnosisInclude | null
    /**
     * Filter, which diagnosis to fetch.
    **/
    where?: diagnosisWhereInput
    orderBy?: Enumerable<diagnosisOrderByInput>
    cursor?: diagnosisWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<DiagnosisScalarFieldEnum>
  }


  /**
   * diagnosis findMany
   */
  export type FindManydiagnosisArgs = {
    /**
     * Select specific fields to fetch from the diagnosis
    **/
    select?: diagnosisSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: diagnosisInclude | null
    /**
     * Filter, which diagnoses to fetch.
    **/
    where?: diagnosisWhereInput
    /**
     * Determine the order of the diagnoses to fetch.
    **/
    orderBy?: Enumerable<diagnosisOrderByInput>
    /**
     * Sets the position for listing diagnoses.
    **/
    cursor?: diagnosisWhereUniqueInput
    /**
     * The number of diagnoses to fetch. If negative number, it will take diagnoses before the `cursor`.
    **/
    take?: number
    /**
     * Skip the first `n` diagnoses.
    **/
    skip?: number
    distinct?: Enumerable<DiagnosisScalarFieldEnum>
  }


  /**
   * diagnosis create
   */
  export type diagnosisCreateArgs = {
    /**
     * Select specific fields to fetch from the diagnosis
    **/
    select?: diagnosisSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: diagnosisInclude | null
    /**
     * The data needed to create a diagnosis.
    **/
    data: diagnosisCreateInput
  }


  /**
   * diagnosis update
   */
  export type diagnosisUpdateArgs = {
    /**
     * Select specific fields to fetch from the diagnosis
    **/
    select?: diagnosisSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: diagnosisInclude | null
    /**
     * The data needed to update a diagnosis.
    **/
    data: diagnosisUpdateInput
    /**
     * Choose, which diagnosis to update.
    **/
    where: diagnosisWhereUniqueInput
  }


  /**
   * diagnosis updateMany
   */
  export type diagnosisUpdateManyArgs = {
    data: diagnosisUpdateManyMutationInput
    where?: diagnosisWhereInput
  }


  /**
   * diagnosis upsert
   */
  export type diagnosisUpsertArgs = {
    /**
     * Select specific fields to fetch from the diagnosis
    **/
    select?: diagnosisSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: diagnosisInclude | null
    /**
     * The filter to search for the diagnosis to update in case it exists.
    **/
    where: diagnosisWhereUniqueInput
    /**
     * In case the diagnosis found by the `where` argument doesn't exist, create a new diagnosis with this data.
    **/
    create: diagnosisCreateInput
    /**
     * In case the diagnosis was found with the provided `where` argument, update it with this data.
    **/
    update: diagnosisUpdateInput
  }


  /**
   * diagnosis delete
   */
  export type diagnosisDeleteArgs = {
    /**
     * Select specific fields to fetch from the diagnosis
    **/
    select?: diagnosisSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: diagnosisInclude | null
    /**
     * Filter which diagnosis to delete.
    **/
    where: diagnosisWhereUniqueInput
  }


  /**
   * diagnosis deleteMany
   */
  export type diagnosisDeleteManyArgs = {
    where?: diagnosisWhereInput
  }


  /**
   * diagnosis without action
   */
  export type diagnosisArgs = {
    /**
     * Select specific fields to fetch from the diagnosis
    **/
    select?: diagnosisSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: diagnosisInclude | null
  }



  /**
   * Model email
   */


  export type AggregateEmail = {
    count: number | null
    avg: EmailAvgAggregateOutputType | null
    sum: EmailSumAggregateOutputType | null
    min: EmailMinAggregateOutputType | null
    max: EmailMaxAggregateOutputType | null
  }

  export type EmailAvgAggregateOutputType = {
    id: number
  }

  export type EmailSumAggregateOutputType = {
    id: number
  }

  export type EmailMinAggregateOutputType = {
    id: number
    email: string | null
  }

  export type EmailMaxAggregateOutputType = {
    id: number
    email: string | null
  }

  export type EmailCountAggregateOutputType = {
    id: number
    email: number | null
    _all: number
  }


  export type EmailAvgAggregateInputType = {
    id?: true
  }

  export type EmailSumAggregateInputType = {
    id?: true
  }

  export type EmailMinAggregateInputType = {
    id?: true
    email?: true
  }

  export type EmailMaxAggregateInputType = {
    id?: true
    email?: true
  }

  export type EmailCountAggregateInputType = {
    id?: true
    email?: true
    _all?: true
  }

  export type AggregateEmailArgs = {
    where?: emailWhereInput
    orderBy?: Enumerable<emailOrderByInput>
    cursor?: emailWhereUniqueInput
    take?: number
    skip?: number
    count?: true
    avg?: EmailAvgAggregateInputType
    sum?: EmailSumAggregateInputType
    min?: EmailMinAggregateInputType
    max?: EmailMaxAggregateInputType
  }

  export type GetEmailAggregateType<T extends AggregateEmailArgs> = {
    [P in keyof T]: P extends 'count' ? number : GetEmailAggregateScalarType<T[P]>
  }

  export type GetEmailAggregateScalarType<T extends any> = {
    [P in keyof T]: P extends keyof EmailAvgAggregateOutputType ? EmailAvgAggregateOutputType[P] : never
  }

    



  export type emailSelect = {
    id?: boolean
    email?: boolean
  }

  export type emailGetPayload<
    S extends boolean | null | undefined | emailArgs,
    U = keyof S
      > = S extends true
        ? email
    : S extends undefined
    ? never
    : S extends emailArgs | FindManyemailArgs
    ?'include' extends U
    ? email 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof email ?email [P]
  : 
     never
  } 
    : email
  : email


  export interface emailDelegate {
    /**
     * Find zero or one Email that matches the filter.
     * @param {FindUniqueemailArgs} args - Arguments to find a Email
     * @example
     * // Get one Email
     * const email = await prisma.email.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FindUniqueemailArgs>(
      args: Subset<T, FindUniqueemailArgs>
    ): CheckSelect<T, Prisma__emailClient<email | null>, Prisma__emailClient<emailGetPayload<T> | null>>
    /**
     * Find the first Email that matches the filter.
     * @param {FindFirstemailArgs} args - Arguments to find a Email
     * @example
     * // Get one Email
     * const email = await prisma.email.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FindFirstemailArgs>(
      args?: Subset<T, FindFirstemailArgs>
    ): CheckSelect<T, Prisma__emailClient<email | null>, Prisma__emailClient<emailGetPayload<T> | null>>
    /**
     * Find zero or more Emails that matches the filter.
     * @param {FindManyemailArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Emails
     * const emails = await prisma.email.findMany()
     * 
     * // Get first 10 Emails
     * const emails = await prisma.email.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailWithIdOnly = await prisma.email.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FindManyemailArgs>(
      args?: Subset<T, FindManyemailArgs>
    ): CheckSelect<T, Promise<Array<email>>, Promise<Array<emailGetPayload<T>>>>
    /**
     * Create a Email.
     * @param {emailCreateArgs} args - Arguments to create a Email.
     * @example
     * // Create one Email
     * const Email = await prisma.email.create({
     *   data: {
     *     // ... data to create a Email
     *   }
     * })
     * 
    **/
    create<T extends emailCreateArgs>(
      args: Subset<T, emailCreateArgs>
    ): CheckSelect<T, Prisma__emailClient<email>, Prisma__emailClient<emailGetPayload<T>>>
    /**
     * Delete a Email.
     * @param {emailDeleteArgs} args - Arguments to delete one Email.
     * @example
     * // Delete one Email
     * const Email = await prisma.email.delete({
     *   where: {
     *     // ... filter to delete one Email
     *   }
     * })
     * 
    **/
    delete<T extends emailDeleteArgs>(
      args: Subset<T, emailDeleteArgs>
    ): CheckSelect<T, Prisma__emailClient<email>, Prisma__emailClient<emailGetPayload<T>>>
    /**
     * Update one Email.
     * @param {emailUpdateArgs} args - Arguments to update one Email.
     * @example
     * // Update one Email
     * const email = await prisma.email.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends emailUpdateArgs>(
      args: Subset<T, emailUpdateArgs>
    ): CheckSelect<T, Prisma__emailClient<email>, Prisma__emailClient<emailGetPayload<T>>>
    /**
     * Delete zero or more Emails.
     * @param {emailDeleteManyArgs} args - Arguments to filter Emails to delete.
     * @example
     * // Delete a few Emails
     * const { count } = await prisma.email.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends emailDeleteManyArgs>(
      args?: Subset<T, emailDeleteManyArgs>
    ): Promise<BatchPayload>
    /**
     * Update zero or more Emails.
     * @param {emailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Emails
     * const email = await prisma.email.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends emailUpdateManyArgs>(
      args: Subset<T, emailUpdateManyArgs>
    ): Promise<BatchPayload>
    /**
     * Create or update one Email.
     * @param {emailUpsertArgs} args - Arguments to update or create a Email.
     * @example
     * // Update or create a Email
     * const email = await prisma.email.upsert({
     *   create: {
     *     // ... data to create a Email
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Email we want to update
     *   }
     * })
    **/
    upsert<T extends emailUpsertArgs>(
      args: Subset<T, emailUpsertArgs>
    ): CheckSelect<T, Prisma__emailClient<email>, Prisma__emailClient<emailGetPayload<T>>>
    /**
     * Find zero or one Email that matches the filter.
     * @param {FindUniqueemailArgs} args - Arguments to find a Email
     * @deprecated This will be deprecated please use prisma.email.findUnique
     * @example
     * // Get one Email
     * const email = await prisma.email.findOne({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findOne<T extends FindUniqueemailArgs>(
      args: Subset<T, FindUniqueemailArgs>
    ): CheckSelect<T, Prisma__emailClient<email | null>, Prisma__emailClient<emailGetPayload<T> | null>>
    /**
     * Count
     */
    count(args?: Omit<FindManyemailArgs, 'select' | 'include'>): Promise<number>

  

    /**
     * Aggregate
     */
    aggregate<T extends AggregateEmailArgs>(args: Subset<T, AggregateEmailArgs>): Promise<GetEmailAggregateType<T>>
  }

  /**
   * The delegate class that acts as a "Promise-like" for email.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__emailClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * email findUnique
   */
  export type FindUniqueemailArgs = {
    /**
     * Select specific fields to fetch from the email
    **/
    select?: emailSelect | null
    /**
     * Filter, which email to fetch.
    **/
    where: emailWhereUniqueInput
  }


  /**
   * email findFirst
   */
  export type FindFirstemailArgs = {
    /**
     * Select specific fields to fetch from the email
    **/
    select?: emailSelect | null
    /**
     * Filter, which email to fetch.
    **/
    where?: emailWhereInput
    orderBy?: Enumerable<emailOrderByInput>
    cursor?: emailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<EmailScalarFieldEnum>
  }


  /**
   * email findMany
   */
  export type FindManyemailArgs = {
    /**
     * Select specific fields to fetch from the email
    **/
    select?: emailSelect | null
    /**
     * Filter, which emails to fetch.
    **/
    where?: emailWhereInput
    /**
     * Determine the order of the emails to fetch.
    **/
    orderBy?: Enumerable<emailOrderByInput>
    /**
     * Sets the position for listing emails.
    **/
    cursor?: emailWhereUniqueInput
    /**
     * The number of emails to fetch. If negative number, it will take emails before the `cursor`.
    **/
    take?: number
    /**
     * Skip the first `n` emails.
    **/
    skip?: number
    distinct?: Enumerable<EmailScalarFieldEnum>
  }


  /**
   * email create
   */
  export type emailCreateArgs = {
    /**
     * Select specific fields to fetch from the email
    **/
    select?: emailSelect | null
    /**
     * The data needed to create a email.
    **/
    data: emailCreateInput
  }


  /**
   * email update
   */
  export type emailUpdateArgs = {
    /**
     * Select specific fields to fetch from the email
    **/
    select?: emailSelect | null
    /**
     * The data needed to update a email.
    **/
    data: emailUpdateInput
    /**
     * Choose, which email to update.
    **/
    where: emailWhereUniqueInput
  }


  /**
   * email updateMany
   */
  export type emailUpdateManyArgs = {
    data: emailUpdateManyMutationInput
    where?: emailWhereInput
  }


  /**
   * email upsert
   */
  export type emailUpsertArgs = {
    /**
     * Select specific fields to fetch from the email
    **/
    select?: emailSelect | null
    /**
     * The filter to search for the email to update in case it exists.
    **/
    where: emailWhereUniqueInput
    /**
     * In case the email found by the `where` argument doesn't exist, create a new email with this data.
    **/
    create: emailCreateInput
    /**
     * In case the email was found with the provided `where` argument, update it with this data.
    **/
    update: emailUpdateInput
  }


  /**
   * email delete
   */
  export type emailDeleteArgs = {
    /**
     * Select specific fields to fetch from the email
    **/
    select?: emailSelect | null
    /**
     * Filter which email to delete.
    **/
    where: emailWhereUniqueInput
  }


  /**
   * email deleteMany
   */
  export type emailDeleteManyArgs = {
    where?: emailWhereInput
  }


  /**
   * email without action
   */
  export type emailArgs = {
    /**
     * Select specific fields to fetch from the email
    **/
    select?: emailSelect | null
  }



  /**
   * Model farm
   */


  export type AggregateFarm = {
    count: number | null
    avg: FarmAvgAggregateOutputType | null
    sum: FarmSumAggregateOutputType | null
    min: FarmMinAggregateOutputType | null
    max: FarmMaxAggregateOutputType | null
  }

  export type FarmAvgAggregateOutputType = {
    id: number
    lat: number | null
    long: number | null
    address_id: number
  }

  export type FarmSumAggregateOutputType = {
    id: number
    lat: number | null
    long: number | null
    address_id: number
  }

  export type FarmMinAggregateOutputType = {
    id: number
    cnpj: string | null
    social_name: string | null
    fantasy_name: string | null
    lat: number | null
    long: number | null
    address_id: number
  }

  export type FarmMaxAggregateOutputType = {
    id: number
    cnpj: string | null
    social_name: string | null
    fantasy_name: string | null
    lat: number | null
    long: number | null
    address_id: number
  }

  export type FarmCountAggregateOutputType = {
    id: number
    cnpj: number | null
    social_name: number | null
    fantasy_name: number | null
    lat: number | null
    long: number | null
    address_id: number
    _all: number
  }


  export type FarmAvgAggregateInputType = {
    id?: true
    lat?: true
    long?: true
    address_id?: true
  }

  export type FarmSumAggregateInputType = {
    id?: true
    lat?: true
    long?: true
    address_id?: true
  }

  export type FarmMinAggregateInputType = {
    id?: true
    cnpj?: true
    social_name?: true
    fantasy_name?: true
    lat?: true
    long?: true
    address_id?: true
  }

  export type FarmMaxAggregateInputType = {
    id?: true
    cnpj?: true
    social_name?: true
    fantasy_name?: true
    lat?: true
    long?: true
    address_id?: true
  }

  export type FarmCountAggregateInputType = {
    id?: true
    cnpj?: true
    social_name?: true
    fantasy_name?: true
    lat?: true
    long?: true
    address_id?: true
    _all?: true
  }

  export type AggregateFarmArgs = {
    where?: farmWhereInput
    orderBy?: Enumerable<farmOrderByInput>
    cursor?: farmWhereUniqueInput
    take?: number
    skip?: number
    count?: true
    avg?: FarmAvgAggregateInputType
    sum?: FarmSumAggregateInputType
    min?: FarmMinAggregateInputType
    max?: FarmMaxAggregateInputType
  }

  export type GetFarmAggregateType<T extends AggregateFarmArgs> = {
    [P in keyof T]: P extends 'count' ? number : GetFarmAggregateScalarType<T[P]>
  }

  export type GetFarmAggregateScalarType<T extends any> = {
    [P in keyof T]: P extends keyof FarmAvgAggregateOutputType ? FarmAvgAggregateOutputType[P] : never
  }

    



  export type farmSelect = {
    id?: boolean
    cnpj?: boolean
    social_name?: boolean
    fantasy_name?: boolean
    lat?: boolean
    long?: boolean
    address_id?: boolean
    address?: boolean | addressArgs
    area?: boolean | FindManyareaArgs
    imaging?: boolean | FindManyimagingArgs
    many_user_has_many_farm?: boolean | FindManymany_user_has_many_farmArgs
  }

  export type farmInclude = {
    address?: boolean | addressArgs
    area?: boolean | FindManyareaArgs
    imaging?: boolean | FindManyimagingArgs
    many_user_has_many_farm?: boolean | FindManymany_user_has_many_farmArgs
  }

  export type farmGetPayload<
    S extends boolean | null | undefined | farmArgs,
    U = keyof S
      > = S extends true
        ? farm
    : S extends undefined
    ? never
    : S extends farmArgs | FindManyfarmArgs
    ?'include' extends U
    ? farm  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'address'
        ? addressGetPayload<S['include'][P]> :
        P extends 'area'
        ? Array < areaGetPayload<S['include'][P]>>  :
        P extends 'imaging'
        ? Array < imagingGetPayload<S['include'][P]>>  :
        P extends 'many_user_has_many_farm'
        ? Array < many_user_has_many_farmGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof farm ?farm [P]
  : 
          P extends 'address'
        ? addressGetPayload<S['select'][P]> :
        P extends 'area'
        ? Array < areaGetPayload<S['select'][P]>>  :
        P extends 'imaging'
        ? Array < imagingGetPayload<S['select'][P]>>  :
        P extends 'many_user_has_many_farm'
        ? Array < many_user_has_many_farmGetPayload<S['select'][P]>>  : never
  } 
    : farm
  : farm


  export interface farmDelegate {
    /**
     * Find zero or one Farm that matches the filter.
     * @param {FindUniquefarmArgs} args - Arguments to find a Farm
     * @example
     * // Get one Farm
     * const farm = await prisma.farm.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FindUniquefarmArgs>(
      args: Subset<T, FindUniquefarmArgs>
    ): CheckSelect<T, Prisma__farmClient<farm | null>, Prisma__farmClient<farmGetPayload<T> | null>>
    /**
     * Find the first Farm that matches the filter.
     * @param {FindFirstfarmArgs} args - Arguments to find a Farm
     * @example
     * // Get one Farm
     * const farm = await prisma.farm.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FindFirstfarmArgs>(
      args?: Subset<T, FindFirstfarmArgs>
    ): CheckSelect<T, Prisma__farmClient<farm | null>, Prisma__farmClient<farmGetPayload<T> | null>>
    /**
     * Find zero or more Farms that matches the filter.
     * @param {FindManyfarmArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Farms
     * const farms = await prisma.farm.findMany()
     * 
     * // Get first 10 Farms
     * const farms = await prisma.farm.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const farmWithIdOnly = await prisma.farm.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FindManyfarmArgs>(
      args?: Subset<T, FindManyfarmArgs>
    ): CheckSelect<T, Promise<Array<farm>>, Promise<Array<farmGetPayload<T>>>>
    /**
     * Create a Farm.
     * @param {farmCreateArgs} args - Arguments to create a Farm.
     * @example
     * // Create one Farm
     * const Farm = await prisma.farm.create({
     *   data: {
     *     // ... data to create a Farm
     *   }
     * })
     * 
    **/
    create<T extends farmCreateArgs>(
      args: Subset<T, farmCreateArgs>
    ): CheckSelect<T, Prisma__farmClient<farm>, Prisma__farmClient<farmGetPayload<T>>>
    /**
     * Delete a Farm.
     * @param {farmDeleteArgs} args - Arguments to delete one Farm.
     * @example
     * // Delete one Farm
     * const Farm = await prisma.farm.delete({
     *   where: {
     *     // ... filter to delete one Farm
     *   }
     * })
     * 
    **/
    delete<T extends farmDeleteArgs>(
      args: Subset<T, farmDeleteArgs>
    ): CheckSelect<T, Prisma__farmClient<farm>, Prisma__farmClient<farmGetPayload<T>>>
    /**
     * Update one Farm.
     * @param {farmUpdateArgs} args - Arguments to update one Farm.
     * @example
     * // Update one Farm
     * const farm = await prisma.farm.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends farmUpdateArgs>(
      args: Subset<T, farmUpdateArgs>
    ): CheckSelect<T, Prisma__farmClient<farm>, Prisma__farmClient<farmGetPayload<T>>>
    /**
     * Delete zero or more Farms.
     * @param {farmDeleteManyArgs} args - Arguments to filter Farms to delete.
     * @example
     * // Delete a few Farms
     * const { count } = await prisma.farm.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends farmDeleteManyArgs>(
      args?: Subset<T, farmDeleteManyArgs>
    ): Promise<BatchPayload>
    /**
     * Update zero or more Farms.
     * @param {farmUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Farms
     * const farm = await prisma.farm.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends farmUpdateManyArgs>(
      args: Subset<T, farmUpdateManyArgs>
    ): Promise<BatchPayload>
    /**
     * Create or update one Farm.
     * @param {farmUpsertArgs} args - Arguments to update or create a Farm.
     * @example
     * // Update or create a Farm
     * const farm = await prisma.farm.upsert({
     *   create: {
     *     // ... data to create a Farm
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Farm we want to update
     *   }
     * })
    **/
    upsert<T extends farmUpsertArgs>(
      args: Subset<T, farmUpsertArgs>
    ): CheckSelect<T, Prisma__farmClient<farm>, Prisma__farmClient<farmGetPayload<T>>>
    /**
     * Find zero or one Farm that matches the filter.
     * @param {FindUniquefarmArgs} args - Arguments to find a Farm
     * @deprecated This will be deprecated please use prisma.farm.findUnique
     * @example
     * // Get one Farm
     * const farm = await prisma.farm.findOne({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findOne<T extends FindUniquefarmArgs>(
      args: Subset<T, FindUniquefarmArgs>
    ): CheckSelect<T, Prisma__farmClient<farm | null>, Prisma__farmClient<farmGetPayload<T> | null>>
    /**
     * Count
     */
    count(args?: Omit<FindManyfarmArgs, 'select' | 'include'>): Promise<number>

  

    /**
     * Aggregate
     */
    aggregate<T extends AggregateFarmArgs>(args: Subset<T, AggregateFarmArgs>): Promise<GetFarmAggregateType<T>>
  }

  /**
   * The delegate class that acts as a "Promise-like" for farm.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__farmClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    address<T extends addressArgs = {}>(args?: Subset<T, addressArgs>): CheckSelect<T, Prisma__addressClient<address | null>, Prisma__addressClient<addressGetPayload<T> | null>>;

    area<T extends FindManyareaArgs = {}>(args?: Subset<T, FindManyareaArgs>): CheckSelect<T, Promise<Array<area>>, Promise<Array<areaGetPayload<T>>>>;

    imaging<T extends FindManyimagingArgs = {}>(args?: Subset<T, FindManyimagingArgs>): CheckSelect<T, Promise<Array<imaging>>, Promise<Array<imagingGetPayload<T>>>>;

    many_user_has_many_farm<T extends FindManymany_user_has_many_farmArgs = {}>(args?: Subset<T, FindManymany_user_has_many_farmArgs>): CheckSelect<T, Promise<Array<many_user_has_many_farm>>, Promise<Array<many_user_has_many_farmGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * farm findUnique
   */
  export type FindUniquefarmArgs = {
    /**
     * Select specific fields to fetch from the farm
    **/
    select?: farmSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: farmInclude | null
    /**
     * Filter, which farm to fetch.
    **/
    where: farmWhereUniqueInput
  }


  /**
   * farm findFirst
   */
  export type FindFirstfarmArgs = {
    /**
     * Select specific fields to fetch from the farm
    **/
    select?: farmSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: farmInclude | null
    /**
     * Filter, which farm to fetch.
    **/
    where?: farmWhereInput
    orderBy?: Enumerable<farmOrderByInput>
    cursor?: farmWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<FarmScalarFieldEnum>
  }


  /**
   * farm findMany
   */
  export type FindManyfarmArgs = {
    /**
     * Select specific fields to fetch from the farm
    **/
    select?: farmSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: farmInclude | null
    /**
     * Filter, which farms to fetch.
    **/
    where?: farmWhereInput
    /**
     * Determine the order of the farms to fetch.
    **/
    orderBy?: Enumerable<farmOrderByInput>
    /**
     * Sets the position for listing farms.
    **/
    cursor?: farmWhereUniqueInput
    /**
     * The number of farms to fetch. If negative number, it will take farms before the `cursor`.
    **/
    take?: number
    /**
     * Skip the first `n` farms.
    **/
    skip?: number
    distinct?: Enumerable<FarmScalarFieldEnum>
  }


  /**
   * farm create
   */
  export type farmCreateArgs = {
    /**
     * Select specific fields to fetch from the farm
    **/
    select?: farmSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: farmInclude | null
    /**
     * The data needed to create a farm.
    **/
    data: farmCreateInput
  }


  /**
   * farm update
   */
  export type farmUpdateArgs = {
    /**
     * Select specific fields to fetch from the farm
    **/
    select?: farmSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: farmInclude | null
    /**
     * The data needed to update a farm.
    **/
    data: farmUpdateInput
    /**
     * Choose, which farm to update.
    **/
    where: farmWhereUniqueInput
  }


  /**
   * farm updateMany
   */
  export type farmUpdateManyArgs = {
    data: farmUpdateManyMutationInput
    where?: farmWhereInput
  }


  /**
   * farm upsert
   */
  export type farmUpsertArgs = {
    /**
     * Select specific fields to fetch from the farm
    **/
    select?: farmSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: farmInclude | null
    /**
     * The filter to search for the farm to update in case it exists.
    **/
    where: farmWhereUniqueInput
    /**
     * In case the farm found by the `where` argument doesn't exist, create a new farm with this data.
    **/
    create: farmCreateInput
    /**
     * In case the farm was found with the provided `where` argument, update it with this data.
    **/
    update: farmUpdateInput
  }


  /**
   * farm delete
   */
  export type farmDeleteArgs = {
    /**
     * Select specific fields to fetch from the farm
    **/
    select?: farmSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: farmInclude | null
    /**
     * Filter which farm to delete.
    **/
    where: farmWhereUniqueInput
  }


  /**
   * farm deleteMany
   */
  export type farmDeleteManyArgs = {
    where?: farmWhereInput
  }


  /**
   * farm without action
   */
  export type farmArgs = {
    /**
     * Select specific fields to fetch from the farm
    **/
    select?: farmSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: farmInclude | null
  }



  /**
   * Model field
   */


  export type AggregateField = {
    count: number | null
    avg: FieldAvgAggregateOutputType | null
    sum: FieldSumAggregateOutputType | null
    min: FieldMinAggregateOutputType | null
    max: FieldMaxAggregateOutputType | null
  }

  export type FieldAvgAggregateOutputType = {
    id: number
    code: number
    area_ha: number
    lat: number
    long: number
    area_id: number
    visiona_area_id: number | null
  }

  export type FieldSumAggregateOutputType = {
    id: number
    code: number
    area_ha: number
    lat: number
    long: number
    area_id: number
    visiona_area_id: number | null
  }

  export type FieldMinAggregateOutputType = {
    id: number
    code: number
    area_ha: number
    lat: number
    long: number
    coordinates: JsonValue | null
    name: string | null
    image_uri: string | null
    area_id: number
    visiona_area_id: number | null
    event: string | null
  }

  export type FieldMaxAggregateOutputType = {
    id: number
    code: number
    area_ha: number
    lat: number
    long: number
    coordinates: JsonValue | null
    name: string | null
    image_uri: string | null
    area_id: number
    visiona_area_id: number | null
    event: string | null
  }

  export type FieldCountAggregateOutputType = {
    id: number
    code: number
    area_ha: number
    lat: number
    long: number
    coordinates: number | null
    name: number | null
    image_uri: number | null
    area_id: number
    visiona_area_id: number | null
    event: number | null
    _all: number
  }


  export type FieldAvgAggregateInputType = {
    id?: true
    code?: true
    area_ha?: true
    lat?: true
    long?: true
    area_id?: true
    visiona_area_id?: true
  }

  export type FieldSumAggregateInputType = {
    id?: true
    code?: true
    area_ha?: true
    lat?: true
    long?: true
    area_id?: true
    visiona_area_id?: true
  }

  export type FieldMinAggregateInputType = {
    id?: true
    code?: true
    area_ha?: true
    lat?: true
    long?: true
    coordinates?: true
    name?: true
    image_uri?: true
    area_id?: true
    visiona_area_id?: true
    event?: true
  }

  export type FieldMaxAggregateInputType = {
    id?: true
    code?: true
    area_ha?: true
    lat?: true
    long?: true
    coordinates?: true
    name?: true
    image_uri?: true
    area_id?: true
    visiona_area_id?: true
    event?: true
  }

  export type FieldCountAggregateInputType = {
    id?: true
    code?: true
    area_ha?: true
    lat?: true
    long?: true
    coordinates?: true
    name?: true
    image_uri?: true
    area_id?: true
    visiona_area_id?: true
    event?: true
    _all?: true
  }

  export type AggregateFieldArgs = {
    where?: fieldWhereInput
    orderBy?: Enumerable<fieldOrderByInput>
    cursor?: fieldWhereUniqueInput
    take?: number
    skip?: number
    count?: true
    avg?: FieldAvgAggregateInputType
    sum?: FieldSumAggregateInputType
    min?: FieldMinAggregateInputType
    max?: FieldMaxAggregateInputType
  }

  export type GetFieldAggregateType<T extends AggregateFieldArgs> = {
    [P in keyof T]: P extends 'count' ? number : GetFieldAggregateScalarType<T[P]>
  }

  export type GetFieldAggregateScalarType<T extends any> = {
    [P in keyof T]: P extends keyof FieldAvgAggregateOutputType ? FieldAvgAggregateOutputType[P] : never
  }

    



  export type fieldSelect = {
    id?: boolean
    code?: boolean
    area_ha?: boolean
    lat?: boolean
    long?: boolean
    coordinates?: boolean
    name?: boolean
    image_uri?: boolean
    area_id?: boolean
    visiona_area_id?: boolean
    event?: boolean
    area?: boolean | areaArgs
    crop?: boolean | FindManycropArgs
    many_quotation_modal_package_has_many_field?: boolean | FindManymany_quotation_modal_package_has_many_fieldArgs
  }

  export type fieldInclude = {
    area?: boolean | areaArgs
    crop?: boolean | FindManycropArgs
    many_quotation_modal_package_has_many_field?: boolean | FindManymany_quotation_modal_package_has_many_fieldArgs
  }

  export type fieldGetPayload<
    S extends boolean | null | undefined | fieldArgs,
    U = keyof S
      > = S extends true
        ? field
    : S extends undefined
    ? never
    : S extends fieldArgs | FindManyfieldArgs
    ?'include' extends U
    ? field  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'area'
        ? areaGetPayload<S['include'][P]> :
        P extends 'crop'
        ? Array < cropGetPayload<S['include'][P]>>  :
        P extends 'many_quotation_modal_package_has_many_field'
        ? Array < many_quotation_modal_package_has_many_fieldGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof field ?field [P]
  : 
          P extends 'area'
        ? areaGetPayload<S['select'][P]> :
        P extends 'crop'
        ? Array < cropGetPayload<S['select'][P]>>  :
        P extends 'many_quotation_modal_package_has_many_field'
        ? Array < many_quotation_modal_package_has_many_fieldGetPayload<S['select'][P]>>  : never
  } 
    : field
  : field


  export interface fieldDelegate {
    /**
     * Find zero or one Field that matches the filter.
     * @param {FindUniquefieldArgs} args - Arguments to find a Field
     * @example
     * // Get one Field
     * const field = await prisma.field.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FindUniquefieldArgs>(
      args: Subset<T, FindUniquefieldArgs>
    ): CheckSelect<T, Prisma__fieldClient<field | null>, Prisma__fieldClient<fieldGetPayload<T> | null>>
    /**
     * Find the first Field that matches the filter.
     * @param {FindFirstfieldArgs} args - Arguments to find a Field
     * @example
     * // Get one Field
     * const field = await prisma.field.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FindFirstfieldArgs>(
      args?: Subset<T, FindFirstfieldArgs>
    ): CheckSelect<T, Prisma__fieldClient<field | null>, Prisma__fieldClient<fieldGetPayload<T> | null>>
    /**
     * Find zero or more Fields that matches the filter.
     * @param {FindManyfieldArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Fields
     * const fields = await prisma.field.findMany()
     * 
     * // Get first 10 Fields
     * const fields = await prisma.field.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fieldWithIdOnly = await prisma.field.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FindManyfieldArgs>(
      args?: Subset<T, FindManyfieldArgs>
    ): CheckSelect<T, Promise<Array<field>>, Promise<Array<fieldGetPayload<T>>>>
    /**
     * Create a Field.
     * @param {fieldCreateArgs} args - Arguments to create a Field.
     * @example
     * // Create one Field
     * const Field = await prisma.field.create({
     *   data: {
     *     // ... data to create a Field
     *   }
     * })
     * 
    **/
    create<T extends fieldCreateArgs>(
      args: Subset<T, fieldCreateArgs>
    ): CheckSelect<T, Prisma__fieldClient<field>, Prisma__fieldClient<fieldGetPayload<T>>>
    /**
     * Delete a Field.
     * @param {fieldDeleteArgs} args - Arguments to delete one Field.
     * @example
     * // Delete one Field
     * const Field = await prisma.field.delete({
     *   where: {
     *     // ... filter to delete one Field
     *   }
     * })
     * 
    **/
    delete<T extends fieldDeleteArgs>(
      args: Subset<T, fieldDeleteArgs>
    ): CheckSelect<T, Prisma__fieldClient<field>, Prisma__fieldClient<fieldGetPayload<T>>>
    /**
     * Update one Field.
     * @param {fieldUpdateArgs} args - Arguments to update one Field.
     * @example
     * // Update one Field
     * const field = await prisma.field.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends fieldUpdateArgs>(
      args: Subset<T, fieldUpdateArgs>
    ): CheckSelect<T, Prisma__fieldClient<field>, Prisma__fieldClient<fieldGetPayload<T>>>
    /**
     * Delete zero or more Fields.
     * @param {fieldDeleteManyArgs} args - Arguments to filter Fields to delete.
     * @example
     * // Delete a few Fields
     * const { count } = await prisma.field.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends fieldDeleteManyArgs>(
      args?: Subset<T, fieldDeleteManyArgs>
    ): Promise<BatchPayload>
    /**
     * Update zero or more Fields.
     * @param {fieldUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Fields
     * const field = await prisma.field.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends fieldUpdateManyArgs>(
      args: Subset<T, fieldUpdateManyArgs>
    ): Promise<BatchPayload>
    /**
     * Create or update one Field.
     * @param {fieldUpsertArgs} args - Arguments to update or create a Field.
     * @example
     * // Update or create a Field
     * const field = await prisma.field.upsert({
     *   create: {
     *     // ... data to create a Field
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Field we want to update
     *   }
     * })
    **/
    upsert<T extends fieldUpsertArgs>(
      args: Subset<T, fieldUpsertArgs>
    ): CheckSelect<T, Prisma__fieldClient<field>, Prisma__fieldClient<fieldGetPayload<T>>>
    /**
     * Find zero or one Field that matches the filter.
     * @param {FindUniquefieldArgs} args - Arguments to find a Field
     * @deprecated This will be deprecated please use prisma.field.findUnique
     * @example
     * // Get one Field
     * const field = await prisma.field.findOne({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findOne<T extends FindUniquefieldArgs>(
      args: Subset<T, FindUniquefieldArgs>
    ): CheckSelect<T, Prisma__fieldClient<field | null>, Prisma__fieldClient<fieldGetPayload<T> | null>>
    /**
     * Count
     */
    count(args?: Omit<FindManyfieldArgs, 'select' | 'include'>): Promise<number>

  

    /**
     * Aggregate
     */
    aggregate<T extends AggregateFieldArgs>(args: Subset<T, AggregateFieldArgs>): Promise<GetFieldAggregateType<T>>
  }

  /**
   * The delegate class that acts as a "Promise-like" for field.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__fieldClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    area<T extends areaArgs = {}>(args?: Subset<T, areaArgs>): CheckSelect<T, Prisma__areaClient<area | null>, Prisma__areaClient<areaGetPayload<T> | null>>;

    crop<T extends FindManycropArgs = {}>(args?: Subset<T, FindManycropArgs>): CheckSelect<T, Promise<Array<crop>>, Promise<Array<cropGetPayload<T>>>>;

    many_quotation_modal_package_has_many_field<T extends FindManymany_quotation_modal_package_has_many_fieldArgs = {}>(args?: Subset<T, FindManymany_quotation_modal_package_has_many_fieldArgs>): CheckSelect<T, Promise<Array<many_quotation_modal_package_has_many_field>>, Promise<Array<many_quotation_modal_package_has_many_fieldGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * field findUnique
   */
  export type FindUniquefieldArgs = {
    /**
     * Select specific fields to fetch from the field
    **/
    select?: fieldSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: fieldInclude | null
    /**
     * Filter, which field to fetch.
    **/
    where: fieldWhereUniqueInput
  }


  /**
   * field findFirst
   */
  export type FindFirstfieldArgs = {
    /**
     * Select specific fields to fetch from the field
    **/
    select?: fieldSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: fieldInclude | null
    /**
     * Filter, which field to fetch.
    **/
    where?: fieldWhereInput
    orderBy?: Enumerable<fieldOrderByInput>
    cursor?: fieldWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<FieldScalarFieldEnum>
  }


  /**
   * field findMany
   */
  export type FindManyfieldArgs = {
    /**
     * Select specific fields to fetch from the field
    **/
    select?: fieldSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: fieldInclude | null
    /**
     * Filter, which fields to fetch.
    **/
    where?: fieldWhereInput
    /**
     * Determine the order of the fields to fetch.
    **/
    orderBy?: Enumerable<fieldOrderByInput>
    /**
     * Sets the position for listing fields.
    **/
    cursor?: fieldWhereUniqueInput
    /**
     * The number of fields to fetch. If negative number, it will take fields before the `cursor`.
    **/
    take?: number
    /**
     * Skip the first `n` fields.
    **/
    skip?: number
    distinct?: Enumerable<FieldScalarFieldEnum>
  }


  /**
   * field create
   */
  export type fieldCreateArgs = {
    /**
     * Select specific fields to fetch from the field
    **/
    select?: fieldSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: fieldInclude | null
    /**
     * The data needed to create a field.
    **/
    data: fieldCreateInput
  }


  /**
   * field update
   */
  export type fieldUpdateArgs = {
    /**
     * Select specific fields to fetch from the field
    **/
    select?: fieldSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: fieldInclude | null
    /**
     * The data needed to update a field.
    **/
    data: fieldUpdateInput
    /**
     * Choose, which field to update.
    **/
    where: fieldWhereUniqueInput
  }


  /**
   * field updateMany
   */
  export type fieldUpdateManyArgs = {
    data: fieldUpdateManyMutationInput
    where?: fieldWhereInput
  }


  /**
   * field upsert
   */
  export type fieldUpsertArgs = {
    /**
     * Select specific fields to fetch from the field
    **/
    select?: fieldSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: fieldInclude | null
    /**
     * The filter to search for the field to update in case it exists.
    **/
    where: fieldWhereUniqueInput
    /**
     * In case the field found by the `where` argument doesn't exist, create a new field with this data.
    **/
    create: fieldCreateInput
    /**
     * In case the field was found with the provided `where` argument, update it with this data.
    **/
    update: fieldUpdateInput
  }


  /**
   * field delete
   */
  export type fieldDeleteArgs = {
    /**
     * Select specific fields to fetch from the field
    **/
    select?: fieldSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: fieldInclude | null
    /**
     * Filter which field to delete.
    **/
    where: fieldWhereUniqueInput
  }


  /**
   * field deleteMany
   */
  export type fieldDeleteManyArgs = {
    where?: fieldWhereInput
  }


  /**
   * field without action
   */
  export type fieldArgs = {
    /**
     * Select specific fields to fetch from the field
    **/
    select?: fieldSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: fieldInclude | null
  }



  /**
   * Model imaging
   */


  export type AggregateImaging = {
    count: number | null
    avg: ImagingAvgAggregateOutputType | null
    sum: ImagingSumAggregateOutputType | null
    min: ImagingMinAggregateOutputType | null
    max: ImagingMaxAggregateOutputType | null
  }

  export type ImagingAvgAggregateOutputType = {
    id: number
    farm_id: number | null
  }

  export type ImagingSumAggregateOutputType = {
    id: number
    farm_id: number | null
  }

  export type ImagingMinAggregateOutputType = {
    id: number
    directory: string | null
    processing_timestamp: Date | null
    imaging_date: Date | null
    farm_id: number | null
  }

  export type ImagingMaxAggregateOutputType = {
    id: number
    directory: string | null
    processing_timestamp: Date | null
    imaging_date: Date | null
    farm_id: number | null
  }

  export type ImagingCountAggregateOutputType = {
    id: number
    directory: number | null
    processing_timestamp: number | null
    imaging_date: number | null
    farm_id: number | null
    _all: number
  }


  export type ImagingAvgAggregateInputType = {
    id?: true
    farm_id?: true
  }

  export type ImagingSumAggregateInputType = {
    id?: true
    farm_id?: true
  }

  export type ImagingMinAggregateInputType = {
    id?: true
    directory?: true
    processing_timestamp?: true
    imaging_date?: true
    farm_id?: true
  }

  export type ImagingMaxAggregateInputType = {
    id?: true
    directory?: true
    processing_timestamp?: true
    imaging_date?: true
    farm_id?: true
  }

  export type ImagingCountAggregateInputType = {
    id?: true
    directory?: true
    processing_timestamp?: true
    imaging_date?: true
    farm_id?: true
    _all?: true
  }

  export type AggregateImagingArgs = {
    where?: imagingWhereInput
    orderBy?: Enumerable<imagingOrderByInput>
    cursor?: imagingWhereUniqueInput
    take?: number
    skip?: number
    count?: true
    avg?: ImagingAvgAggregateInputType
    sum?: ImagingSumAggregateInputType
    min?: ImagingMinAggregateInputType
    max?: ImagingMaxAggregateInputType
  }

  export type GetImagingAggregateType<T extends AggregateImagingArgs> = {
    [P in keyof T]: P extends 'count' ? number : GetImagingAggregateScalarType<T[P]>
  }

  export type GetImagingAggregateScalarType<T extends any> = {
    [P in keyof T]: P extends keyof ImagingAvgAggregateOutputType ? ImagingAvgAggregateOutputType[P] : never
  }

    



  export type imagingSelect = {
    id?: boolean
    directory?: boolean
    processing_timestamp?: boolean
    imaging_date?: boolean
    farm_id?: boolean
    farm?: boolean | farmArgs
  }

  export type imagingInclude = {
    farm?: boolean | farmArgs
  }

  export type imagingGetPayload<
    S extends boolean | null | undefined | imagingArgs,
    U = keyof S
      > = S extends true
        ? imaging
    : S extends undefined
    ? never
    : S extends imagingArgs | FindManyimagingArgs
    ?'include' extends U
    ? imaging  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'farm'
        ? farmGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof imaging ?imaging [P]
  : 
          P extends 'farm'
        ? farmGetPayload<S['select'][P]> | null : never
  } 
    : imaging
  : imaging


  export interface imagingDelegate {
    /**
     * Find zero or one Imaging that matches the filter.
     * @param {FindUniqueimagingArgs} args - Arguments to find a Imaging
     * @example
     * // Get one Imaging
     * const imaging = await prisma.imaging.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FindUniqueimagingArgs>(
      args: Subset<T, FindUniqueimagingArgs>
    ): CheckSelect<T, Prisma__imagingClient<imaging | null>, Prisma__imagingClient<imagingGetPayload<T> | null>>
    /**
     * Find the first Imaging that matches the filter.
     * @param {FindFirstimagingArgs} args - Arguments to find a Imaging
     * @example
     * // Get one Imaging
     * const imaging = await prisma.imaging.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FindFirstimagingArgs>(
      args?: Subset<T, FindFirstimagingArgs>
    ): CheckSelect<T, Prisma__imagingClient<imaging | null>, Prisma__imagingClient<imagingGetPayload<T> | null>>
    /**
     * Find zero or more Imagings that matches the filter.
     * @param {FindManyimagingArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Imagings
     * const imagings = await prisma.imaging.findMany()
     * 
     * // Get first 10 Imagings
     * const imagings = await prisma.imaging.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const imagingWithIdOnly = await prisma.imaging.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FindManyimagingArgs>(
      args?: Subset<T, FindManyimagingArgs>
    ): CheckSelect<T, Promise<Array<imaging>>, Promise<Array<imagingGetPayload<T>>>>
    /**
     * Create a Imaging.
     * @param {imagingCreateArgs} args - Arguments to create a Imaging.
     * @example
     * // Create one Imaging
     * const Imaging = await prisma.imaging.create({
     *   data: {
     *     // ... data to create a Imaging
     *   }
     * })
     * 
    **/
    create<T extends imagingCreateArgs>(
      args: Subset<T, imagingCreateArgs>
    ): CheckSelect<T, Prisma__imagingClient<imaging>, Prisma__imagingClient<imagingGetPayload<T>>>
    /**
     * Delete a Imaging.
     * @param {imagingDeleteArgs} args - Arguments to delete one Imaging.
     * @example
     * // Delete one Imaging
     * const Imaging = await prisma.imaging.delete({
     *   where: {
     *     // ... filter to delete one Imaging
     *   }
     * })
     * 
    **/
    delete<T extends imagingDeleteArgs>(
      args: Subset<T, imagingDeleteArgs>
    ): CheckSelect<T, Prisma__imagingClient<imaging>, Prisma__imagingClient<imagingGetPayload<T>>>
    /**
     * Update one Imaging.
     * @param {imagingUpdateArgs} args - Arguments to update one Imaging.
     * @example
     * // Update one Imaging
     * const imaging = await prisma.imaging.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends imagingUpdateArgs>(
      args: Subset<T, imagingUpdateArgs>
    ): CheckSelect<T, Prisma__imagingClient<imaging>, Prisma__imagingClient<imagingGetPayload<T>>>
    /**
     * Delete zero or more Imagings.
     * @param {imagingDeleteManyArgs} args - Arguments to filter Imagings to delete.
     * @example
     * // Delete a few Imagings
     * const { count } = await prisma.imaging.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends imagingDeleteManyArgs>(
      args?: Subset<T, imagingDeleteManyArgs>
    ): Promise<BatchPayload>
    /**
     * Update zero or more Imagings.
     * @param {imagingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Imagings
     * const imaging = await prisma.imaging.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends imagingUpdateManyArgs>(
      args: Subset<T, imagingUpdateManyArgs>
    ): Promise<BatchPayload>
    /**
     * Create or update one Imaging.
     * @param {imagingUpsertArgs} args - Arguments to update or create a Imaging.
     * @example
     * // Update or create a Imaging
     * const imaging = await prisma.imaging.upsert({
     *   create: {
     *     // ... data to create a Imaging
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Imaging we want to update
     *   }
     * })
    **/
    upsert<T extends imagingUpsertArgs>(
      args: Subset<T, imagingUpsertArgs>
    ): CheckSelect<T, Prisma__imagingClient<imaging>, Prisma__imagingClient<imagingGetPayload<T>>>
    /**
     * Find zero or one Imaging that matches the filter.
     * @param {FindUniqueimagingArgs} args - Arguments to find a Imaging
     * @deprecated This will be deprecated please use prisma.imaging.findUnique
     * @example
     * // Get one Imaging
     * const imaging = await prisma.imaging.findOne({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findOne<T extends FindUniqueimagingArgs>(
      args: Subset<T, FindUniqueimagingArgs>
    ): CheckSelect<T, Prisma__imagingClient<imaging | null>, Prisma__imagingClient<imagingGetPayload<T> | null>>
    /**
     * Count
     */
    count(args?: Omit<FindManyimagingArgs, 'select' | 'include'>): Promise<number>

  

    /**
     * Aggregate
     */
    aggregate<T extends AggregateImagingArgs>(args: Subset<T, AggregateImagingArgs>): Promise<GetImagingAggregateType<T>>
  }

  /**
   * The delegate class that acts as a "Promise-like" for imaging.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__imagingClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    farm<T extends farmArgs = {}>(args?: Subset<T, farmArgs>): CheckSelect<T, Prisma__farmClient<farm | null>, Prisma__farmClient<farmGetPayload<T> | null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * imaging findUnique
   */
  export type FindUniqueimagingArgs = {
    /**
     * Select specific fields to fetch from the imaging
    **/
    select?: imagingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: imagingInclude | null
    /**
     * Filter, which imaging to fetch.
    **/
    where: imagingWhereUniqueInput
  }


  /**
   * imaging findFirst
   */
  export type FindFirstimagingArgs = {
    /**
     * Select specific fields to fetch from the imaging
    **/
    select?: imagingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: imagingInclude | null
    /**
     * Filter, which imaging to fetch.
    **/
    where?: imagingWhereInput
    orderBy?: Enumerable<imagingOrderByInput>
    cursor?: imagingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ImagingScalarFieldEnum>
  }


  /**
   * imaging findMany
   */
  export type FindManyimagingArgs = {
    /**
     * Select specific fields to fetch from the imaging
    **/
    select?: imagingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: imagingInclude | null
    /**
     * Filter, which imagings to fetch.
    **/
    where?: imagingWhereInput
    /**
     * Determine the order of the imagings to fetch.
    **/
    orderBy?: Enumerable<imagingOrderByInput>
    /**
     * Sets the position for listing imagings.
    **/
    cursor?: imagingWhereUniqueInput
    /**
     * The number of imagings to fetch. If negative number, it will take imagings before the `cursor`.
    **/
    take?: number
    /**
     * Skip the first `n` imagings.
    **/
    skip?: number
    distinct?: Enumerable<ImagingScalarFieldEnum>
  }


  /**
   * imaging create
   */
  export type imagingCreateArgs = {
    /**
     * Select specific fields to fetch from the imaging
    **/
    select?: imagingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: imagingInclude | null
    /**
     * The data needed to create a imaging.
    **/
    data: imagingCreateInput
  }


  /**
   * imaging update
   */
  export type imagingUpdateArgs = {
    /**
     * Select specific fields to fetch from the imaging
    **/
    select?: imagingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: imagingInclude | null
    /**
     * The data needed to update a imaging.
    **/
    data: imagingUpdateInput
    /**
     * Choose, which imaging to update.
    **/
    where: imagingWhereUniqueInput
  }


  /**
   * imaging updateMany
   */
  export type imagingUpdateManyArgs = {
    data: imagingUpdateManyMutationInput
    where?: imagingWhereInput
  }


  /**
   * imaging upsert
   */
  export type imagingUpsertArgs = {
    /**
     * Select specific fields to fetch from the imaging
    **/
    select?: imagingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: imagingInclude | null
    /**
     * The filter to search for the imaging to update in case it exists.
    **/
    where: imagingWhereUniqueInput
    /**
     * In case the imaging found by the `where` argument doesn't exist, create a new imaging with this data.
    **/
    create: imagingCreateInput
    /**
     * In case the imaging was found with the provided `where` argument, update it with this data.
    **/
    update: imagingUpdateInput
  }


  /**
   * imaging delete
   */
  export type imagingDeleteArgs = {
    /**
     * Select specific fields to fetch from the imaging
    **/
    select?: imagingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: imagingInclude | null
    /**
     * Filter which imaging to delete.
    **/
    where: imagingWhereUniqueInput
  }


  /**
   * imaging deleteMany
   */
  export type imagingDeleteManyArgs = {
    where?: imagingWhereInput
  }


  /**
   * imaging without action
   */
  export type imagingArgs = {
    /**
     * Select specific fields to fetch from the imaging
    **/
    select?: imagingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: imagingInclude | null
  }



  /**
   * Model infestation
   */


  export type AggregateInfestation = {
    count: number | null
    avg: InfestationAvgAggregateOutputType | null
    sum: InfestationSumAggregateOutputType | null
    min: InfestationMinAggregateOutputType | null
    max: InfestationMaxAggregateOutputType | null
  }

  export type InfestationAvgAggregateOutputType = {
    id: number
    area_ha: number
    diagnosis_id: number
    plague_id: number
  }

  export type InfestationSumAggregateOutputType = {
    id: number
    area_ha: number
    diagnosis_id: number
    plague_id: number
  }

  export type InfestationMinAggregateOutputType = {
    id: number
    area_ha: number
    points: JsonValue | null
    diagnosis_id: number
    plague_id: number
  }

  export type InfestationMaxAggregateOutputType = {
    id: number
    area_ha: number
    points: JsonValue | null
    diagnosis_id: number
    plague_id: number
  }

  export type InfestationCountAggregateOutputType = {
    id: number
    area_ha: number
    points: number | null
    diagnosis_id: number
    plague_id: number
    _all: number
  }


  export type InfestationAvgAggregateInputType = {
    id?: true
    area_ha?: true
    diagnosis_id?: true
    plague_id?: true
  }

  export type InfestationSumAggregateInputType = {
    id?: true
    area_ha?: true
    diagnosis_id?: true
    plague_id?: true
  }

  export type InfestationMinAggregateInputType = {
    id?: true
    area_ha?: true
    points?: true
    diagnosis_id?: true
    plague_id?: true
  }

  export type InfestationMaxAggregateInputType = {
    id?: true
    area_ha?: true
    points?: true
    diagnosis_id?: true
    plague_id?: true
  }

  export type InfestationCountAggregateInputType = {
    id?: true
    area_ha?: true
    points?: true
    diagnosis_id?: true
    plague_id?: true
    _all?: true
  }

  export type AggregateInfestationArgs = {
    where?: infestationWhereInput
    orderBy?: Enumerable<infestationOrderByInput>
    cursor?: infestationWhereUniqueInput
    take?: number
    skip?: number
    count?: true
    avg?: InfestationAvgAggregateInputType
    sum?: InfestationSumAggregateInputType
    min?: InfestationMinAggregateInputType
    max?: InfestationMaxAggregateInputType
  }

  export type GetInfestationAggregateType<T extends AggregateInfestationArgs> = {
    [P in keyof T]: P extends 'count' ? number : GetInfestationAggregateScalarType<T[P]>
  }

  export type GetInfestationAggregateScalarType<T extends any> = {
    [P in keyof T]: P extends keyof InfestationAvgAggregateOutputType ? InfestationAvgAggregateOutputType[P] : never
  }

    



  export type infestationSelect = {
    id?: boolean
    area_ha?: boolean
    points?: boolean
    diagnosis_id?: boolean
    plague_id?: boolean
    diagnosis?: boolean | diagnosisArgs
    plague?: boolean | plagueArgs
  }

  export type infestationInclude = {
    diagnosis?: boolean | diagnosisArgs
    plague?: boolean | plagueArgs
  }

  export type infestationGetPayload<
    S extends boolean | null | undefined | infestationArgs,
    U = keyof S
      > = S extends true
        ? infestation
    : S extends undefined
    ? never
    : S extends infestationArgs | FindManyinfestationArgs
    ?'include' extends U
    ? infestation  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'diagnosis'
        ? diagnosisGetPayload<S['include'][P]> :
        P extends 'plague'
        ? plagueGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof infestation ?infestation [P]
  : 
          P extends 'diagnosis'
        ? diagnosisGetPayload<S['select'][P]> :
        P extends 'plague'
        ? plagueGetPayload<S['select'][P]> : never
  } 
    : infestation
  : infestation


  export interface infestationDelegate {
    /**
     * Find zero or one Infestation that matches the filter.
     * @param {FindUniqueinfestationArgs} args - Arguments to find a Infestation
     * @example
     * // Get one Infestation
     * const infestation = await prisma.infestation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FindUniqueinfestationArgs>(
      args: Subset<T, FindUniqueinfestationArgs>
    ): CheckSelect<T, Prisma__infestationClient<infestation | null>, Prisma__infestationClient<infestationGetPayload<T> | null>>
    /**
     * Find the first Infestation that matches the filter.
     * @param {FindFirstinfestationArgs} args - Arguments to find a Infestation
     * @example
     * // Get one Infestation
     * const infestation = await prisma.infestation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FindFirstinfestationArgs>(
      args?: Subset<T, FindFirstinfestationArgs>
    ): CheckSelect<T, Prisma__infestationClient<infestation | null>, Prisma__infestationClient<infestationGetPayload<T> | null>>
    /**
     * Find zero or more Infestations that matches the filter.
     * @param {FindManyinfestationArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Infestations
     * const infestations = await prisma.infestation.findMany()
     * 
     * // Get first 10 Infestations
     * const infestations = await prisma.infestation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const infestationWithIdOnly = await prisma.infestation.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FindManyinfestationArgs>(
      args?: Subset<T, FindManyinfestationArgs>
    ): CheckSelect<T, Promise<Array<infestation>>, Promise<Array<infestationGetPayload<T>>>>
    /**
     * Create a Infestation.
     * @param {infestationCreateArgs} args - Arguments to create a Infestation.
     * @example
     * // Create one Infestation
     * const Infestation = await prisma.infestation.create({
     *   data: {
     *     // ... data to create a Infestation
     *   }
     * })
     * 
    **/
    create<T extends infestationCreateArgs>(
      args: Subset<T, infestationCreateArgs>
    ): CheckSelect<T, Prisma__infestationClient<infestation>, Prisma__infestationClient<infestationGetPayload<T>>>
    /**
     * Delete a Infestation.
     * @param {infestationDeleteArgs} args - Arguments to delete one Infestation.
     * @example
     * // Delete one Infestation
     * const Infestation = await prisma.infestation.delete({
     *   where: {
     *     // ... filter to delete one Infestation
     *   }
     * })
     * 
    **/
    delete<T extends infestationDeleteArgs>(
      args: Subset<T, infestationDeleteArgs>
    ): CheckSelect<T, Prisma__infestationClient<infestation>, Prisma__infestationClient<infestationGetPayload<T>>>
    /**
     * Update one Infestation.
     * @param {infestationUpdateArgs} args - Arguments to update one Infestation.
     * @example
     * // Update one Infestation
     * const infestation = await prisma.infestation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends infestationUpdateArgs>(
      args: Subset<T, infestationUpdateArgs>
    ): CheckSelect<T, Prisma__infestationClient<infestation>, Prisma__infestationClient<infestationGetPayload<T>>>
    /**
     * Delete zero or more Infestations.
     * @param {infestationDeleteManyArgs} args - Arguments to filter Infestations to delete.
     * @example
     * // Delete a few Infestations
     * const { count } = await prisma.infestation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends infestationDeleteManyArgs>(
      args?: Subset<T, infestationDeleteManyArgs>
    ): Promise<BatchPayload>
    /**
     * Update zero or more Infestations.
     * @param {infestationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Infestations
     * const infestation = await prisma.infestation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends infestationUpdateManyArgs>(
      args: Subset<T, infestationUpdateManyArgs>
    ): Promise<BatchPayload>
    /**
     * Create or update one Infestation.
     * @param {infestationUpsertArgs} args - Arguments to update or create a Infestation.
     * @example
     * // Update or create a Infestation
     * const infestation = await prisma.infestation.upsert({
     *   create: {
     *     // ... data to create a Infestation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Infestation we want to update
     *   }
     * })
    **/
    upsert<T extends infestationUpsertArgs>(
      args: Subset<T, infestationUpsertArgs>
    ): CheckSelect<T, Prisma__infestationClient<infestation>, Prisma__infestationClient<infestationGetPayload<T>>>
    /**
     * Find zero or one Infestation that matches the filter.
     * @param {FindUniqueinfestationArgs} args - Arguments to find a Infestation
     * @deprecated This will be deprecated please use prisma.infestation.findUnique
     * @example
     * // Get one Infestation
     * const infestation = await prisma.infestation.findOne({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findOne<T extends FindUniqueinfestationArgs>(
      args: Subset<T, FindUniqueinfestationArgs>
    ): CheckSelect<T, Prisma__infestationClient<infestation | null>, Prisma__infestationClient<infestationGetPayload<T> | null>>
    /**
     * Count
     */
    count(args?: Omit<FindManyinfestationArgs, 'select' | 'include'>): Promise<number>

  

    /**
     * Aggregate
     */
    aggregate<T extends AggregateInfestationArgs>(args: Subset<T, AggregateInfestationArgs>): Promise<GetInfestationAggregateType<T>>
  }

  /**
   * The delegate class that acts as a "Promise-like" for infestation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__infestationClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    diagnosis<T extends diagnosisArgs = {}>(args?: Subset<T, diagnosisArgs>): CheckSelect<T, Prisma__diagnosisClient<diagnosis | null>, Prisma__diagnosisClient<diagnosisGetPayload<T> | null>>;

    plague<T extends plagueArgs = {}>(args?: Subset<T, plagueArgs>): CheckSelect<T, Prisma__plagueClient<plague | null>, Prisma__plagueClient<plagueGetPayload<T> | null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * infestation findUnique
   */
  export type FindUniqueinfestationArgs = {
    /**
     * Select specific fields to fetch from the infestation
    **/
    select?: infestationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: infestationInclude | null
    /**
     * Filter, which infestation to fetch.
    **/
    where: infestationWhereUniqueInput
  }


  /**
   * infestation findFirst
   */
  export type FindFirstinfestationArgs = {
    /**
     * Select specific fields to fetch from the infestation
    **/
    select?: infestationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: infestationInclude | null
    /**
     * Filter, which infestation to fetch.
    **/
    where?: infestationWhereInput
    orderBy?: Enumerable<infestationOrderByInput>
    cursor?: infestationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<InfestationScalarFieldEnum>
  }


  /**
   * infestation findMany
   */
  export type FindManyinfestationArgs = {
    /**
     * Select specific fields to fetch from the infestation
    **/
    select?: infestationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: infestationInclude | null
    /**
     * Filter, which infestations to fetch.
    **/
    where?: infestationWhereInput
    /**
     * Determine the order of the infestations to fetch.
    **/
    orderBy?: Enumerable<infestationOrderByInput>
    /**
     * Sets the position for listing infestations.
    **/
    cursor?: infestationWhereUniqueInput
    /**
     * The number of infestations to fetch. If negative number, it will take infestations before the `cursor`.
    **/
    take?: number
    /**
     * Skip the first `n` infestations.
    **/
    skip?: number
    distinct?: Enumerable<InfestationScalarFieldEnum>
  }


  /**
   * infestation create
   */
  export type infestationCreateArgs = {
    /**
     * Select specific fields to fetch from the infestation
    **/
    select?: infestationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: infestationInclude | null
    /**
     * The data needed to create a infestation.
    **/
    data: infestationCreateInput
  }


  /**
   * infestation update
   */
  export type infestationUpdateArgs = {
    /**
     * Select specific fields to fetch from the infestation
    **/
    select?: infestationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: infestationInclude | null
    /**
     * The data needed to update a infestation.
    **/
    data: infestationUpdateInput
    /**
     * Choose, which infestation to update.
    **/
    where: infestationWhereUniqueInput
  }


  /**
   * infestation updateMany
   */
  export type infestationUpdateManyArgs = {
    data: infestationUpdateManyMutationInput
    where?: infestationWhereInput
  }


  /**
   * infestation upsert
   */
  export type infestationUpsertArgs = {
    /**
     * Select specific fields to fetch from the infestation
    **/
    select?: infestationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: infestationInclude | null
    /**
     * The filter to search for the infestation to update in case it exists.
    **/
    where: infestationWhereUniqueInput
    /**
     * In case the infestation found by the `where` argument doesn't exist, create a new infestation with this data.
    **/
    create: infestationCreateInput
    /**
     * In case the infestation was found with the provided `where` argument, update it with this data.
    **/
    update: infestationUpdateInput
  }


  /**
   * infestation delete
   */
  export type infestationDeleteArgs = {
    /**
     * Select specific fields to fetch from the infestation
    **/
    select?: infestationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: infestationInclude | null
    /**
     * Filter which infestation to delete.
    **/
    where: infestationWhereUniqueInput
  }


  /**
   * infestation deleteMany
   */
  export type infestationDeleteManyArgs = {
    where?: infestationWhereInput
  }


  /**
   * infestation without action
   */
  export type infestationArgs = {
    /**
     * Select specific fields to fetch from the infestation
    **/
    select?: infestationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: infestationInclude | null
  }



  /**
   * Model many_quotation_modal_package_has_many_field
   */


  export type AggregateMany_quotation_modal_package_has_many_field = {
    count: number | null
    avg: Many_quotation_modal_package_has_many_fieldAvgAggregateOutputType | null
    sum: Many_quotation_modal_package_has_many_fieldSumAggregateOutputType | null
    min: Many_quotation_modal_package_has_many_fieldMinAggregateOutputType | null
    max: Many_quotation_modal_package_has_many_fieldMaxAggregateOutputType | null
  }

  export type Many_quotation_modal_package_has_many_fieldAvgAggregateOutputType = {
    id_quotation_modal_package: number
    id_field: number
  }

  export type Many_quotation_modal_package_has_many_fieldSumAggregateOutputType = {
    id_quotation_modal_package: number
    id_field: number
  }

  export type Many_quotation_modal_package_has_many_fieldMinAggregateOutputType = {
    id_quotation_modal_package: number
    id_field: number
  }

  export type Many_quotation_modal_package_has_many_fieldMaxAggregateOutputType = {
    id_quotation_modal_package: number
    id_field: number
  }

  export type Many_quotation_modal_package_has_many_fieldCountAggregateOutputType = {
    id_quotation_modal_package: number
    id_field: number
    _all: number
  }


  export type Many_quotation_modal_package_has_many_fieldAvgAggregateInputType = {
    id_quotation_modal_package?: true
    id_field?: true
  }

  export type Many_quotation_modal_package_has_many_fieldSumAggregateInputType = {
    id_quotation_modal_package?: true
    id_field?: true
  }

  export type Many_quotation_modal_package_has_many_fieldMinAggregateInputType = {
    id_quotation_modal_package?: true
    id_field?: true
  }

  export type Many_quotation_modal_package_has_many_fieldMaxAggregateInputType = {
    id_quotation_modal_package?: true
    id_field?: true
  }

  export type Many_quotation_modal_package_has_many_fieldCountAggregateInputType = {
    id_quotation_modal_package?: true
    id_field?: true
    _all?: true
  }

  export type AggregateMany_quotation_modal_package_has_many_fieldArgs = {
    where?: many_quotation_modal_package_has_many_fieldWhereInput
    orderBy?: Enumerable<many_quotation_modal_package_has_many_fieldOrderByInput>
    cursor?: many_quotation_modal_package_has_many_fieldWhereUniqueInput
    take?: number
    skip?: number
    count?: true
    avg?: Many_quotation_modal_package_has_many_fieldAvgAggregateInputType
    sum?: Many_quotation_modal_package_has_many_fieldSumAggregateInputType
    min?: Many_quotation_modal_package_has_many_fieldMinAggregateInputType
    max?: Many_quotation_modal_package_has_many_fieldMaxAggregateInputType
  }

  export type GetMany_quotation_modal_package_has_many_fieldAggregateType<T extends AggregateMany_quotation_modal_package_has_many_fieldArgs> = {
    [P in keyof T]: P extends 'count' ? number : GetMany_quotation_modal_package_has_many_fieldAggregateScalarType<T[P]>
  }

  export type GetMany_quotation_modal_package_has_many_fieldAggregateScalarType<T extends any> = {
    [P in keyof T]: P extends keyof Many_quotation_modal_package_has_many_fieldAvgAggregateOutputType ? Many_quotation_modal_package_has_many_fieldAvgAggregateOutputType[P] : never
  }

    



  export type many_quotation_modal_package_has_many_fieldSelect = {
    id_quotation_modal_package?: boolean
    id_field?: boolean
    field?: boolean | fieldArgs
    quotation_modal_package?: boolean | quotation_modal_packageArgs
  }

  export type many_quotation_modal_package_has_many_fieldInclude = {
    field?: boolean | fieldArgs
    quotation_modal_package?: boolean | quotation_modal_packageArgs
  }

  export type many_quotation_modal_package_has_many_fieldGetPayload<
    S extends boolean | null | undefined | many_quotation_modal_package_has_many_fieldArgs,
    U = keyof S
      > = S extends true
        ? many_quotation_modal_package_has_many_field
    : S extends undefined
    ? never
    : S extends many_quotation_modal_package_has_many_fieldArgs | FindManymany_quotation_modal_package_has_many_fieldArgs
    ?'include' extends U
    ? many_quotation_modal_package_has_many_field  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'field'
        ? fieldGetPayload<S['include'][P]> :
        P extends 'quotation_modal_package'
        ? quotation_modal_packageGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof many_quotation_modal_package_has_many_field ?many_quotation_modal_package_has_many_field [P]
  : 
          P extends 'field'
        ? fieldGetPayload<S['select'][P]> :
        P extends 'quotation_modal_package'
        ? quotation_modal_packageGetPayload<S['select'][P]> : never
  } 
    : many_quotation_modal_package_has_many_field
  : many_quotation_modal_package_has_many_field


  export interface many_quotation_modal_package_has_many_fieldDelegate {
    /**
     * Find zero or one Many_quotation_modal_package_has_many_field that matches the filter.
     * @param {FindUniquemany_quotation_modal_package_has_many_fieldArgs} args - Arguments to find a Many_quotation_modal_package_has_many_field
     * @example
     * // Get one Many_quotation_modal_package_has_many_field
     * const many_quotation_modal_package_has_many_field = await prisma.many_quotation_modal_package_has_many_field.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FindUniquemany_quotation_modal_package_has_many_fieldArgs>(
      args: Subset<T, FindUniquemany_quotation_modal_package_has_many_fieldArgs>
    ): CheckSelect<T, Prisma__many_quotation_modal_package_has_many_fieldClient<many_quotation_modal_package_has_many_field | null>, Prisma__many_quotation_modal_package_has_many_fieldClient<many_quotation_modal_package_has_many_fieldGetPayload<T> | null>>
    /**
     * Find the first Many_quotation_modal_package_has_many_field that matches the filter.
     * @param {FindFirstmany_quotation_modal_package_has_many_fieldArgs} args - Arguments to find a Many_quotation_modal_package_has_many_field
     * @example
     * // Get one Many_quotation_modal_package_has_many_field
     * const many_quotation_modal_package_has_many_field = await prisma.many_quotation_modal_package_has_many_field.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FindFirstmany_quotation_modal_package_has_many_fieldArgs>(
      args?: Subset<T, FindFirstmany_quotation_modal_package_has_many_fieldArgs>
    ): CheckSelect<T, Prisma__many_quotation_modal_package_has_many_fieldClient<many_quotation_modal_package_has_many_field | null>, Prisma__many_quotation_modal_package_has_many_fieldClient<many_quotation_modal_package_has_many_fieldGetPayload<T> | null>>
    /**
     * Find zero or more Many_quotation_modal_package_has_many_fields that matches the filter.
     * @param {FindManymany_quotation_modal_package_has_many_fieldArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Many_quotation_modal_package_has_many_fields
     * const many_quotation_modal_package_has_many_fields = await prisma.many_quotation_modal_package_has_many_field.findMany()
     * 
     * // Get first 10 Many_quotation_modal_package_has_many_fields
     * const many_quotation_modal_package_has_many_fields = await prisma.many_quotation_modal_package_has_many_field.findMany({ take: 10 })
     * 
     * // Only select the `id_quotation_modal_package`
     * const many_quotation_modal_package_has_many_fieldWithId_quotation_modal_packageOnly = await prisma.many_quotation_modal_package_has_many_field.findMany({ select: { id_quotation_modal_package: true } })
     * 
    **/
    findMany<T extends FindManymany_quotation_modal_package_has_many_fieldArgs>(
      args?: Subset<T, FindManymany_quotation_modal_package_has_many_fieldArgs>
    ): CheckSelect<T, Promise<Array<many_quotation_modal_package_has_many_field>>, Promise<Array<many_quotation_modal_package_has_many_fieldGetPayload<T>>>>
    /**
     * Create a Many_quotation_modal_package_has_many_field.
     * @param {many_quotation_modal_package_has_many_fieldCreateArgs} args - Arguments to create a Many_quotation_modal_package_has_many_field.
     * @example
     * // Create one Many_quotation_modal_package_has_many_field
     * const Many_quotation_modal_package_has_many_field = await prisma.many_quotation_modal_package_has_many_field.create({
     *   data: {
     *     // ... data to create a Many_quotation_modal_package_has_many_field
     *   }
     * })
     * 
    **/
    create<T extends many_quotation_modal_package_has_many_fieldCreateArgs>(
      args: Subset<T, many_quotation_modal_package_has_many_fieldCreateArgs>
    ): CheckSelect<T, Prisma__many_quotation_modal_package_has_many_fieldClient<many_quotation_modal_package_has_many_field>, Prisma__many_quotation_modal_package_has_many_fieldClient<many_quotation_modal_package_has_many_fieldGetPayload<T>>>
    /**
     * Delete a Many_quotation_modal_package_has_many_field.
     * @param {many_quotation_modal_package_has_many_fieldDeleteArgs} args - Arguments to delete one Many_quotation_modal_package_has_many_field.
     * @example
     * // Delete one Many_quotation_modal_package_has_many_field
     * const Many_quotation_modal_package_has_many_field = await prisma.many_quotation_modal_package_has_many_field.delete({
     *   where: {
     *     // ... filter to delete one Many_quotation_modal_package_has_many_field
     *   }
     * })
     * 
    **/
    delete<T extends many_quotation_modal_package_has_many_fieldDeleteArgs>(
      args: Subset<T, many_quotation_modal_package_has_many_fieldDeleteArgs>
    ): CheckSelect<T, Prisma__many_quotation_modal_package_has_many_fieldClient<many_quotation_modal_package_has_many_field>, Prisma__many_quotation_modal_package_has_many_fieldClient<many_quotation_modal_package_has_many_fieldGetPayload<T>>>
    /**
     * Update one Many_quotation_modal_package_has_many_field.
     * @param {many_quotation_modal_package_has_many_fieldUpdateArgs} args - Arguments to update one Many_quotation_modal_package_has_many_field.
     * @example
     * // Update one Many_quotation_modal_package_has_many_field
     * const many_quotation_modal_package_has_many_field = await prisma.many_quotation_modal_package_has_many_field.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends many_quotation_modal_package_has_many_fieldUpdateArgs>(
      args: Subset<T, many_quotation_modal_package_has_many_fieldUpdateArgs>
    ): CheckSelect<T, Prisma__many_quotation_modal_package_has_many_fieldClient<many_quotation_modal_package_has_many_field>, Prisma__many_quotation_modal_package_has_many_fieldClient<many_quotation_modal_package_has_many_fieldGetPayload<T>>>
    /**
     * Delete zero or more Many_quotation_modal_package_has_many_fields.
     * @param {many_quotation_modal_package_has_many_fieldDeleteManyArgs} args - Arguments to filter Many_quotation_modal_package_has_many_fields to delete.
     * @example
     * // Delete a few Many_quotation_modal_package_has_many_fields
     * const { count } = await prisma.many_quotation_modal_package_has_many_field.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends many_quotation_modal_package_has_many_fieldDeleteManyArgs>(
      args?: Subset<T, many_quotation_modal_package_has_many_fieldDeleteManyArgs>
    ): Promise<BatchPayload>
    /**
     * Update zero or more Many_quotation_modal_package_has_many_fields.
     * @param {many_quotation_modal_package_has_many_fieldUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Many_quotation_modal_package_has_many_fields
     * const many_quotation_modal_package_has_many_field = await prisma.many_quotation_modal_package_has_many_field.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends many_quotation_modal_package_has_many_fieldUpdateManyArgs>(
      args: Subset<T, many_quotation_modal_package_has_many_fieldUpdateManyArgs>
    ): Promise<BatchPayload>
    /**
     * Create or update one Many_quotation_modal_package_has_many_field.
     * @param {many_quotation_modal_package_has_many_fieldUpsertArgs} args - Arguments to update or create a Many_quotation_modal_package_has_many_field.
     * @example
     * // Update or create a Many_quotation_modal_package_has_many_field
     * const many_quotation_modal_package_has_many_field = await prisma.many_quotation_modal_package_has_many_field.upsert({
     *   create: {
     *     // ... data to create a Many_quotation_modal_package_has_many_field
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Many_quotation_modal_package_has_many_field we want to update
     *   }
     * })
    **/
    upsert<T extends many_quotation_modal_package_has_many_fieldUpsertArgs>(
      args: Subset<T, many_quotation_modal_package_has_many_fieldUpsertArgs>
    ): CheckSelect<T, Prisma__many_quotation_modal_package_has_many_fieldClient<many_quotation_modal_package_has_many_field>, Prisma__many_quotation_modal_package_has_many_fieldClient<many_quotation_modal_package_has_many_fieldGetPayload<T>>>
    /**
     * Find zero or one Many_quotation_modal_package_has_many_field that matches the filter.
     * @param {FindUniquemany_quotation_modal_package_has_many_fieldArgs} args - Arguments to find a Many_quotation_modal_package_has_many_field
     * @deprecated This will be deprecated please use prisma.many_quotation_modal_package_has_many_field.findUnique
     * @example
     * // Get one Many_quotation_modal_package_has_many_field
     * const many_quotation_modal_package_has_many_field = await prisma.many_quotation_modal_package_has_many_field.findOne({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findOne<T extends FindUniquemany_quotation_modal_package_has_many_fieldArgs>(
      args: Subset<T, FindUniquemany_quotation_modal_package_has_many_fieldArgs>
    ): CheckSelect<T, Prisma__many_quotation_modal_package_has_many_fieldClient<many_quotation_modal_package_has_many_field | null>, Prisma__many_quotation_modal_package_has_many_fieldClient<many_quotation_modal_package_has_many_fieldGetPayload<T> | null>>
    /**
     * Count
     */
    count(args?: Omit<FindManymany_quotation_modal_package_has_many_fieldArgs, 'select' | 'include'>): Promise<number>

  

    /**
     * Aggregate
     */
    aggregate<T extends AggregateMany_quotation_modal_package_has_many_fieldArgs>(args: Subset<T, AggregateMany_quotation_modal_package_has_many_fieldArgs>): Promise<GetMany_quotation_modal_package_has_many_fieldAggregateType<T>>
  }

  /**
   * The delegate class that acts as a "Promise-like" for many_quotation_modal_package_has_many_field.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__many_quotation_modal_package_has_many_fieldClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    field<T extends fieldArgs = {}>(args?: Subset<T, fieldArgs>): CheckSelect<T, Prisma__fieldClient<field | null>, Prisma__fieldClient<fieldGetPayload<T> | null>>;

    quotation_modal_package<T extends quotation_modal_packageArgs = {}>(args?: Subset<T, quotation_modal_packageArgs>): CheckSelect<T, Prisma__quotation_modal_packageClient<quotation_modal_package | null>, Prisma__quotation_modal_packageClient<quotation_modal_packageGetPayload<T> | null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * many_quotation_modal_package_has_many_field findUnique
   */
  export type FindUniquemany_quotation_modal_package_has_many_fieldArgs = {
    /**
     * Select specific fields to fetch from the many_quotation_modal_package_has_many_field
    **/
    select?: many_quotation_modal_package_has_many_fieldSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: many_quotation_modal_package_has_many_fieldInclude | null
    /**
     * Filter, which many_quotation_modal_package_has_many_field to fetch.
    **/
    where: many_quotation_modal_package_has_many_fieldWhereUniqueInput
  }


  /**
   * many_quotation_modal_package_has_many_field findFirst
   */
  export type FindFirstmany_quotation_modal_package_has_many_fieldArgs = {
    /**
     * Select specific fields to fetch from the many_quotation_modal_package_has_many_field
    **/
    select?: many_quotation_modal_package_has_many_fieldSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: many_quotation_modal_package_has_many_fieldInclude | null
    /**
     * Filter, which many_quotation_modal_package_has_many_field to fetch.
    **/
    where?: many_quotation_modal_package_has_many_fieldWhereInput
    orderBy?: Enumerable<many_quotation_modal_package_has_many_fieldOrderByInput>
    cursor?: many_quotation_modal_package_has_many_fieldWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Many_quotation_modal_package_has_many_fieldScalarFieldEnum>
  }


  /**
   * many_quotation_modal_package_has_many_field findMany
   */
  export type FindManymany_quotation_modal_package_has_many_fieldArgs = {
    /**
     * Select specific fields to fetch from the many_quotation_modal_package_has_many_field
    **/
    select?: many_quotation_modal_package_has_many_fieldSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: many_quotation_modal_package_has_many_fieldInclude | null
    /**
     * Filter, which many_quotation_modal_package_has_many_fields to fetch.
    **/
    where?: many_quotation_modal_package_has_many_fieldWhereInput
    /**
     * Determine the order of the many_quotation_modal_package_has_many_fields to fetch.
    **/
    orderBy?: Enumerable<many_quotation_modal_package_has_many_fieldOrderByInput>
    /**
     * Sets the position for listing many_quotation_modal_package_has_many_fields.
    **/
    cursor?: many_quotation_modal_package_has_many_fieldWhereUniqueInput
    /**
     * The number of many_quotation_modal_package_has_many_fields to fetch. If negative number, it will take many_quotation_modal_package_has_many_fields before the `cursor`.
    **/
    take?: number
    /**
     * Skip the first `n` many_quotation_modal_package_has_many_fields.
    **/
    skip?: number
    distinct?: Enumerable<Many_quotation_modal_package_has_many_fieldScalarFieldEnum>
  }


  /**
   * many_quotation_modal_package_has_many_field create
   */
  export type many_quotation_modal_package_has_many_fieldCreateArgs = {
    /**
     * Select specific fields to fetch from the many_quotation_modal_package_has_many_field
    **/
    select?: many_quotation_modal_package_has_many_fieldSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: many_quotation_modal_package_has_many_fieldInclude | null
    /**
     * The data needed to create a many_quotation_modal_package_has_many_field.
    **/
    data: many_quotation_modal_package_has_many_fieldCreateInput
  }


  /**
   * many_quotation_modal_package_has_many_field update
   */
  export type many_quotation_modal_package_has_many_fieldUpdateArgs = {
    /**
     * Select specific fields to fetch from the many_quotation_modal_package_has_many_field
    **/
    select?: many_quotation_modal_package_has_many_fieldSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: many_quotation_modal_package_has_many_fieldInclude | null
    /**
     * The data needed to update a many_quotation_modal_package_has_many_field.
    **/
    data: many_quotation_modal_package_has_many_fieldUpdateInput
    /**
     * Choose, which many_quotation_modal_package_has_many_field to update.
    **/
    where: many_quotation_modal_package_has_many_fieldWhereUniqueInput
  }


  /**
   * many_quotation_modal_package_has_many_field updateMany
   */
  export type many_quotation_modal_package_has_many_fieldUpdateManyArgs = {
    data: many_quotation_modal_package_has_many_fieldUpdateManyMutationInput
    where?: many_quotation_modal_package_has_many_fieldWhereInput
  }


  /**
   * many_quotation_modal_package_has_many_field upsert
   */
  export type many_quotation_modal_package_has_many_fieldUpsertArgs = {
    /**
     * Select specific fields to fetch from the many_quotation_modal_package_has_many_field
    **/
    select?: many_quotation_modal_package_has_many_fieldSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: many_quotation_modal_package_has_many_fieldInclude | null
    /**
     * The filter to search for the many_quotation_modal_package_has_many_field to update in case it exists.
    **/
    where: many_quotation_modal_package_has_many_fieldWhereUniqueInput
    /**
     * In case the many_quotation_modal_package_has_many_field found by the `where` argument doesn't exist, create a new many_quotation_modal_package_has_many_field with this data.
    **/
    create: many_quotation_modal_package_has_many_fieldCreateInput
    /**
     * In case the many_quotation_modal_package_has_many_field was found with the provided `where` argument, update it with this data.
    **/
    update: many_quotation_modal_package_has_many_fieldUpdateInput
  }


  /**
   * many_quotation_modal_package_has_many_field delete
   */
  export type many_quotation_modal_package_has_many_fieldDeleteArgs = {
    /**
     * Select specific fields to fetch from the many_quotation_modal_package_has_many_field
    **/
    select?: many_quotation_modal_package_has_many_fieldSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: many_quotation_modal_package_has_many_fieldInclude | null
    /**
     * Filter which many_quotation_modal_package_has_many_field to delete.
    **/
    where: many_quotation_modal_package_has_many_fieldWhereUniqueInput
  }


  /**
   * many_quotation_modal_package_has_many_field deleteMany
   */
  export type many_quotation_modal_package_has_many_fieldDeleteManyArgs = {
    where?: many_quotation_modal_package_has_many_fieldWhereInput
  }


  /**
   * many_quotation_modal_package_has_many_field without action
   */
  export type many_quotation_modal_package_has_many_fieldArgs = {
    /**
     * Select specific fields to fetch from the many_quotation_modal_package_has_many_field
    **/
    select?: many_quotation_modal_package_has_many_fieldSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: many_quotation_modal_package_has_many_fieldInclude | null
  }



  /**
   * Model many_user_has_many_farm
   */


  export type AggregateMany_user_has_many_farm = {
    count: number | null
    avg: Many_user_has_many_farmAvgAggregateOutputType | null
    sum: Many_user_has_many_farmSumAggregateOutputType | null
    min: Many_user_has_many_farmMinAggregateOutputType | null
    max: Many_user_has_many_farmMaxAggregateOutputType | null
  }

  export type Many_user_has_many_farmAvgAggregateOutputType = {
    user_id: number
    farm_id: number
  }

  export type Many_user_has_many_farmSumAggregateOutputType = {
    user_id: number
    farm_id: number
  }

  export type Many_user_has_many_farmMinAggregateOutputType = {
    user_id: number
    farm_id: number
  }

  export type Many_user_has_many_farmMaxAggregateOutputType = {
    user_id: number
    farm_id: number
  }

  export type Many_user_has_many_farmCountAggregateOutputType = {
    user_id: number
    farm_id: number
    _all: number
  }


  export type Many_user_has_many_farmAvgAggregateInputType = {
    user_id?: true
    farm_id?: true
  }

  export type Many_user_has_many_farmSumAggregateInputType = {
    user_id?: true
    farm_id?: true
  }

  export type Many_user_has_many_farmMinAggregateInputType = {
    user_id?: true
    farm_id?: true
  }

  export type Many_user_has_many_farmMaxAggregateInputType = {
    user_id?: true
    farm_id?: true
  }

  export type Many_user_has_many_farmCountAggregateInputType = {
    user_id?: true
    farm_id?: true
    _all?: true
  }

  export type AggregateMany_user_has_many_farmArgs = {
    where?: many_user_has_many_farmWhereInput
    orderBy?: Enumerable<many_user_has_many_farmOrderByInput>
    cursor?: many_user_has_many_farmWhereUniqueInput
    take?: number
    skip?: number
    count?: true
    avg?: Many_user_has_many_farmAvgAggregateInputType
    sum?: Many_user_has_many_farmSumAggregateInputType
    min?: Many_user_has_many_farmMinAggregateInputType
    max?: Many_user_has_many_farmMaxAggregateInputType
  }

  export type GetMany_user_has_many_farmAggregateType<T extends AggregateMany_user_has_many_farmArgs> = {
    [P in keyof T]: P extends 'count' ? number : GetMany_user_has_many_farmAggregateScalarType<T[P]>
  }

  export type GetMany_user_has_many_farmAggregateScalarType<T extends any> = {
    [P in keyof T]: P extends keyof Many_user_has_many_farmAvgAggregateOutputType ? Many_user_has_many_farmAvgAggregateOutputType[P] : never
  }

    



  export type many_user_has_many_farmSelect = {
    user_id?: boolean
    farm_id?: boolean
    farm?: boolean | farmArgs
    user?: boolean | userArgs
  }

  export type many_user_has_many_farmInclude = {
    farm?: boolean | farmArgs
    user?: boolean | userArgs
  }

  export type many_user_has_many_farmGetPayload<
    S extends boolean | null | undefined | many_user_has_many_farmArgs,
    U = keyof S
      > = S extends true
        ? many_user_has_many_farm
    : S extends undefined
    ? never
    : S extends many_user_has_many_farmArgs | FindManymany_user_has_many_farmArgs
    ?'include' extends U
    ? many_user_has_many_farm  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'farm'
        ? farmGetPayload<S['include'][P]> :
        P extends 'user'
        ? userGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof many_user_has_many_farm ?many_user_has_many_farm [P]
  : 
          P extends 'farm'
        ? farmGetPayload<S['select'][P]> :
        P extends 'user'
        ? userGetPayload<S['select'][P]> : never
  } 
    : many_user_has_many_farm
  : many_user_has_many_farm


  export interface many_user_has_many_farmDelegate {
    /**
     * Find zero or one Many_user_has_many_farm that matches the filter.
     * @param {FindUniquemany_user_has_many_farmArgs} args - Arguments to find a Many_user_has_many_farm
     * @example
     * // Get one Many_user_has_many_farm
     * const many_user_has_many_farm = await prisma.many_user_has_many_farm.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FindUniquemany_user_has_many_farmArgs>(
      args: Subset<T, FindUniquemany_user_has_many_farmArgs>
    ): CheckSelect<T, Prisma__many_user_has_many_farmClient<many_user_has_many_farm | null>, Prisma__many_user_has_many_farmClient<many_user_has_many_farmGetPayload<T> | null>>
    /**
     * Find the first Many_user_has_many_farm that matches the filter.
     * @param {FindFirstmany_user_has_many_farmArgs} args - Arguments to find a Many_user_has_many_farm
     * @example
     * // Get one Many_user_has_many_farm
     * const many_user_has_many_farm = await prisma.many_user_has_many_farm.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FindFirstmany_user_has_many_farmArgs>(
      args?: Subset<T, FindFirstmany_user_has_many_farmArgs>
    ): CheckSelect<T, Prisma__many_user_has_many_farmClient<many_user_has_many_farm | null>, Prisma__many_user_has_many_farmClient<many_user_has_many_farmGetPayload<T> | null>>
    /**
     * Find zero or more Many_user_has_many_farms that matches the filter.
     * @param {FindManymany_user_has_many_farmArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Many_user_has_many_farms
     * const many_user_has_many_farms = await prisma.many_user_has_many_farm.findMany()
     * 
     * // Get first 10 Many_user_has_many_farms
     * const many_user_has_many_farms = await prisma.many_user_has_many_farm.findMany({ take: 10 })
     * 
     * // Only select the `user_id`
     * const many_user_has_many_farmWithUser_idOnly = await prisma.many_user_has_many_farm.findMany({ select: { user_id: true } })
     * 
    **/
    findMany<T extends FindManymany_user_has_many_farmArgs>(
      args?: Subset<T, FindManymany_user_has_many_farmArgs>
    ): CheckSelect<T, Promise<Array<many_user_has_many_farm>>, Promise<Array<many_user_has_many_farmGetPayload<T>>>>
    /**
     * Create a Many_user_has_many_farm.
     * @param {many_user_has_many_farmCreateArgs} args - Arguments to create a Many_user_has_many_farm.
     * @example
     * // Create one Many_user_has_many_farm
     * const Many_user_has_many_farm = await prisma.many_user_has_many_farm.create({
     *   data: {
     *     // ... data to create a Many_user_has_many_farm
     *   }
     * })
     * 
    **/
    create<T extends many_user_has_many_farmCreateArgs>(
      args: Subset<T, many_user_has_many_farmCreateArgs>
    ): CheckSelect<T, Prisma__many_user_has_many_farmClient<many_user_has_many_farm>, Prisma__many_user_has_many_farmClient<many_user_has_many_farmGetPayload<T>>>
    /**
     * Delete a Many_user_has_many_farm.
     * @param {many_user_has_many_farmDeleteArgs} args - Arguments to delete one Many_user_has_many_farm.
     * @example
     * // Delete one Many_user_has_many_farm
     * const Many_user_has_many_farm = await prisma.many_user_has_many_farm.delete({
     *   where: {
     *     // ... filter to delete one Many_user_has_many_farm
     *   }
     * })
     * 
    **/
    delete<T extends many_user_has_many_farmDeleteArgs>(
      args: Subset<T, many_user_has_many_farmDeleteArgs>
    ): CheckSelect<T, Prisma__many_user_has_many_farmClient<many_user_has_many_farm>, Prisma__many_user_has_many_farmClient<many_user_has_many_farmGetPayload<T>>>
    /**
     * Update one Many_user_has_many_farm.
     * @param {many_user_has_many_farmUpdateArgs} args - Arguments to update one Many_user_has_many_farm.
     * @example
     * // Update one Many_user_has_many_farm
     * const many_user_has_many_farm = await prisma.many_user_has_many_farm.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends many_user_has_many_farmUpdateArgs>(
      args: Subset<T, many_user_has_many_farmUpdateArgs>
    ): CheckSelect<T, Prisma__many_user_has_many_farmClient<many_user_has_many_farm>, Prisma__many_user_has_many_farmClient<many_user_has_many_farmGetPayload<T>>>
    /**
     * Delete zero or more Many_user_has_many_farms.
     * @param {many_user_has_many_farmDeleteManyArgs} args - Arguments to filter Many_user_has_many_farms to delete.
     * @example
     * // Delete a few Many_user_has_many_farms
     * const { count } = await prisma.many_user_has_many_farm.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends many_user_has_many_farmDeleteManyArgs>(
      args?: Subset<T, many_user_has_many_farmDeleteManyArgs>
    ): Promise<BatchPayload>
    /**
     * Update zero or more Many_user_has_many_farms.
     * @param {many_user_has_many_farmUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Many_user_has_many_farms
     * const many_user_has_many_farm = await prisma.many_user_has_many_farm.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends many_user_has_many_farmUpdateManyArgs>(
      args: Subset<T, many_user_has_many_farmUpdateManyArgs>
    ): Promise<BatchPayload>
    /**
     * Create or update one Many_user_has_many_farm.
     * @param {many_user_has_many_farmUpsertArgs} args - Arguments to update or create a Many_user_has_many_farm.
     * @example
     * // Update or create a Many_user_has_many_farm
     * const many_user_has_many_farm = await prisma.many_user_has_many_farm.upsert({
     *   create: {
     *     // ... data to create a Many_user_has_many_farm
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Many_user_has_many_farm we want to update
     *   }
     * })
    **/
    upsert<T extends many_user_has_many_farmUpsertArgs>(
      args: Subset<T, many_user_has_many_farmUpsertArgs>
    ): CheckSelect<T, Prisma__many_user_has_many_farmClient<many_user_has_many_farm>, Prisma__many_user_has_many_farmClient<many_user_has_many_farmGetPayload<T>>>
    /**
     * Find zero or one Many_user_has_many_farm that matches the filter.
     * @param {FindUniquemany_user_has_many_farmArgs} args - Arguments to find a Many_user_has_many_farm
     * @deprecated This will be deprecated please use prisma.many_user_has_many_farm.findUnique
     * @example
     * // Get one Many_user_has_many_farm
     * const many_user_has_many_farm = await prisma.many_user_has_many_farm.findOne({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findOne<T extends FindUniquemany_user_has_many_farmArgs>(
      args: Subset<T, FindUniquemany_user_has_many_farmArgs>
    ): CheckSelect<T, Prisma__many_user_has_many_farmClient<many_user_has_many_farm | null>, Prisma__many_user_has_many_farmClient<many_user_has_many_farmGetPayload<T> | null>>
    /**
     * Count
     */
    count(args?: Omit<FindManymany_user_has_many_farmArgs, 'select' | 'include'>): Promise<number>

  

    /**
     * Aggregate
     */
    aggregate<T extends AggregateMany_user_has_many_farmArgs>(args: Subset<T, AggregateMany_user_has_many_farmArgs>): Promise<GetMany_user_has_many_farmAggregateType<T>>
  }

  /**
   * The delegate class that acts as a "Promise-like" for many_user_has_many_farm.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__many_user_has_many_farmClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    farm<T extends farmArgs = {}>(args?: Subset<T, farmArgs>): CheckSelect<T, Prisma__farmClient<farm | null>, Prisma__farmClient<farmGetPayload<T> | null>>;

    user<T extends userArgs = {}>(args?: Subset<T, userArgs>): CheckSelect<T, Prisma__userClient<user | null>, Prisma__userClient<userGetPayload<T> | null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * many_user_has_many_farm findUnique
   */
  export type FindUniquemany_user_has_many_farmArgs = {
    /**
     * Select specific fields to fetch from the many_user_has_many_farm
    **/
    select?: many_user_has_many_farmSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: many_user_has_many_farmInclude | null
    /**
     * Filter, which many_user_has_many_farm to fetch.
    **/
    where: many_user_has_many_farmWhereUniqueInput
  }


  /**
   * many_user_has_many_farm findFirst
   */
  export type FindFirstmany_user_has_many_farmArgs = {
    /**
     * Select specific fields to fetch from the many_user_has_many_farm
    **/
    select?: many_user_has_many_farmSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: many_user_has_many_farmInclude | null
    /**
     * Filter, which many_user_has_many_farm to fetch.
    **/
    where?: many_user_has_many_farmWhereInput
    orderBy?: Enumerable<many_user_has_many_farmOrderByInput>
    cursor?: many_user_has_many_farmWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Many_user_has_many_farmScalarFieldEnum>
  }


  /**
   * many_user_has_many_farm findMany
   */
  export type FindManymany_user_has_many_farmArgs = {
    /**
     * Select specific fields to fetch from the many_user_has_many_farm
    **/
    select?: many_user_has_many_farmSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: many_user_has_many_farmInclude | null
    /**
     * Filter, which many_user_has_many_farms to fetch.
    **/
    where?: many_user_has_many_farmWhereInput
    /**
     * Determine the order of the many_user_has_many_farms to fetch.
    **/
    orderBy?: Enumerable<many_user_has_many_farmOrderByInput>
    /**
     * Sets the position for listing many_user_has_many_farms.
    **/
    cursor?: many_user_has_many_farmWhereUniqueInput
    /**
     * The number of many_user_has_many_farms to fetch. If negative number, it will take many_user_has_many_farms before the `cursor`.
    **/
    take?: number
    /**
     * Skip the first `n` many_user_has_many_farms.
    **/
    skip?: number
    distinct?: Enumerable<Many_user_has_many_farmScalarFieldEnum>
  }


  /**
   * many_user_has_many_farm create
   */
  export type many_user_has_many_farmCreateArgs = {
    /**
     * Select specific fields to fetch from the many_user_has_many_farm
    **/
    select?: many_user_has_many_farmSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: many_user_has_many_farmInclude | null
    /**
     * The data needed to create a many_user_has_many_farm.
    **/
    data: many_user_has_many_farmCreateInput
  }


  /**
   * many_user_has_many_farm update
   */
  export type many_user_has_many_farmUpdateArgs = {
    /**
     * Select specific fields to fetch from the many_user_has_many_farm
    **/
    select?: many_user_has_many_farmSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: many_user_has_many_farmInclude | null
    /**
     * The data needed to update a many_user_has_many_farm.
    **/
    data: many_user_has_many_farmUpdateInput
    /**
     * Choose, which many_user_has_many_farm to update.
    **/
    where: many_user_has_many_farmWhereUniqueInput
  }


  /**
   * many_user_has_many_farm updateMany
   */
  export type many_user_has_many_farmUpdateManyArgs = {
    data: many_user_has_many_farmUpdateManyMutationInput
    where?: many_user_has_many_farmWhereInput
  }


  /**
   * many_user_has_many_farm upsert
   */
  export type many_user_has_many_farmUpsertArgs = {
    /**
     * Select specific fields to fetch from the many_user_has_many_farm
    **/
    select?: many_user_has_many_farmSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: many_user_has_many_farmInclude | null
    /**
     * The filter to search for the many_user_has_many_farm to update in case it exists.
    **/
    where: many_user_has_many_farmWhereUniqueInput
    /**
     * In case the many_user_has_many_farm found by the `where` argument doesn't exist, create a new many_user_has_many_farm with this data.
    **/
    create: many_user_has_many_farmCreateInput
    /**
     * In case the many_user_has_many_farm was found with the provided `where` argument, update it with this data.
    **/
    update: many_user_has_many_farmUpdateInput
  }


  /**
   * many_user_has_many_farm delete
   */
  export type many_user_has_many_farmDeleteArgs = {
    /**
     * Select specific fields to fetch from the many_user_has_many_farm
    **/
    select?: many_user_has_many_farmSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: many_user_has_many_farmInclude | null
    /**
     * Filter which many_user_has_many_farm to delete.
    **/
    where: many_user_has_many_farmWhereUniqueInput
  }


  /**
   * many_user_has_many_farm deleteMany
   */
  export type many_user_has_many_farmDeleteManyArgs = {
    where?: many_user_has_many_farmWhereInput
  }


  /**
   * many_user_has_many_farm without action
   */
  export type many_user_has_many_farmArgs = {
    /**
     * Select specific fields to fetch from the many_user_has_many_farm
    **/
    select?: many_user_has_many_farmSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: many_user_has_many_farmInclude | null
  }



  /**
   * Model notification
   */


  export type AggregateNotification = {
    count: number | null
    avg: NotificationAvgAggregateOutputType | null
    sum: NotificationSumAggregateOutputType | null
    min: NotificationMinAggregateOutputType | null
    max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationAvgAggregateOutputType = {
    id: number
    type: number
    user_id: number
  }

  export type NotificationSumAggregateOutputType = {
    id: number
    type: number
    user_id: number
  }

  export type NotificationMinAggregateOutputType = {
    id: number
    type: number
    body: JsonValue | null
    sent_date: Date | null
    read_date: Date | null
    delivered_date: Date | null
    user_id: number
  }

  export type NotificationMaxAggregateOutputType = {
    id: number
    type: number
    body: JsonValue | null
    sent_date: Date | null
    read_date: Date | null
    delivered_date: Date | null
    user_id: number
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    type: number
    body: number | null
    sent_date: number | null
    read_date: number | null
    delivered_date: number | null
    user_id: number
    _all: number
  }


  export type NotificationAvgAggregateInputType = {
    id?: true
    type?: true
    user_id?: true
  }

  export type NotificationSumAggregateInputType = {
    id?: true
    type?: true
    user_id?: true
  }

  export type NotificationMinAggregateInputType = {
    id?: true
    type?: true
    body?: true
    sent_date?: true
    read_date?: true
    delivered_date?: true
    user_id?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    type?: true
    body?: true
    sent_date?: true
    read_date?: true
    delivered_date?: true
    user_id?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    type?: true
    body?: true
    sent_date?: true
    read_date?: true
    delivered_date?: true
    user_id?: true
    _all?: true
  }

  export type AggregateNotificationArgs = {
    where?: notificationWhereInput
    orderBy?: Enumerable<notificationOrderByInput>
    cursor?: notificationWhereUniqueInput
    take?: number
    skip?: number
    count?: true
    avg?: NotificationAvgAggregateInputType
    sum?: NotificationSumAggregateInputType
    min?: NotificationMinAggregateInputType
    max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends AggregateNotificationArgs> = {
    [P in keyof T]: P extends 'count' ? number : GetNotificationAggregateScalarType<T[P]>
  }

  export type GetNotificationAggregateScalarType<T extends any> = {
    [P in keyof T]: P extends keyof NotificationAvgAggregateOutputType ? NotificationAvgAggregateOutputType[P] : never
  }

    



  export type notificationSelect = {
    id?: boolean
    type?: boolean
    body?: boolean
    sent_date?: boolean
    read_date?: boolean
    delivered_date?: boolean
    user_id?: boolean
    user?: boolean | userArgs
  }

  export type notificationInclude = {
    user?: boolean | userArgs
  }

  export type notificationGetPayload<
    S extends boolean | null | undefined | notificationArgs,
    U = keyof S
      > = S extends true
        ? notification
    : S extends undefined
    ? never
    : S extends notificationArgs | FindManynotificationArgs
    ?'include' extends U
    ? notification  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'user'
        ? userGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof notification ?notification [P]
  : 
          P extends 'user'
        ? userGetPayload<S['select'][P]> : never
  } 
    : notification
  : notification


  export interface notificationDelegate {
    /**
     * Find zero or one Notification that matches the filter.
     * @param {FindUniquenotificationArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FindUniquenotificationArgs>(
      args: Subset<T, FindUniquenotificationArgs>
    ): CheckSelect<T, Prisma__notificationClient<notification | null>, Prisma__notificationClient<notificationGetPayload<T> | null>>
    /**
     * Find the first Notification that matches the filter.
     * @param {FindFirstnotificationArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FindFirstnotificationArgs>(
      args?: Subset<T, FindFirstnotificationArgs>
    ): CheckSelect<T, Prisma__notificationClient<notification | null>, Prisma__notificationClient<notificationGetPayload<T> | null>>
    /**
     * Find zero or more Notifications that matches the filter.
     * @param {FindManynotificationArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FindManynotificationArgs>(
      args?: Subset<T, FindManynotificationArgs>
    ): CheckSelect<T, Promise<Array<notification>>, Promise<Array<notificationGetPayload<T>>>>
    /**
     * Create a Notification.
     * @param {notificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
    **/
    create<T extends notificationCreateArgs>(
      args: Subset<T, notificationCreateArgs>
    ): CheckSelect<T, Prisma__notificationClient<notification>, Prisma__notificationClient<notificationGetPayload<T>>>
    /**
     * Delete a Notification.
     * @param {notificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
    **/
    delete<T extends notificationDeleteArgs>(
      args: Subset<T, notificationDeleteArgs>
    ): CheckSelect<T, Prisma__notificationClient<notification>, Prisma__notificationClient<notificationGetPayload<T>>>
    /**
     * Update one Notification.
     * @param {notificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends notificationUpdateArgs>(
      args: Subset<T, notificationUpdateArgs>
    ): CheckSelect<T, Prisma__notificationClient<notification>, Prisma__notificationClient<notificationGetPayload<T>>>
    /**
     * Delete zero or more Notifications.
     * @param {notificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends notificationDeleteManyArgs>(
      args?: Subset<T, notificationDeleteManyArgs>
    ): Promise<BatchPayload>
    /**
     * Update zero or more Notifications.
     * @param {notificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends notificationUpdateManyArgs>(
      args: Subset<T, notificationUpdateManyArgs>
    ): Promise<BatchPayload>
    /**
     * Create or update one Notification.
     * @param {notificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
    **/
    upsert<T extends notificationUpsertArgs>(
      args: Subset<T, notificationUpsertArgs>
    ): CheckSelect<T, Prisma__notificationClient<notification>, Prisma__notificationClient<notificationGetPayload<T>>>
    /**
     * Find zero or one Notification that matches the filter.
     * @param {FindUniquenotificationArgs} args - Arguments to find a Notification
     * @deprecated This will be deprecated please use prisma.notification.findUnique
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findOne({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findOne<T extends FindUniquenotificationArgs>(
      args: Subset<T, FindUniquenotificationArgs>
    ): CheckSelect<T, Prisma__notificationClient<notification | null>, Prisma__notificationClient<notificationGetPayload<T> | null>>
    /**
     * Count
     */
    count(args?: Omit<FindManynotificationArgs, 'select' | 'include'>): Promise<number>

  

    /**
     * Aggregate
     */
    aggregate<T extends AggregateNotificationArgs>(args: Subset<T, AggregateNotificationArgs>): Promise<GetNotificationAggregateType<T>>
  }

  /**
   * The delegate class that acts as a "Promise-like" for notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__notificationClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends userArgs = {}>(args?: Subset<T, userArgs>): CheckSelect<T, Prisma__userClient<user | null>, Prisma__userClient<userGetPayload<T> | null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * notification findUnique
   */
  export type FindUniquenotificationArgs = {
    /**
     * Select specific fields to fetch from the notification
    **/
    select?: notificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: notificationInclude | null
    /**
     * Filter, which notification to fetch.
    **/
    where: notificationWhereUniqueInput
  }


  /**
   * notification findFirst
   */
  export type FindFirstnotificationArgs = {
    /**
     * Select specific fields to fetch from the notification
    **/
    select?: notificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: notificationInclude | null
    /**
     * Filter, which notification to fetch.
    **/
    where?: notificationWhereInput
    orderBy?: Enumerable<notificationOrderByInput>
    cursor?: notificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<NotificationScalarFieldEnum>
  }


  /**
   * notification findMany
   */
  export type FindManynotificationArgs = {
    /**
     * Select specific fields to fetch from the notification
    **/
    select?: notificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: notificationInclude | null
    /**
     * Filter, which notifications to fetch.
    **/
    where?: notificationWhereInput
    /**
     * Determine the order of the notifications to fetch.
    **/
    orderBy?: Enumerable<notificationOrderByInput>
    /**
     * Sets the position for listing notifications.
    **/
    cursor?: notificationWhereUniqueInput
    /**
     * The number of notifications to fetch. If negative number, it will take notifications before the `cursor`.
    **/
    take?: number
    /**
     * Skip the first `n` notifications.
    **/
    skip?: number
    distinct?: Enumerable<NotificationScalarFieldEnum>
  }


  /**
   * notification create
   */
  export type notificationCreateArgs = {
    /**
     * Select specific fields to fetch from the notification
    **/
    select?: notificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: notificationInclude | null
    /**
     * The data needed to create a notification.
    **/
    data: notificationCreateInput
  }


  /**
   * notification update
   */
  export type notificationUpdateArgs = {
    /**
     * Select specific fields to fetch from the notification
    **/
    select?: notificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: notificationInclude | null
    /**
     * The data needed to update a notification.
    **/
    data: notificationUpdateInput
    /**
     * Choose, which notification to update.
    **/
    where: notificationWhereUniqueInput
  }


  /**
   * notification updateMany
   */
  export type notificationUpdateManyArgs = {
    data: notificationUpdateManyMutationInput
    where?: notificationWhereInput
  }


  /**
   * notification upsert
   */
  export type notificationUpsertArgs = {
    /**
     * Select specific fields to fetch from the notification
    **/
    select?: notificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: notificationInclude | null
    /**
     * The filter to search for the notification to update in case it exists.
    **/
    where: notificationWhereUniqueInput
    /**
     * In case the notification found by the `where` argument doesn't exist, create a new notification with this data.
    **/
    create: notificationCreateInput
    /**
     * In case the notification was found with the provided `where` argument, update it with this data.
    **/
    update: notificationUpdateInput
  }


  /**
   * notification delete
   */
  export type notificationDeleteArgs = {
    /**
     * Select specific fields to fetch from the notification
    **/
    select?: notificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: notificationInclude | null
    /**
     * Filter which notification to delete.
    **/
    where: notificationWhereUniqueInput
  }


  /**
   * notification deleteMany
   */
  export type notificationDeleteManyArgs = {
    where?: notificationWhereInput
  }


  /**
   * notification without action
   */
  export type notificationArgs = {
    /**
     * Select specific fields to fetch from the notification
    **/
    select?: notificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: notificationInclude | null
  }



  /**
   * Model plague
   */


  export type AggregatePlague = {
    count: number | null
    avg: PlagueAvgAggregateOutputType | null
    sum: PlagueSumAggregateOutputType | null
    min: PlagueMinAggregateOutputType | null
    max: PlagueMaxAggregateOutputType | null
  }

  export type PlagueAvgAggregateOutputType = {
    id: number
    relevance_order: number | null
  }

  export type PlagueSumAggregateOutputType = {
    id: number
    relevance_order: number | null
  }

  export type PlagueMinAggregateOutputType = {
    id: number
    name: string | null
    display_name: string | null
    color: string | null
    in_use: boolean | null
    relevance_order: number | null
  }

  export type PlagueMaxAggregateOutputType = {
    id: number
    name: string | null
    display_name: string | null
    color: string | null
    in_use: boolean | null
    relevance_order: number | null
  }

  export type PlagueCountAggregateOutputType = {
    id: number
    name: number | null
    display_name: number | null
    color: number | null
    in_use: number | null
    relevance_order: number | null
    _all: number
  }


  export type PlagueAvgAggregateInputType = {
    id?: true
    relevance_order?: true
  }

  export type PlagueSumAggregateInputType = {
    id?: true
    relevance_order?: true
  }

  export type PlagueMinAggregateInputType = {
    id?: true
    name?: true
    display_name?: true
    color?: true
    in_use?: true
    relevance_order?: true
  }

  export type PlagueMaxAggregateInputType = {
    id?: true
    name?: true
    display_name?: true
    color?: true
    in_use?: true
    relevance_order?: true
  }

  export type PlagueCountAggregateInputType = {
    id?: true
    name?: true
    display_name?: true
    color?: true
    in_use?: true
    relevance_order?: true
    _all?: true
  }

  export type AggregatePlagueArgs = {
    where?: plagueWhereInput
    orderBy?: Enumerable<plagueOrderByInput>
    cursor?: plagueWhereUniqueInput
    take?: number
    skip?: number
    count?: true
    avg?: PlagueAvgAggregateInputType
    sum?: PlagueSumAggregateInputType
    min?: PlagueMinAggregateInputType
    max?: PlagueMaxAggregateInputType
  }

  export type GetPlagueAggregateType<T extends AggregatePlagueArgs> = {
    [P in keyof T]: P extends 'count' ? number : GetPlagueAggregateScalarType<T[P]>
  }

  export type GetPlagueAggregateScalarType<T extends any> = {
    [P in keyof T]: P extends keyof PlagueAvgAggregateOutputType ? PlagueAvgAggregateOutputType[P] : never
  }

    



  export type plagueSelect = {
    id?: boolean
    name?: boolean
    display_name?: boolean
    color?: boolean
    in_use?: boolean
    relevance_order?: boolean
    infestation?: boolean | FindManyinfestationArgs
  }

  export type plagueInclude = {
    infestation?: boolean | FindManyinfestationArgs
  }

  export type plagueGetPayload<
    S extends boolean | null | undefined | plagueArgs,
    U = keyof S
      > = S extends true
        ? plague
    : S extends undefined
    ? never
    : S extends plagueArgs | FindManyplagueArgs
    ?'include' extends U
    ? plague  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'infestation'
        ? Array < infestationGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof plague ?plague [P]
  : 
          P extends 'infestation'
        ? Array < infestationGetPayload<S['select'][P]>>  : never
  } 
    : plague
  : plague


  export interface plagueDelegate {
    /**
     * Find zero or one Plague that matches the filter.
     * @param {FindUniqueplagueArgs} args - Arguments to find a Plague
     * @example
     * // Get one Plague
     * const plague = await prisma.plague.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FindUniqueplagueArgs>(
      args: Subset<T, FindUniqueplagueArgs>
    ): CheckSelect<T, Prisma__plagueClient<plague | null>, Prisma__plagueClient<plagueGetPayload<T> | null>>
    /**
     * Find the first Plague that matches the filter.
     * @param {FindFirstplagueArgs} args - Arguments to find a Plague
     * @example
     * // Get one Plague
     * const plague = await prisma.plague.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FindFirstplagueArgs>(
      args?: Subset<T, FindFirstplagueArgs>
    ): CheckSelect<T, Prisma__plagueClient<plague | null>, Prisma__plagueClient<plagueGetPayload<T> | null>>
    /**
     * Find zero or more Plagues that matches the filter.
     * @param {FindManyplagueArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Plagues
     * const plagues = await prisma.plague.findMany()
     * 
     * // Get first 10 Plagues
     * const plagues = await prisma.plague.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const plagueWithIdOnly = await prisma.plague.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FindManyplagueArgs>(
      args?: Subset<T, FindManyplagueArgs>
    ): CheckSelect<T, Promise<Array<plague>>, Promise<Array<plagueGetPayload<T>>>>
    /**
     * Create a Plague.
     * @param {plagueCreateArgs} args - Arguments to create a Plague.
     * @example
     * // Create one Plague
     * const Plague = await prisma.plague.create({
     *   data: {
     *     // ... data to create a Plague
     *   }
     * })
     * 
    **/
    create<T extends plagueCreateArgs>(
      args: Subset<T, plagueCreateArgs>
    ): CheckSelect<T, Prisma__plagueClient<plague>, Prisma__plagueClient<plagueGetPayload<T>>>
    /**
     * Delete a Plague.
     * @param {plagueDeleteArgs} args - Arguments to delete one Plague.
     * @example
     * // Delete one Plague
     * const Plague = await prisma.plague.delete({
     *   where: {
     *     // ... filter to delete one Plague
     *   }
     * })
     * 
    **/
    delete<T extends plagueDeleteArgs>(
      args: Subset<T, plagueDeleteArgs>
    ): CheckSelect<T, Prisma__plagueClient<plague>, Prisma__plagueClient<plagueGetPayload<T>>>
    /**
     * Update one Plague.
     * @param {plagueUpdateArgs} args - Arguments to update one Plague.
     * @example
     * // Update one Plague
     * const plague = await prisma.plague.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends plagueUpdateArgs>(
      args: Subset<T, plagueUpdateArgs>
    ): CheckSelect<T, Prisma__plagueClient<plague>, Prisma__plagueClient<plagueGetPayload<T>>>
    /**
     * Delete zero or more Plagues.
     * @param {plagueDeleteManyArgs} args - Arguments to filter Plagues to delete.
     * @example
     * // Delete a few Plagues
     * const { count } = await prisma.plague.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends plagueDeleteManyArgs>(
      args?: Subset<T, plagueDeleteManyArgs>
    ): Promise<BatchPayload>
    /**
     * Update zero or more Plagues.
     * @param {plagueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Plagues
     * const plague = await prisma.plague.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends plagueUpdateManyArgs>(
      args: Subset<T, plagueUpdateManyArgs>
    ): Promise<BatchPayload>
    /**
     * Create or update one Plague.
     * @param {plagueUpsertArgs} args - Arguments to update or create a Plague.
     * @example
     * // Update or create a Plague
     * const plague = await prisma.plague.upsert({
     *   create: {
     *     // ... data to create a Plague
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Plague we want to update
     *   }
     * })
    **/
    upsert<T extends plagueUpsertArgs>(
      args: Subset<T, plagueUpsertArgs>
    ): CheckSelect<T, Prisma__plagueClient<plague>, Prisma__plagueClient<plagueGetPayload<T>>>
    /**
     * Find zero or one Plague that matches the filter.
     * @param {FindUniqueplagueArgs} args - Arguments to find a Plague
     * @deprecated This will be deprecated please use prisma.plague.findUnique
     * @example
     * // Get one Plague
     * const plague = await prisma.plague.findOne({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findOne<T extends FindUniqueplagueArgs>(
      args: Subset<T, FindUniqueplagueArgs>
    ): CheckSelect<T, Prisma__plagueClient<plague | null>, Prisma__plagueClient<plagueGetPayload<T> | null>>
    /**
     * Count
     */
    count(args?: Omit<FindManyplagueArgs, 'select' | 'include'>): Promise<number>

  

    /**
     * Aggregate
     */
    aggregate<T extends AggregatePlagueArgs>(args: Subset<T, AggregatePlagueArgs>): Promise<GetPlagueAggregateType<T>>
  }

  /**
   * The delegate class that acts as a "Promise-like" for plague.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__plagueClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    infestation<T extends FindManyinfestationArgs = {}>(args?: Subset<T, FindManyinfestationArgs>): CheckSelect<T, Promise<Array<infestation>>, Promise<Array<infestationGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * plague findUnique
   */
  export type FindUniqueplagueArgs = {
    /**
     * Select specific fields to fetch from the plague
    **/
    select?: plagueSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: plagueInclude | null
    /**
     * Filter, which plague to fetch.
    **/
    where: plagueWhereUniqueInput
  }


  /**
   * plague findFirst
   */
  export type FindFirstplagueArgs = {
    /**
     * Select specific fields to fetch from the plague
    **/
    select?: plagueSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: plagueInclude | null
    /**
     * Filter, which plague to fetch.
    **/
    where?: plagueWhereInput
    orderBy?: Enumerable<plagueOrderByInput>
    cursor?: plagueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PlagueScalarFieldEnum>
  }


  /**
   * plague findMany
   */
  export type FindManyplagueArgs = {
    /**
     * Select specific fields to fetch from the plague
    **/
    select?: plagueSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: plagueInclude | null
    /**
     * Filter, which plagues to fetch.
    **/
    where?: plagueWhereInput
    /**
     * Determine the order of the plagues to fetch.
    **/
    orderBy?: Enumerable<plagueOrderByInput>
    /**
     * Sets the position for listing plagues.
    **/
    cursor?: plagueWhereUniqueInput
    /**
     * The number of plagues to fetch. If negative number, it will take plagues before the `cursor`.
    **/
    take?: number
    /**
     * Skip the first `n` plagues.
    **/
    skip?: number
    distinct?: Enumerable<PlagueScalarFieldEnum>
  }


  /**
   * plague create
   */
  export type plagueCreateArgs = {
    /**
     * Select specific fields to fetch from the plague
    **/
    select?: plagueSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: plagueInclude | null
    /**
     * The data needed to create a plague.
    **/
    data: plagueCreateInput
  }


  /**
   * plague update
   */
  export type plagueUpdateArgs = {
    /**
     * Select specific fields to fetch from the plague
    **/
    select?: plagueSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: plagueInclude | null
    /**
     * The data needed to update a plague.
    **/
    data: plagueUpdateInput
    /**
     * Choose, which plague to update.
    **/
    where: plagueWhereUniqueInput
  }


  /**
   * plague updateMany
   */
  export type plagueUpdateManyArgs = {
    data: plagueUpdateManyMutationInput
    where?: plagueWhereInput
  }


  /**
   * plague upsert
   */
  export type plagueUpsertArgs = {
    /**
     * Select specific fields to fetch from the plague
    **/
    select?: plagueSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: plagueInclude | null
    /**
     * The filter to search for the plague to update in case it exists.
    **/
    where: plagueWhereUniqueInput
    /**
     * In case the plague found by the `where` argument doesn't exist, create a new plague with this data.
    **/
    create: plagueCreateInput
    /**
     * In case the plague was found with the provided `where` argument, update it with this data.
    **/
    update: plagueUpdateInput
  }


  /**
   * plague delete
   */
  export type plagueDeleteArgs = {
    /**
     * Select specific fields to fetch from the plague
    **/
    select?: plagueSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: plagueInclude | null
    /**
     * Filter which plague to delete.
    **/
    where: plagueWhereUniqueInput
  }


  /**
   * plague deleteMany
   */
  export type plagueDeleteManyArgs = {
    where?: plagueWhereInput
  }


  /**
   * plague without action
   */
  export type plagueArgs = {
    /**
     * Select specific fields to fetch from the plague
    **/
    select?: plagueSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: plagueInclude | null
  }



  /**
   * Model prescription
   */


  export type AggregatePrescription = {
    count: number | null
    avg: PrescriptionAvgAggregateOutputType | null
    sum: PrescriptionSumAggregateOutputType | null
    min: PrescriptionMinAggregateOutputType | null
    max: PrescriptionMaxAggregateOutputType | null
  }

  export type PrescriptionAvgAggregateOutputType = {
    id: number
    pulverization_method: number
    diagnosis_id: number
  }

  export type PrescriptionSumAggregateOutputType = {
    id: number
    pulverization_method: number
    diagnosis_id: number
  }

  export type PrescriptionMinAggregateOutputType = {
    id: number
    date: Date | null
    content: JsonValue | null
    pulverization_method: number
    author: string | null
    phone_number: string | null
    diagnosis_id: number
  }

  export type PrescriptionMaxAggregateOutputType = {
    id: number
    date: Date | null
    content: JsonValue | null
    pulverization_method: number
    author: string | null
    phone_number: string | null
    diagnosis_id: number
  }

  export type PrescriptionCountAggregateOutputType = {
    id: number
    date: number | null
    content: number | null
    pulverization_method: number
    author: number | null
    phone_number: number | null
    diagnosis_id: number
    _all: number
  }


  export type PrescriptionAvgAggregateInputType = {
    id?: true
    pulverization_method?: true
    diagnosis_id?: true
  }

  export type PrescriptionSumAggregateInputType = {
    id?: true
    pulverization_method?: true
    diagnosis_id?: true
  }

  export type PrescriptionMinAggregateInputType = {
    id?: true
    date?: true
    content?: true
    pulverization_method?: true
    author?: true
    phone_number?: true
    diagnosis_id?: true
  }

  export type PrescriptionMaxAggregateInputType = {
    id?: true
    date?: true
    content?: true
    pulverization_method?: true
    author?: true
    phone_number?: true
    diagnosis_id?: true
  }

  export type PrescriptionCountAggregateInputType = {
    id?: true
    date?: true
    content?: true
    pulverization_method?: true
    author?: true
    phone_number?: true
    diagnosis_id?: true
    _all?: true
  }

  export type AggregatePrescriptionArgs = {
    where?: prescriptionWhereInput
    orderBy?: Enumerable<prescriptionOrderByInput>
    cursor?: prescriptionWhereUniqueInput
    take?: number
    skip?: number
    count?: true
    avg?: PrescriptionAvgAggregateInputType
    sum?: PrescriptionSumAggregateInputType
    min?: PrescriptionMinAggregateInputType
    max?: PrescriptionMaxAggregateInputType
  }

  export type GetPrescriptionAggregateType<T extends AggregatePrescriptionArgs> = {
    [P in keyof T]: P extends 'count' ? number : GetPrescriptionAggregateScalarType<T[P]>
  }

  export type GetPrescriptionAggregateScalarType<T extends any> = {
    [P in keyof T]: P extends keyof PrescriptionAvgAggregateOutputType ? PrescriptionAvgAggregateOutputType[P] : never
  }

    



  export type prescriptionSelect = {
    id?: boolean
    date?: boolean
    content?: boolean
    pulverization_method?: boolean
    author?: boolean
    phone_number?: boolean
    diagnosis_id?: boolean
    diagnosis?: boolean | diagnosisArgs
  }

  export type prescriptionInclude = {
    diagnosis?: boolean | diagnosisArgs
  }

  export type prescriptionGetPayload<
    S extends boolean | null | undefined | prescriptionArgs,
    U = keyof S
      > = S extends true
        ? prescription
    : S extends undefined
    ? never
    : S extends prescriptionArgs | FindManyprescriptionArgs
    ?'include' extends U
    ? prescription  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'diagnosis'
        ? diagnosisGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof prescription ?prescription [P]
  : 
          P extends 'diagnosis'
        ? diagnosisGetPayload<S['select'][P]> : never
  } 
    : prescription
  : prescription


  export interface prescriptionDelegate {
    /**
     * Find zero or one Prescription that matches the filter.
     * @param {FindUniqueprescriptionArgs} args - Arguments to find a Prescription
     * @example
     * // Get one Prescription
     * const prescription = await prisma.prescription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FindUniqueprescriptionArgs>(
      args: Subset<T, FindUniqueprescriptionArgs>
    ): CheckSelect<T, Prisma__prescriptionClient<prescription | null>, Prisma__prescriptionClient<prescriptionGetPayload<T> | null>>
    /**
     * Find the first Prescription that matches the filter.
     * @param {FindFirstprescriptionArgs} args - Arguments to find a Prescription
     * @example
     * // Get one Prescription
     * const prescription = await prisma.prescription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FindFirstprescriptionArgs>(
      args?: Subset<T, FindFirstprescriptionArgs>
    ): CheckSelect<T, Prisma__prescriptionClient<prescription | null>, Prisma__prescriptionClient<prescriptionGetPayload<T> | null>>
    /**
     * Find zero or more Prescriptions that matches the filter.
     * @param {FindManyprescriptionArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Prescriptions
     * const prescriptions = await prisma.prescription.findMany()
     * 
     * // Get first 10 Prescriptions
     * const prescriptions = await prisma.prescription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const prescriptionWithIdOnly = await prisma.prescription.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FindManyprescriptionArgs>(
      args?: Subset<T, FindManyprescriptionArgs>
    ): CheckSelect<T, Promise<Array<prescription>>, Promise<Array<prescriptionGetPayload<T>>>>
    /**
     * Create a Prescription.
     * @param {prescriptionCreateArgs} args - Arguments to create a Prescription.
     * @example
     * // Create one Prescription
     * const Prescription = await prisma.prescription.create({
     *   data: {
     *     // ... data to create a Prescription
     *   }
     * })
     * 
    **/
    create<T extends prescriptionCreateArgs>(
      args: Subset<T, prescriptionCreateArgs>
    ): CheckSelect<T, Prisma__prescriptionClient<prescription>, Prisma__prescriptionClient<prescriptionGetPayload<T>>>
    /**
     * Delete a Prescription.
     * @param {prescriptionDeleteArgs} args - Arguments to delete one Prescription.
     * @example
     * // Delete one Prescription
     * const Prescription = await prisma.prescription.delete({
     *   where: {
     *     // ... filter to delete one Prescription
     *   }
     * })
     * 
    **/
    delete<T extends prescriptionDeleteArgs>(
      args: Subset<T, prescriptionDeleteArgs>
    ): CheckSelect<T, Prisma__prescriptionClient<prescription>, Prisma__prescriptionClient<prescriptionGetPayload<T>>>
    /**
     * Update one Prescription.
     * @param {prescriptionUpdateArgs} args - Arguments to update one Prescription.
     * @example
     * // Update one Prescription
     * const prescription = await prisma.prescription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends prescriptionUpdateArgs>(
      args: Subset<T, prescriptionUpdateArgs>
    ): CheckSelect<T, Prisma__prescriptionClient<prescription>, Prisma__prescriptionClient<prescriptionGetPayload<T>>>
    /**
     * Delete zero or more Prescriptions.
     * @param {prescriptionDeleteManyArgs} args - Arguments to filter Prescriptions to delete.
     * @example
     * // Delete a few Prescriptions
     * const { count } = await prisma.prescription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends prescriptionDeleteManyArgs>(
      args?: Subset<T, prescriptionDeleteManyArgs>
    ): Promise<BatchPayload>
    /**
     * Update zero or more Prescriptions.
     * @param {prescriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Prescriptions
     * const prescription = await prisma.prescription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends prescriptionUpdateManyArgs>(
      args: Subset<T, prescriptionUpdateManyArgs>
    ): Promise<BatchPayload>
    /**
     * Create or update one Prescription.
     * @param {prescriptionUpsertArgs} args - Arguments to update or create a Prescription.
     * @example
     * // Update or create a Prescription
     * const prescription = await prisma.prescription.upsert({
     *   create: {
     *     // ... data to create a Prescription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Prescription we want to update
     *   }
     * })
    **/
    upsert<T extends prescriptionUpsertArgs>(
      args: Subset<T, prescriptionUpsertArgs>
    ): CheckSelect<T, Prisma__prescriptionClient<prescription>, Prisma__prescriptionClient<prescriptionGetPayload<T>>>
    /**
     * Find zero or one Prescription that matches the filter.
     * @param {FindUniqueprescriptionArgs} args - Arguments to find a Prescription
     * @deprecated This will be deprecated please use prisma.prescription.findUnique
     * @example
     * // Get one Prescription
     * const prescription = await prisma.prescription.findOne({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findOne<T extends FindUniqueprescriptionArgs>(
      args: Subset<T, FindUniqueprescriptionArgs>
    ): CheckSelect<T, Prisma__prescriptionClient<prescription | null>, Prisma__prescriptionClient<prescriptionGetPayload<T> | null>>
    /**
     * Count
     */
    count(args?: Omit<FindManyprescriptionArgs, 'select' | 'include'>): Promise<number>

  

    /**
     * Aggregate
     */
    aggregate<T extends AggregatePrescriptionArgs>(args: Subset<T, AggregatePrescriptionArgs>): Promise<GetPrescriptionAggregateType<T>>
  }

  /**
   * The delegate class that acts as a "Promise-like" for prescription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__prescriptionClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    diagnosis<T extends diagnosisArgs = {}>(args?: Subset<T, diagnosisArgs>): CheckSelect<T, Prisma__diagnosisClient<diagnosis | null>, Prisma__diagnosisClient<diagnosisGetPayload<T> | null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * prescription findUnique
   */
  export type FindUniqueprescriptionArgs = {
    /**
     * Select specific fields to fetch from the prescription
    **/
    select?: prescriptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: prescriptionInclude | null
    /**
     * Filter, which prescription to fetch.
    **/
    where: prescriptionWhereUniqueInput
  }


  /**
   * prescription findFirst
   */
  export type FindFirstprescriptionArgs = {
    /**
     * Select specific fields to fetch from the prescription
    **/
    select?: prescriptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: prescriptionInclude | null
    /**
     * Filter, which prescription to fetch.
    **/
    where?: prescriptionWhereInput
    orderBy?: Enumerable<prescriptionOrderByInput>
    cursor?: prescriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PrescriptionScalarFieldEnum>
  }


  /**
   * prescription findMany
   */
  export type FindManyprescriptionArgs = {
    /**
     * Select specific fields to fetch from the prescription
    **/
    select?: prescriptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: prescriptionInclude | null
    /**
     * Filter, which prescriptions to fetch.
    **/
    where?: prescriptionWhereInput
    /**
     * Determine the order of the prescriptions to fetch.
    **/
    orderBy?: Enumerable<prescriptionOrderByInput>
    /**
     * Sets the position for listing prescriptions.
    **/
    cursor?: prescriptionWhereUniqueInput
    /**
     * The number of prescriptions to fetch. If negative number, it will take prescriptions before the `cursor`.
    **/
    take?: number
    /**
     * Skip the first `n` prescriptions.
    **/
    skip?: number
    distinct?: Enumerable<PrescriptionScalarFieldEnum>
  }


  /**
   * prescription create
   */
  export type prescriptionCreateArgs = {
    /**
     * Select specific fields to fetch from the prescription
    **/
    select?: prescriptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: prescriptionInclude | null
    /**
     * The data needed to create a prescription.
    **/
    data: prescriptionCreateInput
  }


  /**
   * prescription update
   */
  export type prescriptionUpdateArgs = {
    /**
     * Select specific fields to fetch from the prescription
    **/
    select?: prescriptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: prescriptionInclude | null
    /**
     * The data needed to update a prescription.
    **/
    data: prescriptionUpdateInput
    /**
     * Choose, which prescription to update.
    **/
    where: prescriptionWhereUniqueInput
  }


  /**
   * prescription updateMany
   */
  export type prescriptionUpdateManyArgs = {
    data: prescriptionUpdateManyMutationInput
    where?: prescriptionWhereInput
  }


  /**
   * prescription upsert
   */
  export type prescriptionUpsertArgs = {
    /**
     * Select specific fields to fetch from the prescription
    **/
    select?: prescriptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: prescriptionInclude | null
    /**
     * The filter to search for the prescription to update in case it exists.
    **/
    where: prescriptionWhereUniqueInput
    /**
     * In case the prescription found by the `where` argument doesn't exist, create a new prescription with this data.
    **/
    create: prescriptionCreateInput
    /**
     * In case the prescription was found with the provided `where` argument, update it with this data.
    **/
    update: prescriptionUpdateInput
  }


  /**
   * prescription delete
   */
  export type prescriptionDeleteArgs = {
    /**
     * Select specific fields to fetch from the prescription
    **/
    select?: prescriptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: prescriptionInclude | null
    /**
     * Filter which prescription to delete.
    **/
    where: prescriptionWhereUniqueInput
  }


  /**
   * prescription deleteMany
   */
  export type prescriptionDeleteManyArgs = {
    where?: prescriptionWhereInput
  }


  /**
   * prescription without action
   */
  export type prescriptionArgs = {
    /**
     * Select specific fields to fetch from the prescription
    **/
    select?: prescriptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: prescriptionInclude | null
  }



  /**
   * Model privacy_policy
   */


  export type AggregatePrivacy_policy = {
    count: number | null
    avg: Privacy_policyAvgAggregateOutputType | null
    sum: Privacy_policySumAggregateOutputType | null
    min: Privacy_policyMinAggregateOutputType | null
    max: Privacy_policyMaxAggregateOutputType | null
  }

  export type Privacy_policyAvgAggregateOutputType = {
    id: number
  }

  export type Privacy_policySumAggregateOutputType = {
    id: number
  }

  export type Privacy_policyMinAggregateOutputType = {
    id: number
    content: string | null
    publish_date: Date | null
  }

  export type Privacy_policyMaxAggregateOutputType = {
    id: number
    content: string | null
    publish_date: Date | null
  }

  export type Privacy_policyCountAggregateOutputType = {
    id: number
    content: number | null
    publish_date: number | null
    _all: number
  }


  export type Privacy_policyAvgAggregateInputType = {
    id?: true
  }

  export type Privacy_policySumAggregateInputType = {
    id?: true
  }

  export type Privacy_policyMinAggregateInputType = {
    id?: true
    content?: true
    publish_date?: true
  }

  export type Privacy_policyMaxAggregateInputType = {
    id?: true
    content?: true
    publish_date?: true
  }

  export type Privacy_policyCountAggregateInputType = {
    id?: true
    content?: true
    publish_date?: true
    _all?: true
  }

  export type AggregatePrivacy_policyArgs = {
    where?: privacy_policyWhereInput
    orderBy?: Enumerable<privacy_policyOrderByInput>
    cursor?: privacy_policyWhereUniqueInput
    take?: number
    skip?: number
    count?: true
    avg?: Privacy_policyAvgAggregateInputType
    sum?: Privacy_policySumAggregateInputType
    min?: Privacy_policyMinAggregateInputType
    max?: Privacy_policyMaxAggregateInputType
  }

  export type GetPrivacy_policyAggregateType<T extends AggregatePrivacy_policyArgs> = {
    [P in keyof T]: P extends 'count' ? number : GetPrivacy_policyAggregateScalarType<T[P]>
  }

  export type GetPrivacy_policyAggregateScalarType<T extends any> = {
    [P in keyof T]: P extends keyof Privacy_policyAvgAggregateOutputType ? Privacy_policyAvgAggregateOutputType[P] : never
  }

    



  export type privacy_policySelect = {
    id?: boolean
    content?: boolean
    publish_date?: boolean
    user_accepted_privacy_policy?: boolean | FindManyuser_accepted_privacy_policyArgs
  }

  export type privacy_policyInclude = {
    user_accepted_privacy_policy?: boolean | FindManyuser_accepted_privacy_policyArgs
  }

  export type privacy_policyGetPayload<
    S extends boolean | null | undefined | privacy_policyArgs,
    U = keyof S
      > = S extends true
        ? privacy_policy
    : S extends undefined
    ? never
    : S extends privacy_policyArgs | FindManyprivacy_policyArgs
    ?'include' extends U
    ? privacy_policy  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'user_accepted_privacy_policy'
        ? Array < user_accepted_privacy_policyGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof privacy_policy ?privacy_policy [P]
  : 
          P extends 'user_accepted_privacy_policy'
        ? Array < user_accepted_privacy_policyGetPayload<S['select'][P]>>  : never
  } 
    : privacy_policy
  : privacy_policy


  export interface privacy_policyDelegate {
    /**
     * Find zero or one Privacy_policy that matches the filter.
     * @param {FindUniqueprivacy_policyArgs} args - Arguments to find a Privacy_policy
     * @example
     * // Get one Privacy_policy
     * const privacy_policy = await prisma.privacy_policy.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FindUniqueprivacy_policyArgs>(
      args: Subset<T, FindUniqueprivacy_policyArgs>
    ): CheckSelect<T, Prisma__privacy_policyClient<privacy_policy | null>, Prisma__privacy_policyClient<privacy_policyGetPayload<T> | null>>
    /**
     * Find the first Privacy_policy that matches the filter.
     * @param {FindFirstprivacy_policyArgs} args - Arguments to find a Privacy_policy
     * @example
     * // Get one Privacy_policy
     * const privacy_policy = await prisma.privacy_policy.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FindFirstprivacy_policyArgs>(
      args?: Subset<T, FindFirstprivacy_policyArgs>
    ): CheckSelect<T, Prisma__privacy_policyClient<privacy_policy | null>, Prisma__privacy_policyClient<privacy_policyGetPayload<T> | null>>
    /**
     * Find zero or more Privacy_policies that matches the filter.
     * @param {FindManyprivacy_policyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Privacy_policies
     * const privacy_policies = await prisma.privacy_policy.findMany()
     * 
     * // Get first 10 Privacy_policies
     * const privacy_policies = await prisma.privacy_policy.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const privacy_policyWithIdOnly = await prisma.privacy_policy.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FindManyprivacy_policyArgs>(
      args?: Subset<T, FindManyprivacy_policyArgs>
    ): CheckSelect<T, Promise<Array<privacy_policy>>, Promise<Array<privacy_policyGetPayload<T>>>>
    /**
     * Create a Privacy_policy.
     * @param {privacy_policyCreateArgs} args - Arguments to create a Privacy_policy.
     * @example
     * // Create one Privacy_policy
     * const Privacy_policy = await prisma.privacy_policy.create({
     *   data: {
     *     // ... data to create a Privacy_policy
     *   }
     * })
     * 
    **/
    create<T extends privacy_policyCreateArgs>(
      args: Subset<T, privacy_policyCreateArgs>
    ): CheckSelect<T, Prisma__privacy_policyClient<privacy_policy>, Prisma__privacy_policyClient<privacy_policyGetPayload<T>>>
    /**
     * Delete a Privacy_policy.
     * @param {privacy_policyDeleteArgs} args - Arguments to delete one Privacy_policy.
     * @example
     * // Delete one Privacy_policy
     * const Privacy_policy = await prisma.privacy_policy.delete({
     *   where: {
     *     // ... filter to delete one Privacy_policy
     *   }
     * })
     * 
    **/
    delete<T extends privacy_policyDeleteArgs>(
      args: Subset<T, privacy_policyDeleteArgs>
    ): CheckSelect<T, Prisma__privacy_policyClient<privacy_policy>, Prisma__privacy_policyClient<privacy_policyGetPayload<T>>>
    /**
     * Update one Privacy_policy.
     * @param {privacy_policyUpdateArgs} args - Arguments to update one Privacy_policy.
     * @example
     * // Update one Privacy_policy
     * const privacy_policy = await prisma.privacy_policy.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends privacy_policyUpdateArgs>(
      args: Subset<T, privacy_policyUpdateArgs>
    ): CheckSelect<T, Prisma__privacy_policyClient<privacy_policy>, Prisma__privacy_policyClient<privacy_policyGetPayload<T>>>
    /**
     * Delete zero or more Privacy_policies.
     * @param {privacy_policyDeleteManyArgs} args - Arguments to filter Privacy_policies to delete.
     * @example
     * // Delete a few Privacy_policies
     * const { count } = await prisma.privacy_policy.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends privacy_policyDeleteManyArgs>(
      args?: Subset<T, privacy_policyDeleteManyArgs>
    ): Promise<BatchPayload>
    /**
     * Update zero or more Privacy_policies.
     * @param {privacy_policyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Privacy_policies
     * const privacy_policy = await prisma.privacy_policy.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends privacy_policyUpdateManyArgs>(
      args: Subset<T, privacy_policyUpdateManyArgs>
    ): Promise<BatchPayload>
    /**
     * Create or update one Privacy_policy.
     * @param {privacy_policyUpsertArgs} args - Arguments to update or create a Privacy_policy.
     * @example
     * // Update or create a Privacy_policy
     * const privacy_policy = await prisma.privacy_policy.upsert({
     *   create: {
     *     // ... data to create a Privacy_policy
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Privacy_policy we want to update
     *   }
     * })
    **/
    upsert<T extends privacy_policyUpsertArgs>(
      args: Subset<T, privacy_policyUpsertArgs>
    ): CheckSelect<T, Prisma__privacy_policyClient<privacy_policy>, Prisma__privacy_policyClient<privacy_policyGetPayload<T>>>
    /**
     * Find zero or one Privacy_policy that matches the filter.
     * @param {FindUniqueprivacy_policyArgs} args - Arguments to find a Privacy_policy
     * @deprecated This will be deprecated please use prisma.privacy_policy.findUnique
     * @example
     * // Get one Privacy_policy
     * const privacy_policy = await prisma.privacy_policy.findOne({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findOne<T extends FindUniqueprivacy_policyArgs>(
      args: Subset<T, FindUniqueprivacy_policyArgs>
    ): CheckSelect<T, Prisma__privacy_policyClient<privacy_policy | null>, Prisma__privacy_policyClient<privacy_policyGetPayload<T> | null>>
    /**
     * Count
     */
    count(args?: Omit<FindManyprivacy_policyArgs, 'select' | 'include'>): Promise<number>

  

    /**
     * Aggregate
     */
    aggregate<T extends AggregatePrivacy_policyArgs>(args: Subset<T, AggregatePrivacy_policyArgs>): Promise<GetPrivacy_policyAggregateType<T>>
  }

  /**
   * The delegate class that acts as a "Promise-like" for privacy_policy.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__privacy_policyClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user_accepted_privacy_policy<T extends FindManyuser_accepted_privacy_policyArgs = {}>(args?: Subset<T, FindManyuser_accepted_privacy_policyArgs>): CheckSelect<T, Promise<Array<user_accepted_privacy_policy>>, Promise<Array<user_accepted_privacy_policyGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * privacy_policy findUnique
   */
  export type FindUniqueprivacy_policyArgs = {
    /**
     * Select specific fields to fetch from the privacy_policy
    **/
    select?: privacy_policySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: privacy_policyInclude | null
    /**
     * Filter, which privacy_policy to fetch.
    **/
    where: privacy_policyWhereUniqueInput
  }


  /**
   * privacy_policy findFirst
   */
  export type FindFirstprivacy_policyArgs = {
    /**
     * Select specific fields to fetch from the privacy_policy
    **/
    select?: privacy_policySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: privacy_policyInclude | null
    /**
     * Filter, which privacy_policy to fetch.
    **/
    where?: privacy_policyWhereInput
    orderBy?: Enumerable<privacy_policyOrderByInput>
    cursor?: privacy_policyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Privacy_policyScalarFieldEnum>
  }


  /**
   * privacy_policy findMany
   */
  export type FindManyprivacy_policyArgs = {
    /**
     * Select specific fields to fetch from the privacy_policy
    **/
    select?: privacy_policySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: privacy_policyInclude | null
    /**
     * Filter, which privacy_policies to fetch.
    **/
    where?: privacy_policyWhereInput
    /**
     * Determine the order of the privacy_policies to fetch.
    **/
    orderBy?: Enumerable<privacy_policyOrderByInput>
    /**
     * Sets the position for listing privacy_policies.
    **/
    cursor?: privacy_policyWhereUniqueInput
    /**
     * The number of privacy_policies to fetch. If negative number, it will take privacy_policies before the `cursor`.
    **/
    take?: number
    /**
     * Skip the first `n` privacy_policies.
    **/
    skip?: number
    distinct?: Enumerable<Privacy_policyScalarFieldEnum>
  }


  /**
   * privacy_policy create
   */
  export type privacy_policyCreateArgs = {
    /**
     * Select specific fields to fetch from the privacy_policy
    **/
    select?: privacy_policySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: privacy_policyInclude | null
    /**
     * The data needed to create a privacy_policy.
    **/
    data: privacy_policyCreateInput
  }


  /**
   * privacy_policy update
   */
  export type privacy_policyUpdateArgs = {
    /**
     * Select specific fields to fetch from the privacy_policy
    **/
    select?: privacy_policySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: privacy_policyInclude | null
    /**
     * The data needed to update a privacy_policy.
    **/
    data: privacy_policyUpdateInput
    /**
     * Choose, which privacy_policy to update.
    **/
    where: privacy_policyWhereUniqueInput
  }


  /**
   * privacy_policy updateMany
   */
  export type privacy_policyUpdateManyArgs = {
    data: privacy_policyUpdateManyMutationInput
    where?: privacy_policyWhereInput
  }


  /**
   * privacy_policy upsert
   */
  export type privacy_policyUpsertArgs = {
    /**
     * Select specific fields to fetch from the privacy_policy
    **/
    select?: privacy_policySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: privacy_policyInclude | null
    /**
     * The filter to search for the privacy_policy to update in case it exists.
    **/
    where: privacy_policyWhereUniqueInput
    /**
     * In case the privacy_policy found by the `where` argument doesn't exist, create a new privacy_policy with this data.
    **/
    create: privacy_policyCreateInput
    /**
     * In case the privacy_policy was found with the provided `where` argument, update it with this data.
    **/
    update: privacy_policyUpdateInput
  }


  /**
   * privacy_policy delete
   */
  export type privacy_policyDeleteArgs = {
    /**
     * Select specific fields to fetch from the privacy_policy
    **/
    select?: privacy_policySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: privacy_policyInclude | null
    /**
     * Filter which privacy_policy to delete.
    **/
    where: privacy_policyWhereUniqueInput
  }


  /**
   * privacy_policy deleteMany
   */
  export type privacy_policyDeleteManyArgs = {
    where?: privacy_policyWhereInput
  }


  /**
   * privacy_policy without action
   */
  export type privacy_policyArgs = {
    /**
     * Select specific fields to fetch from the privacy_policy
    **/
    select?: privacy_policySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: privacy_policyInclude | null
  }



  /**
   * Model quotation
   */


  export type AggregateQuotation = {
    count: number | null
    avg: QuotationAvgAggregateOutputType | null
    sum: QuotationSumAggregateOutputType | null
    min: QuotationMinAggregateOutputType | null
    max: QuotationMaxAggregateOutputType | null
  }

  export type QuotationAvgAggregateOutputType = {
    id: number
    antecipated_price: number | null
    cash_price: number | null
    delayed_price: number | null
    company_id: number
    quotation_modal_package_id: number
  }

  export type QuotationSumAggregateOutputType = {
    id: number
    antecipated_price: number | null
    cash_price: number | null
    delayed_price: number | null
    company_id: number
    quotation_modal_package_id: number
  }

  export type QuotationMinAggregateOutputType = {
    id: number
    response_date: Date | null
    expiration_date: Date | null
    antecipated_price: number | null
    cash_price: number | null
    delayed_price: number | null
    company_id: number
    quotation_modal_package_id: number
  }

  export type QuotationMaxAggregateOutputType = {
    id: number
    response_date: Date | null
    expiration_date: Date | null
    antecipated_price: number | null
    cash_price: number | null
    delayed_price: number | null
    company_id: number
    quotation_modal_package_id: number
  }

  export type QuotationCountAggregateOutputType = {
    id: number
    response_date: number | null
    expiration_date: number | null
    antecipated_price: number | null
    cash_price: number | null
    delayed_price: number | null
    company_id: number
    quotation_modal_package_id: number
    _all: number
  }


  export type QuotationAvgAggregateInputType = {
    id?: true
    antecipated_price?: true
    cash_price?: true
    delayed_price?: true
    company_id?: true
    quotation_modal_package_id?: true
  }

  export type QuotationSumAggregateInputType = {
    id?: true
    antecipated_price?: true
    cash_price?: true
    delayed_price?: true
    company_id?: true
    quotation_modal_package_id?: true
  }

  export type QuotationMinAggregateInputType = {
    id?: true
    response_date?: true
    expiration_date?: true
    antecipated_price?: true
    cash_price?: true
    delayed_price?: true
    company_id?: true
    quotation_modal_package_id?: true
  }

  export type QuotationMaxAggregateInputType = {
    id?: true
    response_date?: true
    expiration_date?: true
    antecipated_price?: true
    cash_price?: true
    delayed_price?: true
    company_id?: true
    quotation_modal_package_id?: true
  }

  export type QuotationCountAggregateInputType = {
    id?: true
    response_date?: true
    expiration_date?: true
    antecipated_price?: true
    cash_price?: true
    delayed_price?: true
    company_id?: true
    quotation_modal_package_id?: true
    _all?: true
  }

  export type AggregateQuotationArgs = {
    where?: quotationWhereInput
    orderBy?: Enumerable<quotationOrderByInput>
    cursor?: quotationWhereUniqueInput
    take?: number
    skip?: number
    count?: true
    avg?: QuotationAvgAggregateInputType
    sum?: QuotationSumAggregateInputType
    min?: QuotationMinAggregateInputType
    max?: QuotationMaxAggregateInputType
  }

  export type GetQuotationAggregateType<T extends AggregateQuotationArgs> = {
    [P in keyof T]: P extends 'count' ? number : GetQuotationAggregateScalarType<T[P]>
  }

  export type GetQuotationAggregateScalarType<T extends any> = {
    [P in keyof T]: P extends keyof QuotationAvgAggregateOutputType ? QuotationAvgAggregateOutputType[P] : never
  }

    



  export type quotationSelect = {
    id?: boolean
    response_date?: boolean
    expiration_date?: boolean
    antecipated_price?: boolean
    cash_price?: boolean
    delayed_price?: boolean
    company_id?: boolean
    quotation_modal_package_id?: boolean
    company?: boolean | companyArgs
    quotation_modal_package?: boolean | quotation_modal_packageArgs
    quotation_checkout?: boolean | quotation_checkoutArgs
  }

  export type quotationInclude = {
    company?: boolean | companyArgs
    quotation_modal_package?: boolean | quotation_modal_packageArgs
    quotation_checkout?: boolean | quotation_checkoutArgs
  }

  export type quotationGetPayload<
    S extends boolean | null | undefined | quotationArgs,
    U = keyof S
      > = S extends true
        ? quotation
    : S extends undefined
    ? never
    : S extends quotationArgs | FindManyquotationArgs
    ?'include' extends U
    ? quotation  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'company'
        ? companyGetPayload<S['include'][P]> :
        P extends 'quotation_modal_package'
        ? quotation_modal_packageGetPayload<S['include'][P]> :
        P extends 'quotation_checkout'
        ? quotation_checkoutGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof quotation ?quotation [P]
  : 
          P extends 'company'
        ? companyGetPayload<S['select'][P]> :
        P extends 'quotation_modal_package'
        ? quotation_modal_packageGetPayload<S['select'][P]> :
        P extends 'quotation_checkout'
        ? quotation_checkoutGetPayload<S['select'][P]> | null : never
  } 
    : quotation
  : quotation


  export interface quotationDelegate {
    /**
     * Find zero or one Quotation that matches the filter.
     * @param {FindUniquequotationArgs} args - Arguments to find a Quotation
     * @example
     * // Get one Quotation
     * const quotation = await prisma.quotation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FindUniquequotationArgs>(
      args: Subset<T, FindUniquequotationArgs>
    ): CheckSelect<T, Prisma__quotationClient<quotation | null>, Prisma__quotationClient<quotationGetPayload<T> | null>>
    /**
     * Find the first Quotation that matches the filter.
     * @param {FindFirstquotationArgs} args - Arguments to find a Quotation
     * @example
     * // Get one Quotation
     * const quotation = await prisma.quotation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FindFirstquotationArgs>(
      args?: Subset<T, FindFirstquotationArgs>
    ): CheckSelect<T, Prisma__quotationClient<quotation | null>, Prisma__quotationClient<quotationGetPayload<T> | null>>
    /**
     * Find zero or more Quotations that matches the filter.
     * @param {FindManyquotationArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Quotations
     * const quotations = await prisma.quotation.findMany()
     * 
     * // Get first 10 Quotations
     * const quotations = await prisma.quotation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quotationWithIdOnly = await prisma.quotation.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FindManyquotationArgs>(
      args?: Subset<T, FindManyquotationArgs>
    ): CheckSelect<T, Promise<Array<quotation>>, Promise<Array<quotationGetPayload<T>>>>
    /**
     * Create a Quotation.
     * @param {quotationCreateArgs} args - Arguments to create a Quotation.
     * @example
     * // Create one Quotation
     * const Quotation = await prisma.quotation.create({
     *   data: {
     *     // ... data to create a Quotation
     *   }
     * })
     * 
    **/
    create<T extends quotationCreateArgs>(
      args: Subset<T, quotationCreateArgs>
    ): CheckSelect<T, Prisma__quotationClient<quotation>, Prisma__quotationClient<quotationGetPayload<T>>>
    /**
     * Delete a Quotation.
     * @param {quotationDeleteArgs} args - Arguments to delete one Quotation.
     * @example
     * // Delete one Quotation
     * const Quotation = await prisma.quotation.delete({
     *   where: {
     *     // ... filter to delete one Quotation
     *   }
     * })
     * 
    **/
    delete<T extends quotationDeleteArgs>(
      args: Subset<T, quotationDeleteArgs>
    ): CheckSelect<T, Prisma__quotationClient<quotation>, Prisma__quotationClient<quotationGetPayload<T>>>
    /**
     * Update one Quotation.
     * @param {quotationUpdateArgs} args - Arguments to update one Quotation.
     * @example
     * // Update one Quotation
     * const quotation = await prisma.quotation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends quotationUpdateArgs>(
      args: Subset<T, quotationUpdateArgs>
    ): CheckSelect<T, Prisma__quotationClient<quotation>, Prisma__quotationClient<quotationGetPayload<T>>>
    /**
     * Delete zero or more Quotations.
     * @param {quotationDeleteManyArgs} args - Arguments to filter Quotations to delete.
     * @example
     * // Delete a few Quotations
     * const { count } = await prisma.quotation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends quotationDeleteManyArgs>(
      args?: Subset<T, quotationDeleteManyArgs>
    ): Promise<BatchPayload>
    /**
     * Update zero or more Quotations.
     * @param {quotationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Quotations
     * const quotation = await prisma.quotation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends quotationUpdateManyArgs>(
      args: Subset<T, quotationUpdateManyArgs>
    ): Promise<BatchPayload>
    /**
     * Create or update one Quotation.
     * @param {quotationUpsertArgs} args - Arguments to update or create a Quotation.
     * @example
     * // Update or create a Quotation
     * const quotation = await prisma.quotation.upsert({
     *   create: {
     *     // ... data to create a Quotation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Quotation we want to update
     *   }
     * })
    **/
    upsert<T extends quotationUpsertArgs>(
      args: Subset<T, quotationUpsertArgs>
    ): CheckSelect<T, Prisma__quotationClient<quotation>, Prisma__quotationClient<quotationGetPayload<T>>>
    /**
     * Find zero or one Quotation that matches the filter.
     * @param {FindUniquequotationArgs} args - Arguments to find a Quotation
     * @deprecated This will be deprecated please use prisma.quotation.findUnique
     * @example
     * // Get one Quotation
     * const quotation = await prisma.quotation.findOne({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findOne<T extends FindUniquequotationArgs>(
      args: Subset<T, FindUniquequotationArgs>
    ): CheckSelect<T, Prisma__quotationClient<quotation | null>, Prisma__quotationClient<quotationGetPayload<T> | null>>
    /**
     * Count
     */
    count(args?: Omit<FindManyquotationArgs, 'select' | 'include'>): Promise<number>

  

    /**
     * Aggregate
     */
    aggregate<T extends AggregateQuotationArgs>(args: Subset<T, AggregateQuotationArgs>): Promise<GetQuotationAggregateType<T>>
  }

  /**
   * The delegate class that acts as a "Promise-like" for quotation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__quotationClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    company<T extends companyArgs = {}>(args?: Subset<T, companyArgs>): CheckSelect<T, Prisma__companyClient<company | null>, Prisma__companyClient<companyGetPayload<T> | null>>;

    quotation_modal_package<T extends quotation_modal_packageArgs = {}>(args?: Subset<T, quotation_modal_packageArgs>): CheckSelect<T, Prisma__quotation_modal_packageClient<quotation_modal_package | null>, Prisma__quotation_modal_packageClient<quotation_modal_packageGetPayload<T> | null>>;

    quotation_checkout<T extends quotation_checkoutArgs = {}>(args?: Subset<T, quotation_checkoutArgs>): CheckSelect<T, Prisma__quotation_checkoutClient<quotation_checkout | null>, Prisma__quotation_checkoutClient<quotation_checkoutGetPayload<T> | null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * quotation findUnique
   */
  export type FindUniquequotationArgs = {
    /**
     * Select specific fields to fetch from the quotation
    **/
    select?: quotationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: quotationInclude | null
    /**
     * Filter, which quotation to fetch.
    **/
    where: quotationWhereUniqueInput
  }


  /**
   * quotation findFirst
   */
  export type FindFirstquotationArgs = {
    /**
     * Select specific fields to fetch from the quotation
    **/
    select?: quotationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: quotationInclude | null
    /**
     * Filter, which quotation to fetch.
    **/
    where?: quotationWhereInput
    orderBy?: Enumerable<quotationOrderByInput>
    cursor?: quotationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<QuotationScalarFieldEnum>
  }


  /**
   * quotation findMany
   */
  export type FindManyquotationArgs = {
    /**
     * Select specific fields to fetch from the quotation
    **/
    select?: quotationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: quotationInclude | null
    /**
     * Filter, which quotations to fetch.
    **/
    where?: quotationWhereInput
    /**
     * Determine the order of the quotations to fetch.
    **/
    orderBy?: Enumerable<quotationOrderByInput>
    /**
     * Sets the position for listing quotations.
    **/
    cursor?: quotationWhereUniqueInput
    /**
     * The number of quotations to fetch. If negative number, it will take quotations before the `cursor`.
    **/
    take?: number
    /**
     * Skip the first `n` quotations.
    **/
    skip?: number
    distinct?: Enumerable<QuotationScalarFieldEnum>
  }


  /**
   * quotation create
   */
  export type quotationCreateArgs = {
    /**
     * Select specific fields to fetch from the quotation
    **/
    select?: quotationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: quotationInclude | null
    /**
     * The data needed to create a quotation.
    **/
    data: quotationCreateInput
  }


  /**
   * quotation update
   */
  export type quotationUpdateArgs = {
    /**
     * Select specific fields to fetch from the quotation
    **/
    select?: quotationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: quotationInclude | null
    /**
     * The data needed to update a quotation.
    **/
    data: quotationUpdateInput
    /**
     * Choose, which quotation to update.
    **/
    where: quotationWhereUniqueInput
  }


  /**
   * quotation updateMany
   */
  export type quotationUpdateManyArgs = {
    data: quotationUpdateManyMutationInput
    where?: quotationWhereInput
  }


  /**
   * quotation upsert
   */
  export type quotationUpsertArgs = {
    /**
     * Select specific fields to fetch from the quotation
    **/
    select?: quotationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: quotationInclude | null
    /**
     * The filter to search for the quotation to update in case it exists.
    **/
    where: quotationWhereUniqueInput
    /**
     * In case the quotation found by the `where` argument doesn't exist, create a new quotation with this data.
    **/
    create: quotationCreateInput
    /**
     * In case the quotation was found with the provided `where` argument, update it with this data.
    **/
    update: quotationUpdateInput
  }


  /**
   * quotation delete
   */
  export type quotationDeleteArgs = {
    /**
     * Select specific fields to fetch from the quotation
    **/
    select?: quotationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: quotationInclude | null
    /**
     * Filter which quotation to delete.
    **/
    where: quotationWhereUniqueInput
  }


  /**
   * quotation deleteMany
   */
  export type quotationDeleteManyArgs = {
    where?: quotationWhereInput
  }


  /**
   * quotation without action
   */
  export type quotationArgs = {
    /**
     * Select specific fields to fetch from the quotation
    **/
    select?: quotationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: quotationInclude | null
  }



  /**
   * Model quotation_checkout
   */


  export type AggregateQuotation_checkout = {
    count: number | null
    avg: Quotation_checkoutAvgAggregateOutputType | null
    sum: Quotation_checkoutSumAggregateOutputType | null
    min: Quotation_checkoutMinAggregateOutputType | null
    max: Quotation_checkoutMaxAggregateOutputType | null
  }

  export type Quotation_checkoutAvgAggregateOutputType = {
    id: number
    selected_price: number
    quotation_id: number
  }

  export type Quotation_checkoutSumAggregateOutputType = {
    id: number
    selected_price: number
    quotation_id: number
  }

  export type Quotation_checkoutMinAggregateOutputType = {
    id: number
    checkout_date: Date | null
    selected_price: number
    quotation_id: number
  }

  export type Quotation_checkoutMaxAggregateOutputType = {
    id: number
    checkout_date: Date | null
    selected_price: number
    quotation_id: number
  }

  export type Quotation_checkoutCountAggregateOutputType = {
    id: number
    checkout_date: number | null
    selected_price: number
    quotation_id: number
    _all: number
  }


  export type Quotation_checkoutAvgAggregateInputType = {
    id?: true
    selected_price?: true
    quotation_id?: true
  }

  export type Quotation_checkoutSumAggregateInputType = {
    id?: true
    selected_price?: true
    quotation_id?: true
  }

  export type Quotation_checkoutMinAggregateInputType = {
    id?: true
    checkout_date?: true
    selected_price?: true
    quotation_id?: true
  }

  export type Quotation_checkoutMaxAggregateInputType = {
    id?: true
    checkout_date?: true
    selected_price?: true
    quotation_id?: true
  }

  export type Quotation_checkoutCountAggregateInputType = {
    id?: true
    checkout_date?: true
    selected_price?: true
    quotation_id?: true
    _all?: true
  }

  export type AggregateQuotation_checkoutArgs = {
    where?: quotation_checkoutWhereInput
    orderBy?: Enumerable<quotation_checkoutOrderByInput>
    cursor?: quotation_checkoutWhereUniqueInput
    take?: number
    skip?: number
    count?: true
    avg?: Quotation_checkoutAvgAggregateInputType
    sum?: Quotation_checkoutSumAggregateInputType
    min?: Quotation_checkoutMinAggregateInputType
    max?: Quotation_checkoutMaxAggregateInputType
  }

  export type GetQuotation_checkoutAggregateType<T extends AggregateQuotation_checkoutArgs> = {
    [P in keyof T]: P extends 'count' ? number : GetQuotation_checkoutAggregateScalarType<T[P]>
  }

  export type GetQuotation_checkoutAggregateScalarType<T extends any> = {
    [P in keyof T]: P extends keyof Quotation_checkoutAvgAggregateOutputType ? Quotation_checkoutAvgAggregateOutputType[P] : never
  }

    



  export type quotation_checkoutSelect = {
    id?: boolean
    checkout_date?: boolean
    selected_price?: boolean
    quotation_id?: boolean
    quotation?: boolean | quotationArgs
  }

  export type quotation_checkoutInclude = {
    quotation?: boolean | quotationArgs
  }

  export type quotation_checkoutGetPayload<
    S extends boolean | null | undefined | quotation_checkoutArgs,
    U = keyof S
      > = S extends true
        ? quotation_checkout
    : S extends undefined
    ? never
    : S extends quotation_checkoutArgs | FindManyquotation_checkoutArgs
    ?'include' extends U
    ? quotation_checkout  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'quotation'
        ? quotationGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof quotation_checkout ?quotation_checkout [P]
  : 
          P extends 'quotation'
        ? quotationGetPayload<S['select'][P]> : never
  } 
    : quotation_checkout
  : quotation_checkout


  export interface quotation_checkoutDelegate {
    /**
     * Find zero or one Quotation_checkout that matches the filter.
     * @param {FindUniquequotation_checkoutArgs} args - Arguments to find a Quotation_checkout
     * @example
     * // Get one Quotation_checkout
     * const quotation_checkout = await prisma.quotation_checkout.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FindUniquequotation_checkoutArgs>(
      args: Subset<T, FindUniquequotation_checkoutArgs>
    ): CheckSelect<T, Prisma__quotation_checkoutClient<quotation_checkout | null>, Prisma__quotation_checkoutClient<quotation_checkoutGetPayload<T> | null>>
    /**
     * Find the first Quotation_checkout that matches the filter.
     * @param {FindFirstquotation_checkoutArgs} args - Arguments to find a Quotation_checkout
     * @example
     * // Get one Quotation_checkout
     * const quotation_checkout = await prisma.quotation_checkout.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FindFirstquotation_checkoutArgs>(
      args?: Subset<T, FindFirstquotation_checkoutArgs>
    ): CheckSelect<T, Prisma__quotation_checkoutClient<quotation_checkout | null>, Prisma__quotation_checkoutClient<quotation_checkoutGetPayload<T> | null>>
    /**
     * Find zero or more Quotation_checkouts that matches the filter.
     * @param {FindManyquotation_checkoutArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Quotation_checkouts
     * const quotation_checkouts = await prisma.quotation_checkout.findMany()
     * 
     * // Get first 10 Quotation_checkouts
     * const quotation_checkouts = await prisma.quotation_checkout.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quotation_checkoutWithIdOnly = await prisma.quotation_checkout.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FindManyquotation_checkoutArgs>(
      args?: Subset<T, FindManyquotation_checkoutArgs>
    ): CheckSelect<T, Promise<Array<quotation_checkout>>, Promise<Array<quotation_checkoutGetPayload<T>>>>
    /**
     * Create a Quotation_checkout.
     * @param {quotation_checkoutCreateArgs} args - Arguments to create a Quotation_checkout.
     * @example
     * // Create one Quotation_checkout
     * const Quotation_checkout = await prisma.quotation_checkout.create({
     *   data: {
     *     // ... data to create a Quotation_checkout
     *   }
     * })
     * 
    **/
    create<T extends quotation_checkoutCreateArgs>(
      args: Subset<T, quotation_checkoutCreateArgs>
    ): CheckSelect<T, Prisma__quotation_checkoutClient<quotation_checkout>, Prisma__quotation_checkoutClient<quotation_checkoutGetPayload<T>>>
    /**
     * Delete a Quotation_checkout.
     * @param {quotation_checkoutDeleteArgs} args - Arguments to delete one Quotation_checkout.
     * @example
     * // Delete one Quotation_checkout
     * const Quotation_checkout = await prisma.quotation_checkout.delete({
     *   where: {
     *     // ... filter to delete one Quotation_checkout
     *   }
     * })
     * 
    **/
    delete<T extends quotation_checkoutDeleteArgs>(
      args: Subset<T, quotation_checkoutDeleteArgs>
    ): CheckSelect<T, Prisma__quotation_checkoutClient<quotation_checkout>, Prisma__quotation_checkoutClient<quotation_checkoutGetPayload<T>>>
    /**
     * Update one Quotation_checkout.
     * @param {quotation_checkoutUpdateArgs} args - Arguments to update one Quotation_checkout.
     * @example
     * // Update one Quotation_checkout
     * const quotation_checkout = await prisma.quotation_checkout.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends quotation_checkoutUpdateArgs>(
      args: Subset<T, quotation_checkoutUpdateArgs>
    ): CheckSelect<T, Prisma__quotation_checkoutClient<quotation_checkout>, Prisma__quotation_checkoutClient<quotation_checkoutGetPayload<T>>>
    /**
     * Delete zero or more Quotation_checkouts.
     * @param {quotation_checkoutDeleteManyArgs} args - Arguments to filter Quotation_checkouts to delete.
     * @example
     * // Delete a few Quotation_checkouts
     * const { count } = await prisma.quotation_checkout.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends quotation_checkoutDeleteManyArgs>(
      args?: Subset<T, quotation_checkoutDeleteManyArgs>
    ): Promise<BatchPayload>
    /**
     * Update zero or more Quotation_checkouts.
     * @param {quotation_checkoutUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Quotation_checkouts
     * const quotation_checkout = await prisma.quotation_checkout.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends quotation_checkoutUpdateManyArgs>(
      args: Subset<T, quotation_checkoutUpdateManyArgs>
    ): Promise<BatchPayload>
    /**
     * Create or update one Quotation_checkout.
     * @param {quotation_checkoutUpsertArgs} args - Arguments to update or create a Quotation_checkout.
     * @example
     * // Update or create a Quotation_checkout
     * const quotation_checkout = await prisma.quotation_checkout.upsert({
     *   create: {
     *     // ... data to create a Quotation_checkout
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Quotation_checkout we want to update
     *   }
     * })
    **/
    upsert<T extends quotation_checkoutUpsertArgs>(
      args: Subset<T, quotation_checkoutUpsertArgs>
    ): CheckSelect<T, Prisma__quotation_checkoutClient<quotation_checkout>, Prisma__quotation_checkoutClient<quotation_checkoutGetPayload<T>>>
    /**
     * Find zero or one Quotation_checkout that matches the filter.
     * @param {FindUniquequotation_checkoutArgs} args - Arguments to find a Quotation_checkout
     * @deprecated This will be deprecated please use prisma.quotation_checkout.findUnique
     * @example
     * // Get one Quotation_checkout
     * const quotation_checkout = await prisma.quotation_checkout.findOne({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findOne<T extends FindUniquequotation_checkoutArgs>(
      args: Subset<T, FindUniquequotation_checkoutArgs>
    ): CheckSelect<T, Prisma__quotation_checkoutClient<quotation_checkout | null>, Prisma__quotation_checkoutClient<quotation_checkoutGetPayload<T> | null>>
    /**
     * Count
     */
    count(args?: Omit<FindManyquotation_checkoutArgs, 'select' | 'include'>): Promise<number>

  

    /**
     * Aggregate
     */
    aggregate<T extends AggregateQuotation_checkoutArgs>(args: Subset<T, AggregateQuotation_checkoutArgs>): Promise<GetQuotation_checkoutAggregateType<T>>
  }

  /**
   * The delegate class that acts as a "Promise-like" for quotation_checkout.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__quotation_checkoutClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    quotation<T extends quotationArgs = {}>(args?: Subset<T, quotationArgs>): CheckSelect<T, Prisma__quotationClient<quotation | null>, Prisma__quotationClient<quotationGetPayload<T> | null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * quotation_checkout findUnique
   */
  export type FindUniquequotation_checkoutArgs = {
    /**
     * Select specific fields to fetch from the quotation_checkout
    **/
    select?: quotation_checkoutSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: quotation_checkoutInclude | null
    /**
     * Filter, which quotation_checkout to fetch.
    **/
    where: quotation_checkoutWhereUniqueInput
  }


  /**
   * quotation_checkout findFirst
   */
  export type FindFirstquotation_checkoutArgs = {
    /**
     * Select specific fields to fetch from the quotation_checkout
    **/
    select?: quotation_checkoutSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: quotation_checkoutInclude | null
    /**
     * Filter, which quotation_checkout to fetch.
    **/
    where?: quotation_checkoutWhereInput
    orderBy?: Enumerable<quotation_checkoutOrderByInput>
    cursor?: quotation_checkoutWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Quotation_checkoutScalarFieldEnum>
  }


  /**
   * quotation_checkout findMany
   */
  export type FindManyquotation_checkoutArgs = {
    /**
     * Select specific fields to fetch from the quotation_checkout
    **/
    select?: quotation_checkoutSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: quotation_checkoutInclude | null
    /**
     * Filter, which quotation_checkouts to fetch.
    **/
    where?: quotation_checkoutWhereInput
    /**
     * Determine the order of the quotation_checkouts to fetch.
    **/
    orderBy?: Enumerable<quotation_checkoutOrderByInput>
    /**
     * Sets the position for listing quotation_checkouts.
    **/
    cursor?: quotation_checkoutWhereUniqueInput
    /**
     * The number of quotation_checkouts to fetch. If negative number, it will take quotation_checkouts before the `cursor`.
    **/
    take?: number
    /**
     * Skip the first `n` quotation_checkouts.
    **/
    skip?: number
    distinct?: Enumerable<Quotation_checkoutScalarFieldEnum>
  }


  /**
   * quotation_checkout create
   */
  export type quotation_checkoutCreateArgs = {
    /**
     * Select specific fields to fetch from the quotation_checkout
    **/
    select?: quotation_checkoutSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: quotation_checkoutInclude | null
    /**
     * The data needed to create a quotation_checkout.
    **/
    data: quotation_checkoutCreateInput
  }


  /**
   * quotation_checkout update
   */
  export type quotation_checkoutUpdateArgs = {
    /**
     * Select specific fields to fetch from the quotation_checkout
    **/
    select?: quotation_checkoutSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: quotation_checkoutInclude | null
    /**
     * The data needed to update a quotation_checkout.
    **/
    data: quotation_checkoutUpdateInput
    /**
     * Choose, which quotation_checkout to update.
    **/
    where: quotation_checkoutWhereUniqueInput
  }


  /**
   * quotation_checkout updateMany
   */
  export type quotation_checkoutUpdateManyArgs = {
    data: quotation_checkoutUpdateManyMutationInput
    where?: quotation_checkoutWhereInput
  }


  /**
   * quotation_checkout upsert
   */
  export type quotation_checkoutUpsertArgs = {
    /**
     * Select specific fields to fetch from the quotation_checkout
    **/
    select?: quotation_checkoutSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: quotation_checkoutInclude | null
    /**
     * The filter to search for the quotation_checkout to update in case it exists.
    **/
    where: quotation_checkoutWhereUniqueInput
    /**
     * In case the quotation_checkout found by the `where` argument doesn't exist, create a new quotation_checkout with this data.
    **/
    create: quotation_checkoutCreateInput
    /**
     * In case the quotation_checkout was found with the provided `where` argument, update it with this data.
    **/
    update: quotation_checkoutUpdateInput
  }


  /**
   * quotation_checkout delete
   */
  export type quotation_checkoutDeleteArgs = {
    /**
     * Select specific fields to fetch from the quotation_checkout
    **/
    select?: quotation_checkoutSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: quotation_checkoutInclude | null
    /**
     * Filter which quotation_checkout to delete.
    **/
    where: quotation_checkoutWhereUniqueInput
  }


  /**
   * quotation_checkout deleteMany
   */
  export type quotation_checkoutDeleteManyArgs = {
    where?: quotation_checkoutWhereInput
  }


  /**
   * quotation_checkout without action
   */
  export type quotation_checkoutArgs = {
    /**
     * Select specific fields to fetch from the quotation_checkout
    **/
    select?: quotation_checkoutSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: quotation_checkoutInclude | null
  }



  /**
   * Model quotation_modal_package
   */


  export type AggregateQuotation_modal_package = {
    count: number | null
    avg: Quotation_modal_packageAvgAggregateOutputType | null
    sum: Quotation_modal_packageSumAggregateOutputType | null
    min: Quotation_modal_packageMinAggregateOutputType | null
    max: Quotation_modal_packageMaxAggregateOutputType | null
  }

  export type Quotation_modal_packageAvgAggregateOutputType = {
    id: number
    pulverization_method: number
    quotation_package_id: number
  }

  export type Quotation_modal_packageSumAggregateOutputType = {
    id: number
    pulverization_method: number
    quotation_package_id: number
  }

  export type Quotation_modal_packageMinAggregateOutputType = {
    id: number
    pulverization_method: number
    quotation_package_id: number
  }

  export type Quotation_modal_packageMaxAggregateOutputType = {
    id: number
    pulverization_method: number
    quotation_package_id: number
  }

  export type Quotation_modal_packageCountAggregateOutputType = {
    id: number
    pulverization_method: number
    quotation_package_id: number
    _all: number
  }


  export type Quotation_modal_packageAvgAggregateInputType = {
    id?: true
    pulverization_method?: true
    quotation_package_id?: true
  }

  export type Quotation_modal_packageSumAggregateInputType = {
    id?: true
    pulverization_method?: true
    quotation_package_id?: true
  }

  export type Quotation_modal_packageMinAggregateInputType = {
    id?: true
    pulverization_method?: true
    quotation_package_id?: true
  }

  export type Quotation_modal_packageMaxAggregateInputType = {
    id?: true
    pulverization_method?: true
    quotation_package_id?: true
  }

  export type Quotation_modal_packageCountAggregateInputType = {
    id?: true
    pulverization_method?: true
    quotation_package_id?: true
    _all?: true
  }

  export type AggregateQuotation_modal_packageArgs = {
    where?: quotation_modal_packageWhereInput
    orderBy?: Enumerable<quotation_modal_packageOrderByInput>
    cursor?: quotation_modal_packageWhereUniqueInput
    take?: number
    skip?: number
    count?: true
    avg?: Quotation_modal_packageAvgAggregateInputType
    sum?: Quotation_modal_packageSumAggregateInputType
    min?: Quotation_modal_packageMinAggregateInputType
    max?: Quotation_modal_packageMaxAggregateInputType
  }

  export type GetQuotation_modal_packageAggregateType<T extends AggregateQuotation_modal_packageArgs> = {
    [P in keyof T]: P extends 'count' ? number : GetQuotation_modal_packageAggregateScalarType<T[P]>
  }

  export type GetQuotation_modal_packageAggregateScalarType<T extends any> = {
    [P in keyof T]: P extends keyof Quotation_modal_packageAvgAggregateOutputType ? Quotation_modal_packageAvgAggregateOutputType[P] : never
  }

    



  export type quotation_modal_packageSelect = {
    id?: boolean
    pulverization_method?: boolean
    quotation_package_id?: boolean
    quotation_package?: boolean | quotation_packageArgs
    many_quotation_modal_package_has_many_field?: boolean | FindManymany_quotation_modal_package_has_many_fieldArgs
    quotation?: boolean | FindManyquotationArgs
  }

  export type quotation_modal_packageInclude = {
    quotation_package?: boolean | quotation_packageArgs
    many_quotation_modal_package_has_many_field?: boolean | FindManymany_quotation_modal_package_has_many_fieldArgs
    quotation?: boolean | FindManyquotationArgs
  }

  export type quotation_modal_packageGetPayload<
    S extends boolean | null | undefined | quotation_modal_packageArgs,
    U = keyof S
      > = S extends true
        ? quotation_modal_package
    : S extends undefined
    ? never
    : S extends quotation_modal_packageArgs | FindManyquotation_modal_packageArgs
    ?'include' extends U
    ? quotation_modal_package  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'quotation_package'
        ? quotation_packageGetPayload<S['include'][P]> :
        P extends 'many_quotation_modal_package_has_many_field'
        ? Array < many_quotation_modal_package_has_many_fieldGetPayload<S['include'][P]>>  :
        P extends 'quotation'
        ? Array < quotationGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof quotation_modal_package ?quotation_modal_package [P]
  : 
          P extends 'quotation_package'
        ? quotation_packageGetPayload<S['select'][P]> :
        P extends 'many_quotation_modal_package_has_many_field'
        ? Array < many_quotation_modal_package_has_many_fieldGetPayload<S['select'][P]>>  :
        P extends 'quotation'
        ? Array < quotationGetPayload<S['select'][P]>>  : never
  } 
    : quotation_modal_package
  : quotation_modal_package


  export interface quotation_modal_packageDelegate {
    /**
     * Find zero or one Quotation_modal_package that matches the filter.
     * @param {FindUniquequotation_modal_packageArgs} args - Arguments to find a Quotation_modal_package
     * @example
     * // Get one Quotation_modal_package
     * const quotation_modal_package = await prisma.quotation_modal_package.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FindUniquequotation_modal_packageArgs>(
      args: Subset<T, FindUniquequotation_modal_packageArgs>
    ): CheckSelect<T, Prisma__quotation_modal_packageClient<quotation_modal_package | null>, Prisma__quotation_modal_packageClient<quotation_modal_packageGetPayload<T> | null>>
    /**
     * Find the first Quotation_modal_package that matches the filter.
     * @param {FindFirstquotation_modal_packageArgs} args - Arguments to find a Quotation_modal_package
     * @example
     * // Get one Quotation_modal_package
     * const quotation_modal_package = await prisma.quotation_modal_package.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FindFirstquotation_modal_packageArgs>(
      args?: Subset<T, FindFirstquotation_modal_packageArgs>
    ): CheckSelect<T, Prisma__quotation_modal_packageClient<quotation_modal_package | null>, Prisma__quotation_modal_packageClient<quotation_modal_packageGetPayload<T> | null>>
    /**
     * Find zero or more Quotation_modal_packages that matches the filter.
     * @param {FindManyquotation_modal_packageArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Quotation_modal_packages
     * const quotation_modal_packages = await prisma.quotation_modal_package.findMany()
     * 
     * // Get first 10 Quotation_modal_packages
     * const quotation_modal_packages = await prisma.quotation_modal_package.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quotation_modal_packageWithIdOnly = await prisma.quotation_modal_package.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FindManyquotation_modal_packageArgs>(
      args?: Subset<T, FindManyquotation_modal_packageArgs>
    ): CheckSelect<T, Promise<Array<quotation_modal_package>>, Promise<Array<quotation_modal_packageGetPayload<T>>>>
    /**
     * Create a Quotation_modal_package.
     * @param {quotation_modal_packageCreateArgs} args - Arguments to create a Quotation_modal_package.
     * @example
     * // Create one Quotation_modal_package
     * const Quotation_modal_package = await prisma.quotation_modal_package.create({
     *   data: {
     *     // ... data to create a Quotation_modal_package
     *   }
     * })
     * 
    **/
    create<T extends quotation_modal_packageCreateArgs>(
      args: Subset<T, quotation_modal_packageCreateArgs>
    ): CheckSelect<T, Prisma__quotation_modal_packageClient<quotation_modal_package>, Prisma__quotation_modal_packageClient<quotation_modal_packageGetPayload<T>>>
    /**
     * Delete a Quotation_modal_package.
     * @param {quotation_modal_packageDeleteArgs} args - Arguments to delete one Quotation_modal_package.
     * @example
     * // Delete one Quotation_modal_package
     * const Quotation_modal_package = await prisma.quotation_modal_package.delete({
     *   where: {
     *     // ... filter to delete one Quotation_modal_package
     *   }
     * })
     * 
    **/
    delete<T extends quotation_modal_packageDeleteArgs>(
      args: Subset<T, quotation_modal_packageDeleteArgs>
    ): CheckSelect<T, Prisma__quotation_modal_packageClient<quotation_modal_package>, Prisma__quotation_modal_packageClient<quotation_modal_packageGetPayload<T>>>
    /**
     * Update one Quotation_modal_package.
     * @param {quotation_modal_packageUpdateArgs} args - Arguments to update one Quotation_modal_package.
     * @example
     * // Update one Quotation_modal_package
     * const quotation_modal_package = await prisma.quotation_modal_package.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends quotation_modal_packageUpdateArgs>(
      args: Subset<T, quotation_modal_packageUpdateArgs>
    ): CheckSelect<T, Prisma__quotation_modal_packageClient<quotation_modal_package>, Prisma__quotation_modal_packageClient<quotation_modal_packageGetPayload<T>>>
    /**
     * Delete zero or more Quotation_modal_packages.
     * @param {quotation_modal_packageDeleteManyArgs} args - Arguments to filter Quotation_modal_packages to delete.
     * @example
     * // Delete a few Quotation_modal_packages
     * const { count } = await prisma.quotation_modal_package.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends quotation_modal_packageDeleteManyArgs>(
      args?: Subset<T, quotation_modal_packageDeleteManyArgs>
    ): Promise<BatchPayload>
    /**
     * Update zero or more Quotation_modal_packages.
     * @param {quotation_modal_packageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Quotation_modal_packages
     * const quotation_modal_package = await prisma.quotation_modal_package.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends quotation_modal_packageUpdateManyArgs>(
      args: Subset<T, quotation_modal_packageUpdateManyArgs>
    ): Promise<BatchPayload>
    /**
     * Create or update one Quotation_modal_package.
     * @param {quotation_modal_packageUpsertArgs} args - Arguments to update or create a Quotation_modal_package.
     * @example
     * // Update or create a Quotation_modal_package
     * const quotation_modal_package = await prisma.quotation_modal_package.upsert({
     *   create: {
     *     // ... data to create a Quotation_modal_package
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Quotation_modal_package we want to update
     *   }
     * })
    **/
    upsert<T extends quotation_modal_packageUpsertArgs>(
      args: Subset<T, quotation_modal_packageUpsertArgs>
    ): CheckSelect<T, Prisma__quotation_modal_packageClient<quotation_modal_package>, Prisma__quotation_modal_packageClient<quotation_modal_packageGetPayload<T>>>
    /**
     * Find zero or one Quotation_modal_package that matches the filter.
     * @param {FindUniquequotation_modal_packageArgs} args - Arguments to find a Quotation_modal_package
     * @deprecated This will be deprecated please use prisma.quotation_modal_package.findUnique
     * @example
     * // Get one Quotation_modal_package
     * const quotation_modal_package = await prisma.quotation_modal_package.findOne({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findOne<T extends FindUniquequotation_modal_packageArgs>(
      args: Subset<T, FindUniquequotation_modal_packageArgs>
    ): CheckSelect<T, Prisma__quotation_modal_packageClient<quotation_modal_package | null>, Prisma__quotation_modal_packageClient<quotation_modal_packageGetPayload<T> | null>>
    /**
     * Count
     */
    count(args?: Omit<FindManyquotation_modal_packageArgs, 'select' | 'include'>): Promise<number>

  

    /**
     * Aggregate
     */
    aggregate<T extends AggregateQuotation_modal_packageArgs>(args: Subset<T, AggregateQuotation_modal_packageArgs>): Promise<GetQuotation_modal_packageAggregateType<T>>
  }

  /**
   * The delegate class that acts as a "Promise-like" for quotation_modal_package.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__quotation_modal_packageClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    quotation_package<T extends quotation_packageArgs = {}>(args?: Subset<T, quotation_packageArgs>): CheckSelect<T, Prisma__quotation_packageClient<quotation_package | null>, Prisma__quotation_packageClient<quotation_packageGetPayload<T> | null>>;

    many_quotation_modal_package_has_many_field<T extends FindManymany_quotation_modal_package_has_many_fieldArgs = {}>(args?: Subset<T, FindManymany_quotation_modal_package_has_many_fieldArgs>): CheckSelect<T, Promise<Array<many_quotation_modal_package_has_many_field>>, Promise<Array<many_quotation_modal_package_has_many_fieldGetPayload<T>>>>;

    quotation<T extends FindManyquotationArgs = {}>(args?: Subset<T, FindManyquotationArgs>): CheckSelect<T, Promise<Array<quotation>>, Promise<Array<quotationGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * quotation_modal_package findUnique
   */
  export type FindUniquequotation_modal_packageArgs = {
    /**
     * Select specific fields to fetch from the quotation_modal_package
    **/
    select?: quotation_modal_packageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: quotation_modal_packageInclude | null
    /**
     * Filter, which quotation_modal_package to fetch.
    **/
    where: quotation_modal_packageWhereUniqueInput
  }


  /**
   * quotation_modal_package findFirst
   */
  export type FindFirstquotation_modal_packageArgs = {
    /**
     * Select specific fields to fetch from the quotation_modal_package
    **/
    select?: quotation_modal_packageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: quotation_modal_packageInclude | null
    /**
     * Filter, which quotation_modal_package to fetch.
    **/
    where?: quotation_modal_packageWhereInput
    orderBy?: Enumerable<quotation_modal_packageOrderByInput>
    cursor?: quotation_modal_packageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Quotation_modal_packageScalarFieldEnum>
  }


  /**
   * quotation_modal_package findMany
   */
  export type FindManyquotation_modal_packageArgs = {
    /**
     * Select specific fields to fetch from the quotation_modal_package
    **/
    select?: quotation_modal_packageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: quotation_modal_packageInclude | null
    /**
     * Filter, which quotation_modal_packages to fetch.
    **/
    where?: quotation_modal_packageWhereInput
    /**
     * Determine the order of the quotation_modal_packages to fetch.
    **/
    orderBy?: Enumerable<quotation_modal_packageOrderByInput>
    /**
     * Sets the position for listing quotation_modal_packages.
    **/
    cursor?: quotation_modal_packageWhereUniqueInput
    /**
     * The number of quotation_modal_packages to fetch. If negative number, it will take quotation_modal_packages before the `cursor`.
    **/
    take?: number
    /**
     * Skip the first `n` quotation_modal_packages.
    **/
    skip?: number
    distinct?: Enumerable<Quotation_modal_packageScalarFieldEnum>
  }


  /**
   * quotation_modal_package create
   */
  export type quotation_modal_packageCreateArgs = {
    /**
     * Select specific fields to fetch from the quotation_modal_package
    **/
    select?: quotation_modal_packageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: quotation_modal_packageInclude | null
    /**
     * The data needed to create a quotation_modal_package.
    **/
    data: quotation_modal_packageCreateInput
  }


  /**
   * quotation_modal_package update
   */
  export type quotation_modal_packageUpdateArgs = {
    /**
     * Select specific fields to fetch from the quotation_modal_package
    **/
    select?: quotation_modal_packageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: quotation_modal_packageInclude | null
    /**
     * The data needed to update a quotation_modal_package.
    **/
    data: quotation_modal_packageUpdateInput
    /**
     * Choose, which quotation_modal_package to update.
    **/
    where: quotation_modal_packageWhereUniqueInput
  }


  /**
   * quotation_modal_package updateMany
   */
  export type quotation_modal_packageUpdateManyArgs = {
    data: quotation_modal_packageUpdateManyMutationInput
    where?: quotation_modal_packageWhereInput
  }


  /**
   * quotation_modal_package upsert
   */
  export type quotation_modal_packageUpsertArgs = {
    /**
     * Select specific fields to fetch from the quotation_modal_package
    **/
    select?: quotation_modal_packageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: quotation_modal_packageInclude | null
    /**
     * The filter to search for the quotation_modal_package to update in case it exists.
    **/
    where: quotation_modal_packageWhereUniqueInput
    /**
     * In case the quotation_modal_package found by the `where` argument doesn't exist, create a new quotation_modal_package with this data.
    **/
    create: quotation_modal_packageCreateInput
    /**
     * In case the quotation_modal_package was found with the provided `where` argument, update it with this data.
    **/
    update: quotation_modal_packageUpdateInput
  }


  /**
   * quotation_modal_package delete
   */
  export type quotation_modal_packageDeleteArgs = {
    /**
     * Select specific fields to fetch from the quotation_modal_package
    **/
    select?: quotation_modal_packageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: quotation_modal_packageInclude | null
    /**
     * Filter which quotation_modal_package to delete.
    **/
    where: quotation_modal_packageWhereUniqueInput
  }


  /**
   * quotation_modal_package deleteMany
   */
  export type quotation_modal_packageDeleteManyArgs = {
    where?: quotation_modal_packageWhereInput
  }


  /**
   * quotation_modal_package without action
   */
  export type quotation_modal_packageArgs = {
    /**
     * Select specific fields to fetch from the quotation_modal_package
    **/
    select?: quotation_modal_packageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: quotation_modal_packageInclude | null
  }



  /**
   * Model quotation_package
   */


  export type AggregateQuotation_package = {
    count: number | null
    avg: Quotation_packageAvgAggregateOutputType | null
    sum: Quotation_packageSumAggregateOutputType | null
    min: Quotation_packageMinAggregateOutputType | null
    max: Quotation_packageMaxAggregateOutputType | null
  }

  export type Quotation_packageAvgAggregateOutputType = {
    id: number
    code: number
  }

  export type Quotation_packageSumAggregateOutputType = {
    id: number
    code: number
  }

  export type Quotation_packageMinAggregateOutputType = {
    id: number
    code: number
    request_date: Date | null
    pulverization_start_date: Date | null
    pulverization_end_date: Date | null
  }

  export type Quotation_packageMaxAggregateOutputType = {
    id: number
    code: number
    request_date: Date | null
    pulverization_start_date: Date | null
    pulverization_end_date: Date | null
  }

  export type Quotation_packageCountAggregateOutputType = {
    id: number
    code: number
    request_date: number | null
    pulverization_start_date: number | null
    pulverization_end_date: number | null
    _all: number
  }


  export type Quotation_packageAvgAggregateInputType = {
    id?: true
    code?: true
  }

  export type Quotation_packageSumAggregateInputType = {
    id?: true
    code?: true
  }

  export type Quotation_packageMinAggregateInputType = {
    id?: true
    code?: true
    request_date?: true
    pulverization_start_date?: true
    pulverization_end_date?: true
  }

  export type Quotation_packageMaxAggregateInputType = {
    id?: true
    code?: true
    request_date?: true
    pulverization_start_date?: true
    pulverization_end_date?: true
  }

  export type Quotation_packageCountAggregateInputType = {
    id?: true
    code?: true
    request_date?: true
    pulverization_start_date?: true
    pulverization_end_date?: true
    _all?: true
  }

  export type AggregateQuotation_packageArgs = {
    where?: quotation_packageWhereInput
    orderBy?: Enumerable<quotation_packageOrderByInput>
    cursor?: quotation_packageWhereUniqueInput
    take?: number
    skip?: number
    count?: true
    avg?: Quotation_packageAvgAggregateInputType
    sum?: Quotation_packageSumAggregateInputType
    min?: Quotation_packageMinAggregateInputType
    max?: Quotation_packageMaxAggregateInputType
  }

  export type GetQuotation_packageAggregateType<T extends AggregateQuotation_packageArgs> = {
    [P in keyof T]: P extends 'count' ? number : GetQuotation_packageAggregateScalarType<T[P]>
  }

  export type GetQuotation_packageAggregateScalarType<T extends any> = {
    [P in keyof T]: P extends keyof Quotation_packageAvgAggregateOutputType ? Quotation_packageAvgAggregateOutputType[P] : never
  }

    



  export type quotation_packageSelect = {
    id?: boolean
    code?: boolean
    request_date?: boolean
    pulverization_start_date?: boolean
    pulverization_end_date?: boolean
    quotation_modal_package?: boolean | FindManyquotation_modal_packageArgs
  }

  export type quotation_packageInclude = {
    quotation_modal_package?: boolean | FindManyquotation_modal_packageArgs
  }

  export type quotation_packageGetPayload<
    S extends boolean | null | undefined | quotation_packageArgs,
    U = keyof S
      > = S extends true
        ? quotation_package
    : S extends undefined
    ? never
    : S extends quotation_packageArgs | FindManyquotation_packageArgs
    ?'include' extends U
    ? quotation_package  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'quotation_modal_package'
        ? Array < quotation_modal_packageGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof quotation_package ?quotation_package [P]
  : 
          P extends 'quotation_modal_package'
        ? Array < quotation_modal_packageGetPayload<S['select'][P]>>  : never
  } 
    : quotation_package
  : quotation_package


  export interface quotation_packageDelegate {
    /**
     * Find zero or one Quotation_package that matches the filter.
     * @param {FindUniquequotation_packageArgs} args - Arguments to find a Quotation_package
     * @example
     * // Get one Quotation_package
     * const quotation_package = await prisma.quotation_package.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FindUniquequotation_packageArgs>(
      args: Subset<T, FindUniquequotation_packageArgs>
    ): CheckSelect<T, Prisma__quotation_packageClient<quotation_package | null>, Prisma__quotation_packageClient<quotation_packageGetPayload<T> | null>>
    /**
     * Find the first Quotation_package that matches the filter.
     * @param {FindFirstquotation_packageArgs} args - Arguments to find a Quotation_package
     * @example
     * // Get one Quotation_package
     * const quotation_package = await prisma.quotation_package.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FindFirstquotation_packageArgs>(
      args?: Subset<T, FindFirstquotation_packageArgs>
    ): CheckSelect<T, Prisma__quotation_packageClient<quotation_package | null>, Prisma__quotation_packageClient<quotation_packageGetPayload<T> | null>>
    /**
     * Find zero or more Quotation_packages that matches the filter.
     * @param {FindManyquotation_packageArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Quotation_packages
     * const quotation_packages = await prisma.quotation_package.findMany()
     * 
     * // Get first 10 Quotation_packages
     * const quotation_packages = await prisma.quotation_package.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quotation_packageWithIdOnly = await prisma.quotation_package.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FindManyquotation_packageArgs>(
      args?: Subset<T, FindManyquotation_packageArgs>
    ): CheckSelect<T, Promise<Array<quotation_package>>, Promise<Array<quotation_packageGetPayload<T>>>>
    /**
     * Create a Quotation_package.
     * @param {quotation_packageCreateArgs} args - Arguments to create a Quotation_package.
     * @example
     * // Create one Quotation_package
     * const Quotation_package = await prisma.quotation_package.create({
     *   data: {
     *     // ... data to create a Quotation_package
     *   }
     * })
     * 
    **/
    create<T extends quotation_packageCreateArgs>(
      args: Subset<T, quotation_packageCreateArgs>
    ): CheckSelect<T, Prisma__quotation_packageClient<quotation_package>, Prisma__quotation_packageClient<quotation_packageGetPayload<T>>>
    /**
     * Delete a Quotation_package.
     * @param {quotation_packageDeleteArgs} args - Arguments to delete one Quotation_package.
     * @example
     * // Delete one Quotation_package
     * const Quotation_package = await prisma.quotation_package.delete({
     *   where: {
     *     // ... filter to delete one Quotation_package
     *   }
     * })
     * 
    **/
    delete<T extends quotation_packageDeleteArgs>(
      args: Subset<T, quotation_packageDeleteArgs>
    ): CheckSelect<T, Prisma__quotation_packageClient<quotation_package>, Prisma__quotation_packageClient<quotation_packageGetPayload<T>>>
    /**
     * Update one Quotation_package.
     * @param {quotation_packageUpdateArgs} args - Arguments to update one Quotation_package.
     * @example
     * // Update one Quotation_package
     * const quotation_package = await prisma.quotation_package.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends quotation_packageUpdateArgs>(
      args: Subset<T, quotation_packageUpdateArgs>
    ): CheckSelect<T, Prisma__quotation_packageClient<quotation_package>, Prisma__quotation_packageClient<quotation_packageGetPayload<T>>>
    /**
     * Delete zero or more Quotation_packages.
     * @param {quotation_packageDeleteManyArgs} args - Arguments to filter Quotation_packages to delete.
     * @example
     * // Delete a few Quotation_packages
     * const { count } = await prisma.quotation_package.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends quotation_packageDeleteManyArgs>(
      args?: Subset<T, quotation_packageDeleteManyArgs>
    ): Promise<BatchPayload>
    /**
     * Update zero or more Quotation_packages.
     * @param {quotation_packageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Quotation_packages
     * const quotation_package = await prisma.quotation_package.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends quotation_packageUpdateManyArgs>(
      args: Subset<T, quotation_packageUpdateManyArgs>
    ): Promise<BatchPayload>
    /**
     * Create or update one Quotation_package.
     * @param {quotation_packageUpsertArgs} args - Arguments to update or create a Quotation_package.
     * @example
     * // Update or create a Quotation_package
     * const quotation_package = await prisma.quotation_package.upsert({
     *   create: {
     *     // ... data to create a Quotation_package
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Quotation_package we want to update
     *   }
     * })
    **/
    upsert<T extends quotation_packageUpsertArgs>(
      args: Subset<T, quotation_packageUpsertArgs>
    ): CheckSelect<T, Prisma__quotation_packageClient<quotation_package>, Prisma__quotation_packageClient<quotation_packageGetPayload<T>>>
    /**
     * Find zero or one Quotation_package that matches the filter.
     * @param {FindUniquequotation_packageArgs} args - Arguments to find a Quotation_package
     * @deprecated This will be deprecated please use prisma.quotation_package.findUnique
     * @example
     * // Get one Quotation_package
     * const quotation_package = await prisma.quotation_package.findOne({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findOne<T extends FindUniquequotation_packageArgs>(
      args: Subset<T, FindUniquequotation_packageArgs>
    ): CheckSelect<T, Prisma__quotation_packageClient<quotation_package | null>, Prisma__quotation_packageClient<quotation_packageGetPayload<T> | null>>
    /**
     * Count
     */
    count(args?: Omit<FindManyquotation_packageArgs, 'select' | 'include'>): Promise<number>

  

    /**
     * Aggregate
     */
    aggregate<T extends AggregateQuotation_packageArgs>(args: Subset<T, AggregateQuotation_packageArgs>): Promise<GetQuotation_packageAggregateType<T>>
  }

  /**
   * The delegate class that acts as a "Promise-like" for quotation_package.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__quotation_packageClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    quotation_modal_package<T extends FindManyquotation_modal_packageArgs = {}>(args?: Subset<T, FindManyquotation_modal_packageArgs>): CheckSelect<T, Promise<Array<quotation_modal_package>>, Promise<Array<quotation_modal_packageGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * quotation_package findUnique
   */
  export type FindUniquequotation_packageArgs = {
    /**
     * Select specific fields to fetch from the quotation_package
    **/
    select?: quotation_packageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: quotation_packageInclude | null
    /**
     * Filter, which quotation_package to fetch.
    **/
    where: quotation_packageWhereUniqueInput
  }


  /**
   * quotation_package findFirst
   */
  export type FindFirstquotation_packageArgs = {
    /**
     * Select specific fields to fetch from the quotation_package
    **/
    select?: quotation_packageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: quotation_packageInclude | null
    /**
     * Filter, which quotation_package to fetch.
    **/
    where?: quotation_packageWhereInput
    orderBy?: Enumerable<quotation_packageOrderByInput>
    cursor?: quotation_packageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Quotation_packageScalarFieldEnum>
  }


  /**
   * quotation_package findMany
   */
  export type FindManyquotation_packageArgs = {
    /**
     * Select specific fields to fetch from the quotation_package
    **/
    select?: quotation_packageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: quotation_packageInclude | null
    /**
     * Filter, which quotation_packages to fetch.
    **/
    where?: quotation_packageWhereInput
    /**
     * Determine the order of the quotation_packages to fetch.
    **/
    orderBy?: Enumerable<quotation_packageOrderByInput>
    /**
     * Sets the position for listing quotation_packages.
    **/
    cursor?: quotation_packageWhereUniqueInput
    /**
     * The number of quotation_packages to fetch. If negative number, it will take quotation_packages before the `cursor`.
    **/
    take?: number
    /**
     * Skip the first `n` quotation_packages.
    **/
    skip?: number
    distinct?: Enumerable<Quotation_packageScalarFieldEnum>
  }


  /**
   * quotation_package create
   */
  export type quotation_packageCreateArgs = {
    /**
     * Select specific fields to fetch from the quotation_package
    **/
    select?: quotation_packageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: quotation_packageInclude | null
    /**
     * The data needed to create a quotation_package.
    **/
    data: quotation_packageCreateInput
  }


  /**
   * quotation_package update
   */
  export type quotation_packageUpdateArgs = {
    /**
     * Select specific fields to fetch from the quotation_package
    **/
    select?: quotation_packageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: quotation_packageInclude | null
    /**
     * The data needed to update a quotation_package.
    **/
    data: quotation_packageUpdateInput
    /**
     * Choose, which quotation_package to update.
    **/
    where: quotation_packageWhereUniqueInput
  }


  /**
   * quotation_package updateMany
   */
  export type quotation_packageUpdateManyArgs = {
    data: quotation_packageUpdateManyMutationInput
    where?: quotation_packageWhereInput
  }


  /**
   * quotation_package upsert
   */
  export type quotation_packageUpsertArgs = {
    /**
     * Select specific fields to fetch from the quotation_package
    **/
    select?: quotation_packageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: quotation_packageInclude | null
    /**
     * The filter to search for the quotation_package to update in case it exists.
    **/
    where: quotation_packageWhereUniqueInput
    /**
     * In case the quotation_package found by the `where` argument doesn't exist, create a new quotation_package with this data.
    **/
    create: quotation_packageCreateInput
    /**
     * In case the quotation_package was found with the provided `where` argument, update it with this data.
    **/
    update: quotation_packageUpdateInput
  }


  /**
   * quotation_package delete
   */
  export type quotation_packageDeleteArgs = {
    /**
     * Select specific fields to fetch from the quotation_package
    **/
    select?: quotation_packageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: quotation_packageInclude | null
    /**
     * Filter which quotation_package to delete.
    **/
    where: quotation_packageWhereUniqueInput
  }


  /**
   * quotation_package deleteMany
   */
  export type quotation_packageDeleteManyArgs = {
    where?: quotation_packageWhereInput
  }


  /**
   * quotation_package without action
   */
  export type quotation_packageArgs = {
    /**
     * Select specific fields to fetch from the quotation_package
    **/
    select?: quotation_packageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: quotation_packageInclude | null
  }



  /**
   * Model role
   */


  export type AggregateRole = {
    count: number | null
    avg: RoleAvgAggregateOutputType | null
    sum: RoleSumAggregateOutputType | null
    min: RoleMinAggregateOutputType | null
    max: RoleMaxAggregateOutputType | null
  }

  export type RoleAvgAggregateOutputType = {
    id: number
  }

  export type RoleSumAggregateOutputType = {
    id: number
  }

  export type RoleMinAggregateOutputType = {
    id: number
    name: string | null
  }

  export type RoleMaxAggregateOutputType = {
    id: number
    name: string | null
  }

  export type RoleCountAggregateOutputType = {
    id: number
    name: number | null
    _all: number
  }


  export type RoleAvgAggregateInputType = {
    id?: true
  }

  export type RoleSumAggregateInputType = {
    id?: true
  }

  export type RoleMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type RoleMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type RoleCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type AggregateRoleArgs = {
    where?: roleWhereInput
    orderBy?: Enumerable<roleOrderByInput>
    cursor?: roleWhereUniqueInput
    take?: number
    skip?: number
    count?: true
    avg?: RoleAvgAggregateInputType
    sum?: RoleSumAggregateInputType
    min?: RoleMinAggregateInputType
    max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends AggregateRoleArgs> = {
    [P in keyof T]: P extends 'count' ? number : GetRoleAggregateScalarType<T[P]>
  }

  export type GetRoleAggregateScalarType<T extends any> = {
    [P in keyof T]: P extends keyof RoleAvgAggregateOutputType ? RoleAvgAggregateOutputType[P] : never
  }

    



  export type roleSelect = {
    id?: boolean
    name?: boolean
    user_role?: boolean | FindManyuser_roleArgs
  }

  export type roleInclude = {
    user_role?: boolean | FindManyuser_roleArgs
  }

  export type roleGetPayload<
    S extends boolean | null | undefined | roleArgs,
    U = keyof S
      > = S extends true
        ? role
    : S extends undefined
    ? never
    : S extends roleArgs | FindManyroleArgs
    ?'include' extends U
    ? role  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'user_role'
        ? Array < user_roleGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof role ?role [P]
  : 
          P extends 'user_role'
        ? Array < user_roleGetPayload<S['select'][P]>>  : never
  } 
    : role
  : role


  export interface roleDelegate {
    /**
     * Find zero or one Role that matches the filter.
     * @param {FindUniqueroleArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FindUniqueroleArgs>(
      args: Subset<T, FindUniqueroleArgs>
    ): CheckSelect<T, Prisma__roleClient<role | null>, Prisma__roleClient<roleGetPayload<T> | null>>
    /**
     * Find the first Role that matches the filter.
     * @param {FindFirstroleArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FindFirstroleArgs>(
      args?: Subset<T, FindFirstroleArgs>
    ): CheckSelect<T, Prisma__roleClient<role | null>, Prisma__roleClient<roleGetPayload<T> | null>>
    /**
     * Find zero or more Roles that matches the filter.
     * @param {FindManyroleArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleWithIdOnly = await prisma.role.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FindManyroleArgs>(
      args?: Subset<T, FindManyroleArgs>
    ): CheckSelect<T, Promise<Array<role>>, Promise<Array<roleGetPayload<T>>>>
    /**
     * Create a Role.
     * @param {roleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
    **/
    create<T extends roleCreateArgs>(
      args: Subset<T, roleCreateArgs>
    ): CheckSelect<T, Prisma__roleClient<role>, Prisma__roleClient<roleGetPayload<T>>>
    /**
     * Delete a Role.
     * @param {roleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
    **/
    delete<T extends roleDeleteArgs>(
      args: Subset<T, roleDeleteArgs>
    ): CheckSelect<T, Prisma__roleClient<role>, Prisma__roleClient<roleGetPayload<T>>>
    /**
     * Update one Role.
     * @param {roleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends roleUpdateArgs>(
      args: Subset<T, roleUpdateArgs>
    ): CheckSelect<T, Prisma__roleClient<role>, Prisma__roleClient<roleGetPayload<T>>>
    /**
     * Delete zero or more Roles.
     * @param {roleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends roleDeleteManyArgs>(
      args?: Subset<T, roleDeleteManyArgs>
    ): Promise<BatchPayload>
    /**
     * Update zero or more Roles.
     * @param {roleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends roleUpdateManyArgs>(
      args: Subset<T, roleUpdateManyArgs>
    ): Promise<BatchPayload>
    /**
     * Create or update one Role.
     * @param {roleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
    **/
    upsert<T extends roleUpsertArgs>(
      args: Subset<T, roleUpsertArgs>
    ): CheckSelect<T, Prisma__roleClient<role>, Prisma__roleClient<roleGetPayload<T>>>
    /**
     * Find zero or one Role that matches the filter.
     * @param {FindUniqueroleArgs} args - Arguments to find a Role
     * @deprecated This will be deprecated please use prisma.role.findUnique
     * @example
     * // Get one Role
     * const role = await prisma.role.findOne({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findOne<T extends FindUniqueroleArgs>(
      args: Subset<T, FindUniqueroleArgs>
    ): CheckSelect<T, Prisma__roleClient<role | null>, Prisma__roleClient<roleGetPayload<T> | null>>
    /**
     * Count
     */
    count(args?: Omit<FindManyroleArgs, 'select' | 'include'>): Promise<number>

  

    /**
     * Aggregate
     */
    aggregate<T extends AggregateRoleArgs>(args: Subset<T, AggregateRoleArgs>): Promise<GetRoleAggregateType<T>>
  }

  /**
   * The delegate class that acts as a "Promise-like" for role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__roleClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user_role<T extends FindManyuser_roleArgs = {}>(args?: Subset<T, FindManyuser_roleArgs>): CheckSelect<T, Promise<Array<user_role>>, Promise<Array<user_roleGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * role findUnique
   */
  export type FindUniqueroleArgs = {
    /**
     * Select specific fields to fetch from the role
    **/
    select?: roleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: roleInclude | null
    /**
     * Filter, which role to fetch.
    **/
    where: roleWhereUniqueInput
  }


  /**
   * role findFirst
   */
  export type FindFirstroleArgs = {
    /**
     * Select specific fields to fetch from the role
    **/
    select?: roleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: roleInclude | null
    /**
     * Filter, which role to fetch.
    **/
    where?: roleWhereInput
    orderBy?: Enumerable<roleOrderByInput>
    cursor?: roleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<RoleScalarFieldEnum>
  }


  /**
   * role findMany
   */
  export type FindManyroleArgs = {
    /**
     * Select specific fields to fetch from the role
    **/
    select?: roleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: roleInclude | null
    /**
     * Filter, which roles to fetch.
    **/
    where?: roleWhereInput
    /**
     * Determine the order of the roles to fetch.
    **/
    orderBy?: Enumerable<roleOrderByInput>
    /**
     * Sets the position for listing roles.
    **/
    cursor?: roleWhereUniqueInput
    /**
     * The number of roles to fetch. If negative number, it will take roles before the `cursor`.
    **/
    take?: number
    /**
     * Skip the first `n` roles.
    **/
    skip?: number
    distinct?: Enumerable<RoleScalarFieldEnum>
  }


  /**
   * role create
   */
  export type roleCreateArgs = {
    /**
     * Select specific fields to fetch from the role
    **/
    select?: roleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: roleInclude | null
    /**
     * The data needed to create a role.
    **/
    data: roleCreateInput
  }


  /**
   * role update
   */
  export type roleUpdateArgs = {
    /**
     * Select specific fields to fetch from the role
    **/
    select?: roleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: roleInclude | null
    /**
     * The data needed to update a role.
    **/
    data: roleUpdateInput
    /**
     * Choose, which role to update.
    **/
    where: roleWhereUniqueInput
  }


  /**
   * role updateMany
   */
  export type roleUpdateManyArgs = {
    data: roleUpdateManyMutationInput
    where?: roleWhereInput
  }


  /**
   * role upsert
   */
  export type roleUpsertArgs = {
    /**
     * Select specific fields to fetch from the role
    **/
    select?: roleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: roleInclude | null
    /**
     * The filter to search for the role to update in case it exists.
    **/
    where: roleWhereUniqueInput
    /**
     * In case the role found by the `where` argument doesn't exist, create a new role with this data.
    **/
    create: roleCreateInput
    /**
     * In case the role was found with the provided `where` argument, update it with this data.
    **/
    update: roleUpdateInput
  }


  /**
   * role delete
   */
  export type roleDeleteArgs = {
    /**
     * Select specific fields to fetch from the role
    **/
    select?: roleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: roleInclude | null
    /**
     * Filter which role to delete.
    **/
    where: roleWhereUniqueInput
  }


  /**
   * role deleteMany
   */
  export type roleDeleteManyArgs = {
    where?: roleWhereInput
  }


  /**
   * role without action
   */
  export type roleArgs = {
    /**
     * Select specific fields to fetch from the role
    **/
    select?: roleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: roleInclude | null
  }



  /**
   * Model seed_revision
   */


  export type AggregateSeed_revision = {
    count: number | null
    avg: Seed_revisionAvgAggregateOutputType | null
    sum: Seed_revisionSumAggregateOutputType | null
    min: Seed_revisionMinAggregateOutputType | null
    max: Seed_revisionMaxAggregateOutputType | null
  }

  export type Seed_revisionAvgAggregateOutputType = {
    id: number
    revision: number
    version_major: number | null
    version_minor: number | null
    version_patch: number | null
  }

  export type Seed_revisionSumAggregateOutputType = {
    id: number
    revision: number
    version_major: number | null
    version_minor: number | null
    version_patch: number | null
  }

  export type Seed_revisionMinAggregateOutputType = {
    id: number
    revision: number
    seeding_timestamp: Date | null
    version_major: number | null
    version_minor: number | null
    version_patch: number | null
  }

  export type Seed_revisionMaxAggregateOutputType = {
    id: number
    revision: number
    seeding_timestamp: Date | null
    version_major: number | null
    version_minor: number | null
    version_patch: number | null
  }

  export type Seed_revisionCountAggregateOutputType = {
    id: number
    revision: number
    seeding_timestamp: number | null
    version_major: number | null
    version_minor: number | null
    version_patch: number | null
    _all: number
  }


  export type Seed_revisionAvgAggregateInputType = {
    id?: true
    revision?: true
    version_major?: true
    version_minor?: true
    version_patch?: true
  }

  export type Seed_revisionSumAggregateInputType = {
    id?: true
    revision?: true
    version_major?: true
    version_minor?: true
    version_patch?: true
  }

  export type Seed_revisionMinAggregateInputType = {
    id?: true
    revision?: true
    seeding_timestamp?: true
    version_major?: true
    version_minor?: true
    version_patch?: true
  }

  export type Seed_revisionMaxAggregateInputType = {
    id?: true
    revision?: true
    seeding_timestamp?: true
    version_major?: true
    version_minor?: true
    version_patch?: true
  }

  export type Seed_revisionCountAggregateInputType = {
    id?: true
    revision?: true
    seeding_timestamp?: true
    version_major?: true
    version_minor?: true
    version_patch?: true
    _all?: true
  }

  export type AggregateSeed_revisionArgs = {
    where?: seed_revisionWhereInput
    orderBy?: Enumerable<seed_revisionOrderByInput>
    cursor?: seed_revisionWhereUniqueInput
    take?: number
    skip?: number
    count?: true
    avg?: Seed_revisionAvgAggregateInputType
    sum?: Seed_revisionSumAggregateInputType
    min?: Seed_revisionMinAggregateInputType
    max?: Seed_revisionMaxAggregateInputType
  }

  export type GetSeed_revisionAggregateType<T extends AggregateSeed_revisionArgs> = {
    [P in keyof T]: P extends 'count' ? number : GetSeed_revisionAggregateScalarType<T[P]>
  }

  export type GetSeed_revisionAggregateScalarType<T extends any> = {
    [P in keyof T]: P extends keyof Seed_revisionAvgAggregateOutputType ? Seed_revisionAvgAggregateOutputType[P] : never
  }

    



  export type seed_revisionSelect = {
    id?: boolean
    revision?: boolean
    seeding_timestamp?: boolean
    version_major?: boolean
    version_minor?: boolean
    version_patch?: boolean
  }

  export type seed_revisionGetPayload<
    S extends boolean | null | undefined | seed_revisionArgs,
    U = keyof S
      > = S extends true
        ? seed_revision
    : S extends undefined
    ? never
    : S extends seed_revisionArgs | FindManyseed_revisionArgs
    ?'include' extends U
    ? seed_revision 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof seed_revision ?seed_revision [P]
  : 
     never
  } 
    : seed_revision
  : seed_revision


  export interface seed_revisionDelegate {
    /**
     * Find zero or one Seed_revision that matches the filter.
     * @param {FindUniqueseed_revisionArgs} args - Arguments to find a Seed_revision
     * @example
     * // Get one Seed_revision
     * const seed_revision = await prisma.seed_revision.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FindUniqueseed_revisionArgs>(
      args: Subset<T, FindUniqueseed_revisionArgs>
    ): CheckSelect<T, Prisma__seed_revisionClient<seed_revision | null>, Prisma__seed_revisionClient<seed_revisionGetPayload<T> | null>>
    /**
     * Find the first Seed_revision that matches the filter.
     * @param {FindFirstseed_revisionArgs} args - Arguments to find a Seed_revision
     * @example
     * // Get one Seed_revision
     * const seed_revision = await prisma.seed_revision.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FindFirstseed_revisionArgs>(
      args?: Subset<T, FindFirstseed_revisionArgs>
    ): CheckSelect<T, Prisma__seed_revisionClient<seed_revision | null>, Prisma__seed_revisionClient<seed_revisionGetPayload<T> | null>>
    /**
     * Find zero or more Seed_revisions that matches the filter.
     * @param {FindManyseed_revisionArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Seed_revisions
     * const seed_revisions = await prisma.seed_revision.findMany()
     * 
     * // Get first 10 Seed_revisions
     * const seed_revisions = await prisma.seed_revision.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const seed_revisionWithIdOnly = await prisma.seed_revision.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FindManyseed_revisionArgs>(
      args?: Subset<T, FindManyseed_revisionArgs>
    ): CheckSelect<T, Promise<Array<seed_revision>>, Promise<Array<seed_revisionGetPayload<T>>>>
    /**
     * Create a Seed_revision.
     * @param {seed_revisionCreateArgs} args - Arguments to create a Seed_revision.
     * @example
     * // Create one Seed_revision
     * const Seed_revision = await prisma.seed_revision.create({
     *   data: {
     *     // ... data to create a Seed_revision
     *   }
     * })
     * 
    **/
    create<T extends seed_revisionCreateArgs>(
      args: Subset<T, seed_revisionCreateArgs>
    ): CheckSelect<T, Prisma__seed_revisionClient<seed_revision>, Prisma__seed_revisionClient<seed_revisionGetPayload<T>>>
    /**
     * Delete a Seed_revision.
     * @param {seed_revisionDeleteArgs} args - Arguments to delete one Seed_revision.
     * @example
     * // Delete one Seed_revision
     * const Seed_revision = await prisma.seed_revision.delete({
     *   where: {
     *     // ... filter to delete one Seed_revision
     *   }
     * })
     * 
    **/
    delete<T extends seed_revisionDeleteArgs>(
      args: Subset<T, seed_revisionDeleteArgs>
    ): CheckSelect<T, Prisma__seed_revisionClient<seed_revision>, Prisma__seed_revisionClient<seed_revisionGetPayload<T>>>
    /**
     * Update one Seed_revision.
     * @param {seed_revisionUpdateArgs} args - Arguments to update one Seed_revision.
     * @example
     * // Update one Seed_revision
     * const seed_revision = await prisma.seed_revision.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends seed_revisionUpdateArgs>(
      args: Subset<T, seed_revisionUpdateArgs>
    ): CheckSelect<T, Prisma__seed_revisionClient<seed_revision>, Prisma__seed_revisionClient<seed_revisionGetPayload<T>>>
    /**
     * Delete zero or more Seed_revisions.
     * @param {seed_revisionDeleteManyArgs} args - Arguments to filter Seed_revisions to delete.
     * @example
     * // Delete a few Seed_revisions
     * const { count } = await prisma.seed_revision.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends seed_revisionDeleteManyArgs>(
      args?: Subset<T, seed_revisionDeleteManyArgs>
    ): Promise<BatchPayload>
    /**
     * Update zero or more Seed_revisions.
     * @param {seed_revisionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Seed_revisions
     * const seed_revision = await prisma.seed_revision.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends seed_revisionUpdateManyArgs>(
      args: Subset<T, seed_revisionUpdateManyArgs>
    ): Promise<BatchPayload>
    /**
     * Create or update one Seed_revision.
     * @param {seed_revisionUpsertArgs} args - Arguments to update or create a Seed_revision.
     * @example
     * // Update or create a Seed_revision
     * const seed_revision = await prisma.seed_revision.upsert({
     *   create: {
     *     // ... data to create a Seed_revision
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Seed_revision we want to update
     *   }
     * })
    **/
    upsert<T extends seed_revisionUpsertArgs>(
      args: Subset<T, seed_revisionUpsertArgs>
    ): CheckSelect<T, Prisma__seed_revisionClient<seed_revision>, Prisma__seed_revisionClient<seed_revisionGetPayload<T>>>
    /**
     * Find zero or one Seed_revision that matches the filter.
     * @param {FindUniqueseed_revisionArgs} args - Arguments to find a Seed_revision
     * @deprecated This will be deprecated please use prisma.seed_revision.findUnique
     * @example
     * // Get one Seed_revision
     * const seed_revision = await prisma.seed_revision.findOne({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findOne<T extends FindUniqueseed_revisionArgs>(
      args: Subset<T, FindUniqueseed_revisionArgs>
    ): CheckSelect<T, Prisma__seed_revisionClient<seed_revision | null>, Prisma__seed_revisionClient<seed_revisionGetPayload<T> | null>>
    /**
     * Count
     */
    count(args?: Omit<FindManyseed_revisionArgs, 'select' | 'include'>): Promise<number>

  

    /**
     * Aggregate
     */
    aggregate<T extends AggregateSeed_revisionArgs>(args: Subset<T, AggregateSeed_revisionArgs>): Promise<GetSeed_revisionAggregateType<T>>
  }

  /**
   * The delegate class that acts as a "Promise-like" for seed_revision.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__seed_revisionClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * seed_revision findUnique
   */
  export type FindUniqueseed_revisionArgs = {
    /**
     * Select specific fields to fetch from the seed_revision
    **/
    select?: seed_revisionSelect | null
    /**
     * Filter, which seed_revision to fetch.
    **/
    where: seed_revisionWhereUniqueInput
  }


  /**
   * seed_revision findFirst
   */
  export type FindFirstseed_revisionArgs = {
    /**
     * Select specific fields to fetch from the seed_revision
    **/
    select?: seed_revisionSelect | null
    /**
     * Filter, which seed_revision to fetch.
    **/
    where?: seed_revisionWhereInput
    orderBy?: Enumerable<seed_revisionOrderByInput>
    cursor?: seed_revisionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Seed_revisionScalarFieldEnum>
  }


  /**
   * seed_revision findMany
   */
  export type FindManyseed_revisionArgs = {
    /**
     * Select specific fields to fetch from the seed_revision
    **/
    select?: seed_revisionSelect | null
    /**
     * Filter, which seed_revisions to fetch.
    **/
    where?: seed_revisionWhereInput
    /**
     * Determine the order of the seed_revisions to fetch.
    **/
    orderBy?: Enumerable<seed_revisionOrderByInput>
    /**
     * Sets the position for listing seed_revisions.
    **/
    cursor?: seed_revisionWhereUniqueInput
    /**
     * The number of seed_revisions to fetch. If negative number, it will take seed_revisions before the `cursor`.
    **/
    take?: number
    /**
     * Skip the first `n` seed_revisions.
    **/
    skip?: number
    distinct?: Enumerable<Seed_revisionScalarFieldEnum>
  }


  /**
   * seed_revision create
   */
  export type seed_revisionCreateArgs = {
    /**
     * Select specific fields to fetch from the seed_revision
    **/
    select?: seed_revisionSelect | null
    /**
     * The data needed to create a seed_revision.
    **/
    data: seed_revisionCreateInput
  }


  /**
   * seed_revision update
   */
  export type seed_revisionUpdateArgs = {
    /**
     * Select specific fields to fetch from the seed_revision
    **/
    select?: seed_revisionSelect | null
    /**
     * The data needed to update a seed_revision.
    **/
    data: seed_revisionUpdateInput
    /**
     * Choose, which seed_revision to update.
    **/
    where: seed_revisionWhereUniqueInput
  }


  /**
   * seed_revision updateMany
   */
  export type seed_revisionUpdateManyArgs = {
    data: seed_revisionUpdateManyMutationInput
    where?: seed_revisionWhereInput
  }


  /**
   * seed_revision upsert
   */
  export type seed_revisionUpsertArgs = {
    /**
     * Select specific fields to fetch from the seed_revision
    **/
    select?: seed_revisionSelect | null
    /**
     * The filter to search for the seed_revision to update in case it exists.
    **/
    where: seed_revisionWhereUniqueInput
    /**
     * In case the seed_revision found by the `where` argument doesn't exist, create a new seed_revision with this data.
    **/
    create: seed_revisionCreateInput
    /**
     * In case the seed_revision was found with the provided `where` argument, update it with this data.
    **/
    update: seed_revisionUpdateInput
  }


  /**
   * seed_revision delete
   */
  export type seed_revisionDeleteArgs = {
    /**
     * Select specific fields to fetch from the seed_revision
    **/
    select?: seed_revisionSelect | null
    /**
     * Filter which seed_revision to delete.
    **/
    where: seed_revisionWhereUniqueInput
  }


  /**
   * seed_revision deleteMany
   */
  export type seed_revisionDeleteManyArgs = {
    where?: seed_revisionWhereInput
  }


  /**
   * seed_revision without action
   */
  export type seed_revisionArgs = {
    /**
     * Select specific fields to fetch from the seed_revision
    **/
    select?: seed_revisionSelect | null
  }



  /**
   * Model state
   */


  export type AggregateState = {
    count: number | null
    avg: StateAvgAggregateOutputType | null
    sum: StateSumAggregateOutputType | null
    min: StateMinAggregateOutputType | null
    max: StateMaxAggregateOutputType | null
  }

  export type StateAvgAggregateOutputType = {
    id: number
    ibge_code: number | null
    country_code: number | null
  }

  export type StateSumAggregateOutputType = {
    id: number
    ibge_code: number | null
    country_code: number | null
  }

  export type StateMinAggregateOutputType = {
    id: number
    initials: string | null
    name: string | null
    ibge_code: number | null
    country_code: number | null
    area_code: JsonValue | null
  }

  export type StateMaxAggregateOutputType = {
    id: number
    initials: string | null
    name: string | null
    ibge_code: number | null
    country_code: number | null
    area_code: JsonValue | null
  }

  export type StateCountAggregateOutputType = {
    id: number
    initials: number | null
    name: number | null
    ibge_code: number | null
    country_code: number | null
    area_code: number | null
    _all: number
  }


  export type StateAvgAggregateInputType = {
    id?: true
    ibge_code?: true
    country_code?: true
  }

  export type StateSumAggregateInputType = {
    id?: true
    ibge_code?: true
    country_code?: true
  }

  export type StateMinAggregateInputType = {
    id?: true
    initials?: true
    name?: true
    ibge_code?: true
    country_code?: true
    area_code?: true
  }

  export type StateMaxAggregateInputType = {
    id?: true
    initials?: true
    name?: true
    ibge_code?: true
    country_code?: true
    area_code?: true
  }

  export type StateCountAggregateInputType = {
    id?: true
    initials?: true
    name?: true
    ibge_code?: true
    country_code?: true
    area_code?: true
    _all?: true
  }

  export type AggregateStateArgs = {
    where?: stateWhereInput
    orderBy?: Enumerable<stateOrderByInput>
    cursor?: stateWhereUniqueInput
    take?: number
    skip?: number
    count?: true
    avg?: StateAvgAggregateInputType
    sum?: StateSumAggregateInputType
    min?: StateMinAggregateInputType
    max?: StateMaxAggregateInputType
  }

  export type GetStateAggregateType<T extends AggregateStateArgs> = {
    [P in keyof T]: P extends 'count' ? number : GetStateAggregateScalarType<T[P]>
  }

  export type GetStateAggregateScalarType<T extends any> = {
    [P in keyof T]: P extends keyof StateAvgAggregateOutputType ? StateAvgAggregateOutputType[P] : never
  }

    



  export type stateSelect = {
    id?: boolean
    initials?: boolean
    name?: boolean
    ibge_code?: boolean
    country_code?: boolean
    area_code?: boolean
    address?: boolean | FindManyaddressArgs
  }

  export type stateInclude = {
    address?: boolean | FindManyaddressArgs
  }

  export type stateGetPayload<
    S extends boolean | null | undefined | stateArgs,
    U = keyof S
      > = S extends true
        ? state
    : S extends undefined
    ? never
    : S extends stateArgs | FindManystateArgs
    ?'include' extends U
    ? state  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'address'
        ? Array < addressGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof state ?state [P]
  : 
          P extends 'address'
        ? Array < addressGetPayload<S['select'][P]>>  : never
  } 
    : state
  : state


  export interface stateDelegate {
    /**
     * Find zero or one State that matches the filter.
     * @param {FindUniquestateArgs} args - Arguments to find a State
     * @example
     * // Get one State
     * const state = await prisma.state.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FindUniquestateArgs>(
      args: Subset<T, FindUniquestateArgs>
    ): CheckSelect<T, Prisma__stateClient<state | null>, Prisma__stateClient<stateGetPayload<T> | null>>
    /**
     * Find the first State that matches the filter.
     * @param {FindFirststateArgs} args - Arguments to find a State
     * @example
     * // Get one State
     * const state = await prisma.state.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FindFirststateArgs>(
      args?: Subset<T, FindFirststateArgs>
    ): CheckSelect<T, Prisma__stateClient<state | null>, Prisma__stateClient<stateGetPayload<T> | null>>
    /**
     * Find zero or more States that matches the filter.
     * @param {FindManystateArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all States
     * const states = await prisma.state.findMany()
     * 
     * // Get first 10 States
     * const states = await prisma.state.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stateWithIdOnly = await prisma.state.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FindManystateArgs>(
      args?: Subset<T, FindManystateArgs>
    ): CheckSelect<T, Promise<Array<state>>, Promise<Array<stateGetPayload<T>>>>
    /**
     * Create a State.
     * @param {stateCreateArgs} args - Arguments to create a State.
     * @example
     * // Create one State
     * const State = await prisma.state.create({
     *   data: {
     *     // ... data to create a State
     *   }
     * })
     * 
    **/
    create<T extends stateCreateArgs>(
      args: Subset<T, stateCreateArgs>
    ): CheckSelect<T, Prisma__stateClient<state>, Prisma__stateClient<stateGetPayload<T>>>
    /**
     * Delete a State.
     * @param {stateDeleteArgs} args - Arguments to delete one State.
     * @example
     * // Delete one State
     * const State = await prisma.state.delete({
     *   where: {
     *     // ... filter to delete one State
     *   }
     * })
     * 
    **/
    delete<T extends stateDeleteArgs>(
      args: Subset<T, stateDeleteArgs>
    ): CheckSelect<T, Prisma__stateClient<state>, Prisma__stateClient<stateGetPayload<T>>>
    /**
     * Update one State.
     * @param {stateUpdateArgs} args - Arguments to update one State.
     * @example
     * // Update one State
     * const state = await prisma.state.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends stateUpdateArgs>(
      args: Subset<T, stateUpdateArgs>
    ): CheckSelect<T, Prisma__stateClient<state>, Prisma__stateClient<stateGetPayload<T>>>
    /**
     * Delete zero or more States.
     * @param {stateDeleteManyArgs} args - Arguments to filter States to delete.
     * @example
     * // Delete a few States
     * const { count } = await prisma.state.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends stateDeleteManyArgs>(
      args?: Subset<T, stateDeleteManyArgs>
    ): Promise<BatchPayload>
    /**
     * Update zero or more States.
     * @param {stateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many States
     * const state = await prisma.state.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends stateUpdateManyArgs>(
      args: Subset<T, stateUpdateManyArgs>
    ): Promise<BatchPayload>
    /**
     * Create or update one State.
     * @param {stateUpsertArgs} args - Arguments to update or create a State.
     * @example
     * // Update or create a State
     * const state = await prisma.state.upsert({
     *   create: {
     *     // ... data to create a State
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the State we want to update
     *   }
     * })
    **/
    upsert<T extends stateUpsertArgs>(
      args: Subset<T, stateUpsertArgs>
    ): CheckSelect<T, Prisma__stateClient<state>, Prisma__stateClient<stateGetPayload<T>>>
    /**
     * Find zero or one State that matches the filter.
     * @param {FindUniquestateArgs} args - Arguments to find a State
     * @deprecated This will be deprecated please use prisma.state.findUnique
     * @example
     * // Get one State
     * const state = await prisma.state.findOne({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findOne<T extends FindUniquestateArgs>(
      args: Subset<T, FindUniquestateArgs>
    ): CheckSelect<T, Prisma__stateClient<state | null>, Prisma__stateClient<stateGetPayload<T> | null>>
    /**
     * Count
     */
    count(args?: Omit<FindManystateArgs, 'select' | 'include'>): Promise<number>

  

    /**
     * Aggregate
     */
    aggregate<T extends AggregateStateArgs>(args: Subset<T, AggregateStateArgs>): Promise<GetStateAggregateType<T>>
  }

  /**
   * The delegate class that acts as a "Promise-like" for state.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__stateClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    address<T extends FindManyaddressArgs = {}>(args?: Subset<T, FindManyaddressArgs>): CheckSelect<T, Promise<Array<address>>, Promise<Array<addressGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * state findUnique
   */
  export type FindUniquestateArgs = {
    /**
     * Select specific fields to fetch from the state
    **/
    select?: stateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: stateInclude | null
    /**
     * Filter, which state to fetch.
    **/
    where: stateWhereUniqueInput
  }


  /**
   * state findFirst
   */
  export type FindFirststateArgs = {
    /**
     * Select specific fields to fetch from the state
    **/
    select?: stateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: stateInclude | null
    /**
     * Filter, which state to fetch.
    **/
    where?: stateWhereInput
    orderBy?: Enumerable<stateOrderByInput>
    cursor?: stateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<StateScalarFieldEnum>
  }


  /**
   * state findMany
   */
  export type FindManystateArgs = {
    /**
     * Select specific fields to fetch from the state
    **/
    select?: stateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: stateInclude | null
    /**
     * Filter, which states to fetch.
    **/
    where?: stateWhereInput
    /**
     * Determine the order of the states to fetch.
    **/
    orderBy?: Enumerable<stateOrderByInput>
    /**
     * Sets the position for listing states.
    **/
    cursor?: stateWhereUniqueInput
    /**
     * The number of states to fetch. If negative number, it will take states before the `cursor`.
    **/
    take?: number
    /**
     * Skip the first `n` states.
    **/
    skip?: number
    distinct?: Enumerable<StateScalarFieldEnum>
  }


  /**
   * state create
   */
  export type stateCreateArgs = {
    /**
     * Select specific fields to fetch from the state
    **/
    select?: stateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: stateInclude | null
    /**
     * The data needed to create a state.
    **/
    data: stateCreateInput
  }


  /**
   * state update
   */
  export type stateUpdateArgs = {
    /**
     * Select specific fields to fetch from the state
    **/
    select?: stateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: stateInclude | null
    /**
     * The data needed to update a state.
    **/
    data: stateUpdateInput
    /**
     * Choose, which state to update.
    **/
    where: stateWhereUniqueInput
  }


  /**
   * state updateMany
   */
  export type stateUpdateManyArgs = {
    data: stateUpdateManyMutationInput
    where?: stateWhereInput
  }


  /**
   * state upsert
   */
  export type stateUpsertArgs = {
    /**
     * Select specific fields to fetch from the state
    **/
    select?: stateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: stateInclude | null
    /**
     * The filter to search for the state to update in case it exists.
    **/
    where: stateWhereUniqueInput
    /**
     * In case the state found by the `where` argument doesn't exist, create a new state with this data.
    **/
    create: stateCreateInput
    /**
     * In case the state was found with the provided `where` argument, update it with this data.
    **/
    update: stateUpdateInput
  }


  /**
   * state delete
   */
  export type stateDeleteArgs = {
    /**
     * Select specific fields to fetch from the state
    **/
    select?: stateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: stateInclude | null
    /**
     * Filter which state to delete.
    **/
    where: stateWhereUniqueInput
  }


  /**
   * state deleteMany
   */
  export type stateDeleteManyArgs = {
    where?: stateWhereInput
  }


  /**
   * state without action
   */
  export type stateArgs = {
    /**
     * Select specific fields to fetch from the state
    **/
    select?: stateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: stateInclude | null
  }



  /**
   * Model terms_and_conditions
   */


  export type AggregateTerms_and_conditions = {
    count: number | null
    avg: Terms_and_conditionsAvgAggregateOutputType | null
    sum: Terms_and_conditionsSumAggregateOutputType | null
    min: Terms_and_conditionsMinAggregateOutputType | null
    max: Terms_and_conditionsMaxAggregateOutputType | null
  }

  export type Terms_and_conditionsAvgAggregateOutputType = {
    id: number
  }

  export type Terms_and_conditionsSumAggregateOutputType = {
    id: number
  }

  export type Terms_and_conditionsMinAggregateOutputType = {
    id: number
    content: string | null
    publish_date: Date | null
  }

  export type Terms_and_conditionsMaxAggregateOutputType = {
    id: number
    content: string | null
    publish_date: Date | null
  }

  export type Terms_and_conditionsCountAggregateOutputType = {
    id: number
    content: number | null
    publish_date: number | null
    _all: number
  }


  export type Terms_and_conditionsAvgAggregateInputType = {
    id?: true
  }

  export type Terms_and_conditionsSumAggregateInputType = {
    id?: true
  }

  export type Terms_and_conditionsMinAggregateInputType = {
    id?: true
    content?: true
    publish_date?: true
  }

  export type Terms_and_conditionsMaxAggregateInputType = {
    id?: true
    content?: true
    publish_date?: true
  }

  export type Terms_and_conditionsCountAggregateInputType = {
    id?: true
    content?: true
    publish_date?: true
    _all?: true
  }

  export type AggregateTerms_and_conditionsArgs = {
    where?: terms_and_conditionsWhereInput
    orderBy?: Enumerable<terms_and_conditionsOrderByInput>
    cursor?: terms_and_conditionsWhereUniqueInput
    take?: number
    skip?: number
    count?: true
    avg?: Terms_and_conditionsAvgAggregateInputType
    sum?: Terms_and_conditionsSumAggregateInputType
    min?: Terms_and_conditionsMinAggregateInputType
    max?: Terms_and_conditionsMaxAggregateInputType
  }

  export type GetTerms_and_conditionsAggregateType<T extends AggregateTerms_and_conditionsArgs> = {
    [P in keyof T]: P extends 'count' ? number : GetTerms_and_conditionsAggregateScalarType<T[P]>
  }

  export type GetTerms_and_conditionsAggregateScalarType<T extends any> = {
    [P in keyof T]: P extends keyof Terms_and_conditionsAvgAggregateOutputType ? Terms_and_conditionsAvgAggregateOutputType[P] : never
  }

    



  export type terms_and_conditionsSelect = {
    id?: boolean
    content?: boolean
    publish_date?: boolean
    user_accepted_terms?: boolean | FindManyuser_accepted_termsArgs
  }

  export type terms_and_conditionsInclude = {
    user_accepted_terms?: boolean | FindManyuser_accepted_termsArgs
  }

  export type terms_and_conditionsGetPayload<
    S extends boolean | null | undefined | terms_and_conditionsArgs,
    U = keyof S
      > = S extends true
        ? terms_and_conditions
    : S extends undefined
    ? never
    : S extends terms_and_conditionsArgs | FindManyterms_and_conditionsArgs
    ?'include' extends U
    ? terms_and_conditions  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'user_accepted_terms'
        ? Array < user_accepted_termsGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof terms_and_conditions ?terms_and_conditions [P]
  : 
          P extends 'user_accepted_terms'
        ? Array < user_accepted_termsGetPayload<S['select'][P]>>  : never
  } 
    : terms_and_conditions
  : terms_and_conditions


  export interface terms_and_conditionsDelegate {
    /**
     * Find zero or one Terms_and_conditions that matches the filter.
     * @param {FindUniqueterms_and_conditionsArgs} args - Arguments to find a Terms_and_conditions
     * @example
     * // Get one Terms_and_conditions
     * const terms_and_conditions = await prisma.terms_and_conditions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FindUniqueterms_and_conditionsArgs>(
      args: Subset<T, FindUniqueterms_and_conditionsArgs>
    ): CheckSelect<T, Prisma__terms_and_conditionsClient<terms_and_conditions | null>, Prisma__terms_and_conditionsClient<terms_and_conditionsGetPayload<T> | null>>
    /**
     * Find the first Terms_and_conditions that matches the filter.
     * @param {FindFirstterms_and_conditionsArgs} args - Arguments to find a Terms_and_conditions
     * @example
     * // Get one Terms_and_conditions
     * const terms_and_conditions = await prisma.terms_and_conditions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FindFirstterms_and_conditionsArgs>(
      args?: Subset<T, FindFirstterms_and_conditionsArgs>
    ): CheckSelect<T, Prisma__terms_and_conditionsClient<terms_and_conditions | null>, Prisma__terms_and_conditionsClient<terms_and_conditionsGetPayload<T> | null>>
    /**
     * Find zero or more Terms_and_conditions that matches the filter.
     * @param {FindManyterms_and_conditionsArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Terms_and_conditions
     * const terms_and_conditions = await prisma.terms_and_conditions.findMany()
     * 
     * // Get first 10 Terms_and_conditions
     * const terms_and_conditions = await prisma.terms_and_conditions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const terms_and_conditionsWithIdOnly = await prisma.terms_and_conditions.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FindManyterms_and_conditionsArgs>(
      args?: Subset<T, FindManyterms_and_conditionsArgs>
    ): CheckSelect<T, Promise<Array<terms_and_conditions>>, Promise<Array<terms_and_conditionsGetPayload<T>>>>
    /**
     * Create a Terms_and_conditions.
     * @param {terms_and_conditionsCreateArgs} args - Arguments to create a Terms_and_conditions.
     * @example
     * // Create one Terms_and_conditions
     * const Terms_and_conditions = await prisma.terms_and_conditions.create({
     *   data: {
     *     // ... data to create a Terms_and_conditions
     *   }
     * })
     * 
    **/
    create<T extends terms_and_conditionsCreateArgs>(
      args: Subset<T, terms_and_conditionsCreateArgs>
    ): CheckSelect<T, Prisma__terms_and_conditionsClient<terms_and_conditions>, Prisma__terms_and_conditionsClient<terms_and_conditionsGetPayload<T>>>
    /**
     * Delete a Terms_and_conditions.
     * @param {terms_and_conditionsDeleteArgs} args - Arguments to delete one Terms_and_conditions.
     * @example
     * // Delete one Terms_and_conditions
     * const Terms_and_conditions = await prisma.terms_and_conditions.delete({
     *   where: {
     *     // ... filter to delete one Terms_and_conditions
     *   }
     * })
     * 
    **/
    delete<T extends terms_and_conditionsDeleteArgs>(
      args: Subset<T, terms_and_conditionsDeleteArgs>
    ): CheckSelect<T, Prisma__terms_and_conditionsClient<terms_and_conditions>, Prisma__terms_and_conditionsClient<terms_and_conditionsGetPayload<T>>>
    /**
     * Update one Terms_and_conditions.
     * @param {terms_and_conditionsUpdateArgs} args - Arguments to update one Terms_and_conditions.
     * @example
     * // Update one Terms_and_conditions
     * const terms_and_conditions = await prisma.terms_and_conditions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends terms_and_conditionsUpdateArgs>(
      args: Subset<T, terms_and_conditionsUpdateArgs>
    ): CheckSelect<T, Prisma__terms_and_conditionsClient<terms_and_conditions>, Prisma__terms_and_conditionsClient<terms_and_conditionsGetPayload<T>>>
    /**
     * Delete zero or more Terms_and_conditions.
     * @param {terms_and_conditionsDeleteManyArgs} args - Arguments to filter Terms_and_conditions to delete.
     * @example
     * // Delete a few Terms_and_conditions
     * const { count } = await prisma.terms_and_conditions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends terms_and_conditionsDeleteManyArgs>(
      args?: Subset<T, terms_and_conditionsDeleteManyArgs>
    ): Promise<BatchPayload>
    /**
     * Update zero or more Terms_and_conditions.
     * @param {terms_and_conditionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Terms_and_conditions
     * const terms_and_conditions = await prisma.terms_and_conditions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends terms_and_conditionsUpdateManyArgs>(
      args: Subset<T, terms_and_conditionsUpdateManyArgs>
    ): Promise<BatchPayload>
    /**
     * Create or update one Terms_and_conditions.
     * @param {terms_and_conditionsUpsertArgs} args - Arguments to update or create a Terms_and_conditions.
     * @example
     * // Update or create a Terms_and_conditions
     * const terms_and_conditions = await prisma.terms_and_conditions.upsert({
     *   create: {
     *     // ... data to create a Terms_and_conditions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Terms_and_conditions we want to update
     *   }
     * })
    **/
    upsert<T extends terms_and_conditionsUpsertArgs>(
      args: Subset<T, terms_and_conditionsUpsertArgs>
    ): CheckSelect<T, Prisma__terms_and_conditionsClient<terms_and_conditions>, Prisma__terms_and_conditionsClient<terms_and_conditionsGetPayload<T>>>
    /**
     * Find zero or one Terms_and_conditions that matches the filter.
     * @param {FindUniqueterms_and_conditionsArgs} args - Arguments to find a Terms_and_conditions
     * @deprecated This will be deprecated please use prisma.terms_and_conditions.findUnique
     * @example
     * // Get one Terms_and_conditions
     * const terms_and_conditions = await prisma.terms_and_conditions.findOne({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findOne<T extends FindUniqueterms_and_conditionsArgs>(
      args: Subset<T, FindUniqueterms_and_conditionsArgs>
    ): CheckSelect<T, Prisma__terms_and_conditionsClient<terms_and_conditions | null>, Prisma__terms_and_conditionsClient<terms_and_conditionsGetPayload<T> | null>>
    /**
     * Count
     */
    count(args?: Omit<FindManyterms_and_conditionsArgs, 'select' | 'include'>): Promise<number>

  

    /**
     * Aggregate
     */
    aggregate<T extends AggregateTerms_and_conditionsArgs>(args: Subset<T, AggregateTerms_and_conditionsArgs>): Promise<GetTerms_and_conditionsAggregateType<T>>
  }

  /**
   * The delegate class that acts as a "Promise-like" for terms_and_conditions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__terms_and_conditionsClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user_accepted_terms<T extends FindManyuser_accepted_termsArgs = {}>(args?: Subset<T, FindManyuser_accepted_termsArgs>): CheckSelect<T, Promise<Array<user_accepted_terms>>, Promise<Array<user_accepted_termsGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * terms_and_conditions findUnique
   */
  export type FindUniqueterms_and_conditionsArgs = {
    /**
     * Select specific fields to fetch from the terms_and_conditions
    **/
    select?: terms_and_conditionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: terms_and_conditionsInclude | null
    /**
     * Filter, which terms_and_conditions to fetch.
    **/
    where: terms_and_conditionsWhereUniqueInput
  }


  /**
   * terms_and_conditions findFirst
   */
  export type FindFirstterms_and_conditionsArgs = {
    /**
     * Select specific fields to fetch from the terms_and_conditions
    **/
    select?: terms_and_conditionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: terms_and_conditionsInclude | null
    /**
     * Filter, which terms_and_conditions to fetch.
    **/
    where?: terms_and_conditionsWhereInput
    orderBy?: Enumerable<terms_and_conditionsOrderByInput>
    cursor?: terms_and_conditionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Terms_and_conditionsScalarFieldEnum>
  }


  /**
   * terms_and_conditions findMany
   */
  export type FindManyterms_and_conditionsArgs = {
    /**
     * Select specific fields to fetch from the terms_and_conditions
    **/
    select?: terms_and_conditionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: terms_and_conditionsInclude | null
    /**
     * Filter, which terms_and_conditions to fetch.
    **/
    where?: terms_and_conditionsWhereInput
    /**
     * Determine the order of the terms_and_conditions to fetch.
    **/
    orderBy?: Enumerable<terms_and_conditionsOrderByInput>
    /**
     * Sets the position for listing terms_and_conditions.
    **/
    cursor?: terms_and_conditionsWhereUniqueInput
    /**
     * The number of terms_and_conditions to fetch. If negative number, it will take terms_and_conditions before the `cursor`.
    **/
    take?: number
    /**
     * Skip the first `n` terms_and_conditions.
    **/
    skip?: number
    distinct?: Enumerable<Terms_and_conditionsScalarFieldEnum>
  }


  /**
   * terms_and_conditions create
   */
  export type terms_and_conditionsCreateArgs = {
    /**
     * Select specific fields to fetch from the terms_and_conditions
    **/
    select?: terms_and_conditionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: terms_and_conditionsInclude | null
    /**
     * The data needed to create a terms_and_conditions.
    **/
    data: terms_and_conditionsCreateInput
  }


  /**
   * terms_and_conditions update
   */
  export type terms_and_conditionsUpdateArgs = {
    /**
     * Select specific fields to fetch from the terms_and_conditions
    **/
    select?: terms_and_conditionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: terms_and_conditionsInclude | null
    /**
     * The data needed to update a terms_and_conditions.
    **/
    data: terms_and_conditionsUpdateInput
    /**
     * Choose, which terms_and_conditions to update.
    **/
    where: terms_and_conditionsWhereUniqueInput
  }


  /**
   * terms_and_conditions updateMany
   */
  export type terms_and_conditionsUpdateManyArgs = {
    data: terms_and_conditionsUpdateManyMutationInput
    where?: terms_and_conditionsWhereInput
  }


  /**
   * terms_and_conditions upsert
   */
  export type terms_and_conditionsUpsertArgs = {
    /**
     * Select specific fields to fetch from the terms_and_conditions
    **/
    select?: terms_and_conditionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: terms_and_conditionsInclude | null
    /**
     * The filter to search for the terms_and_conditions to update in case it exists.
    **/
    where: terms_and_conditionsWhereUniqueInput
    /**
     * In case the terms_and_conditions found by the `where` argument doesn't exist, create a new terms_and_conditions with this data.
    **/
    create: terms_and_conditionsCreateInput
    /**
     * In case the terms_and_conditions was found with the provided `where` argument, update it with this data.
    **/
    update: terms_and_conditionsUpdateInput
  }


  /**
   * terms_and_conditions delete
   */
  export type terms_and_conditionsDeleteArgs = {
    /**
     * Select specific fields to fetch from the terms_and_conditions
    **/
    select?: terms_and_conditionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: terms_and_conditionsInclude | null
    /**
     * Filter which terms_and_conditions to delete.
    **/
    where: terms_and_conditionsWhereUniqueInput
  }


  /**
   * terms_and_conditions deleteMany
   */
  export type terms_and_conditionsDeleteManyArgs = {
    where?: terms_and_conditionsWhereInput
  }


  /**
   * terms_and_conditions without action
   */
  export type terms_and_conditionsArgs = {
    /**
     * Select specific fields to fetch from the terms_and_conditions
    **/
    select?: terms_and_conditionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: terms_and_conditionsInclude | null
  }



  /**
   * Model user
   */


  export type AggregateUser = {
    count: number | null
    avg: UserAvgAggregateOutputType | null
    sum: UserSumAggregateOutputType | null
    min: UserMinAggregateOutputType | null
    max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number
    yellow_threshold: number
    red_threshold: number
  }

  export type UserSumAggregateOutputType = {
    id: number
    yellow_threshold: number
    red_threshold: number
  }

  export type UserMinAggregateOutputType = {
    id: number
    first_name: string | null
    last_name: string | null
    username: string | null
    password: string | null
    cpf: string | null
    phone_number: string | null
    email: string | null
    active: boolean | null
    creation_date: Date | null
    access_date: Date | null
    update_date: Date | null
    yellow_threshold: number
    red_threshold: number
    fcm_token: string | null
    avatar: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: number
    first_name: string | null
    last_name: string | null
    username: string | null
    password: string | null
    cpf: string | null
    phone_number: string | null
    email: string | null
    active: boolean | null
    creation_date: Date | null
    access_date: Date | null
    update_date: Date | null
    yellow_threshold: number
    red_threshold: number
    fcm_token: string | null
    avatar: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    first_name: number | null
    last_name: number | null
    username: number | null
    password: number | null
    cpf: number | null
    phone_number: number | null
    email: number | null
    active: number | null
    creation_date: number | null
    access_date: number | null
    update_date: number | null
    yellow_threshold: number
    red_threshold: number
    fcm_token: number | null
    avatar: number | null
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    yellow_threshold?: true
    red_threshold?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    yellow_threshold?: true
    red_threshold?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    first_name?: true
    last_name?: true
    username?: true
    password?: true
    cpf?: true
    phone_number?: true
    email?: true
    active?: true
    creation_date?: true
    access_date?: true
    update_date?: true
    yellow_threshold?: true
    red_threshold?: true
    fcm_token?: true
    avatar?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    first_name?: true
    last_name?: true
    username?: true
    password?: true
    cpf?: true
    phone_number?: true
    email?: true
    active?: true
    creation_date?: true
    access_date?: true
    update_date?: true
    yellow_threshold?: true
    red_threshold?: true
    fcm_token?: true
    avatar?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    first_name?: true
    last_name?: true
    username?: true
    password?: true
    cpf?: true
    phone_number?: true
    email?: true
    active?: true
    creation_date?: true
    access_date?: true
    update_date?: true
    yellow_threshold?: true
    red_threshold?: true
    fcm_token?: true
    avatar?: true
    _all?: true
  }

  export type AggregateUserArgs = {
    where?: userWhereInput
    orderBy?: Enumerable<userOrderByInput>
    cursor?: userWhereUniqueInput
    take?: number
    skip?: number
    count?: true
    avg?: UserAvgAggregateInputType
    sum?: UserSumAggregateInputType
    min?: UserMinAggregateInputType
    max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends AggregateUserArgs> = {
    [P in keyof T]: P extends 'count' ? number : GetUserAggregateScalarType<T[P]>
  }

  export type GetUserAggregateScalarType<T extends any> = {
    [P in keyof T]: P extends keyof UserAvgAggregateOutputType ? UserAvgAggregateOutputType[P] : never
  }

    



  export type userSelect = {
    id?: boolean
    first_name?: boolean
    last_name?: boolean
    username?: boolean
    password?: boolean
    cpf?: boolean
    phone_number?: boolean
    email?: boolean
    active?: boolean
    creation_date?: boolean
    access_date?: boolean
    update_date?: boolean
    yellow_threshold?: boolean
    red_threshold?: boolean
    fcm_token?: boolean
    avatar?: boolean
    many_user_has_many_farm?: boolean | FindManymany_user_has_many_farmArgs
    notification?: boolean | FindManynotificationArgs
    user_accepted_privacy_policy?: boolean | FindManyuser_accepted_privacy_policyArgs
    user_accepted_terms?: boolean | FindManyuser_accepted_termsArgs
    user_role?: boolean | FindManyuser_roleArgs
  }

  export type userInclude = {
    many_user_has_many_farm?: boolean | FindManymany_user_has_many_farmArgs
    notification?: boolean | FindManynotificationArgs
    user_accepted_privacy_policy?: boolean | FindManyuser_accepted_privacy_policyArgs
    user_accepted_terms?: boolean | FindManyuser_accepted_termsArgs
    user_role?: boolean | FindManyuser_roleArgs
  }

  export type userGetPayload<
    S extends boolean | null | undefined | userArgs,
    U = keyof S
      > = S extends true
        ? user
    : S extends undefined
    ? never
    : S extends userArgs | FindManyuserArgs
    ?'include' extends U
    ? user  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'many_user_has_many_farm'
        ? Array < many_user_has_many_farmGetPayload<S['include'][P]>>  :
        P extends 'notification'
        ? Array < notificationGetPayload<S['include'][P]>>  :
        P extends 'user_accepted_privacy_policy'
        ? Array < user_accepted_privacy_policyGetPayload<S['include'][P]>>  :
        P extends 'user_accepted_terms'
        ? Array < user_accepted_termsGetPayload<S['include'][P]>>  :
        P extends 'user_role'
        ? Array < user_roleGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof user ?user [P]
  : 
          P extends 'many_user_has_many_farm'
        ? Array < many_user_has_many_farmGetPayload<S['select'][P]>>  :
        P extends 'notification'
        ? Array < notificationGetPayload<S['select'][P]>>  :
        P extends 'user_accepted_privacy_policy'
        ? Array < user_accepted_privacy_policyGetPayload<S['select'][P]>>  :
        P extends 'user_accepted_terms'
        ? Array < user_accepted_termsGetPayload<S['select'][P]>>  :
        P extends 'user_role'
        ? Array < user_roleGetPayload<S['select'][P]>>  : never
  } 
    : user
  : user


  export interface userDelegate {
    /**
     * Find zero or one User that matches the filter.
     * @param {FindUniqueuserArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FindUniqueuserArgs>(
      args: Subset<T, FindUniqueuserArgs>
    ): CheckSelect<T, Prisma__userClient<user | null>, Prisma__userClient<userGetPayload<T> | null>>
    /**
     * Find the first User that matches the filter.
     * @param {FindFirstuserArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FindFirstuserArgs>(
      args?: Subset<T, FindFirstuserArgs>
    ): CheckSelect<T, Prisma__userClient<user | null>, Prisma__userClient<userGetPayload<T> | null>>
    /**
     * Find zero or more Users that matches the filter.
     * @param {FindManyuserArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FindManyuserArgs>(
      args?: Subset<T, FindManyuserArgs>
    ): CheckSelect<T, Promise<Array<user>>, Promise<Array<userGetPayload<T>>>>
    /**
     * Create a User.
     * @param {userCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends userCreateArgs>(
      args: Subset<T, userCreateArgs>
    ): CheckSelect<T, Prisma__userClient<user>, Prisma__userClient<userGetPayload<T>>>
    /**
     * Delete a User.
     * @param {userDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends userDeleteArgs>(
      args: Subset<T, userDeleteArgs>
    ): CheckSelect<T, Prisma__userClient<user>, Prisma__userClient<userGetPayload<T>>>
    /**
     * Update one User.
     * @param {userUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends userUpdateArgs>(
      args: Subset<T, userUpdateArgs>
    ): CheckSelect<T, Prisma__userClient<user>, Prisma__userClient<userGetPayload<T>>>
    /**
     * Delete zero or more Users.
     * @param {userDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends userDeleteManyArgs>(
      args?: Subset<T, userDeleteManyArgs>
    ): Promise<BatchPayload>
    /**
     * Update zero or more Users.
     * @param {userUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends userUpdateManyArgs>(
      args: Subset<T, userUpdateManyArgs>
    ): Promise<BatchPayload>
    /**
     * Create or update one User.
     * @param {userUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends userUpsertArgs>(
      args: Subset<T, userUpsertArgs>
    ): CheckSelect<T, Prisma__userClient<user>, Prisma__userClient<userGetPayload<T>>>
    /**
     * Find zero or one User that matches the filter.
     * @param {FindUniqueuserArgs} args - Arguments to find a User
     * @deprecated This will be deprecated please use prisma.user.findUnique
     * @example
     * // Get one User
     * const user = await prisma.user.findOne({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findOne<T extends FindUniqueuserArgs>(
      args: Subset<T, FindUniqueuserArgs>
    ): CheckSelect<T, Prisma__userClient<user | null>, Prisma__userClient<userGetPayload<T> | null>>
    /**
     * Count
     */
    count(args?: Omit<FindManyuserArgs, 'select' | 'include'>): Promise<number>

  

    /**
     * Aggregate
     */
    aggregate<T extends AggregateUserArgs>(args: Subset<T, AggregateUserArgs>): Promise<GetUserAggregateType<T>>
  }

  /**
   * The delegate class that acts as a "Promise-like" for user.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__userClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    many_user_has_many_farm<T extends FindManymany_user_has_many_farmArgs = {}>(args?: Subset<T, FindManymany_user_has_many_farmArgs>): CheckSelect<T, Promise<Array<many_user_has_many_farm>>, Promise<Array<many_user_has_many_farmGetPayload<T>>>>;

    notification<T extends FindManynotificationArgs = {}>(args?: Subset<T, FindManynotificationArgs>): CheckSelect<T, Promise<Array<notification>>, Promise<Array<notificationGetPayload<T>>>>;

    user_accepted_privacy_policy<T extends FindManyuser_accepted_privacy_policyArgs = {}>(args?: Subset<T, FindManyuser_accepted_privacy_policyArgs>): CheckSelect<T, Promise<Array<user_accepted_privacy_policy>>, Promise<Array<user_accepted_privacy_policyGetPayload<T>>>>;

    user_accepted_terms<T extends FindManyuser_accepted_termsArgs = {}>(args?: Subset<T, FindManyuser_accepted_termsArgs>): CheckSelect<T, Promise<Array<user_accepted_terms>>, Promise<Array<user_accepted_termsGetPayload<T>>>>;

    user_role<T extends FindManyuser_roleArgs = {}>(args?: Subset<T, FindManyuser_roleArgs>): CheckSelect<T, Promise<Array<user_role>>, Promise<Array<user_roleGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * user findUnique
   */
  export type FindUniqueuserArgs = {
    /**
     * Select specific fields to fetch from the user
    **/
    select?: userSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: userInclude | null
    /**
     * Filter, which user to fetch.
    **/
    where: userWhereUniqueInput
  }


  /**
   * user findFirst
   */
  export type FindFirstuserArgs = {
    /**
     * Select specific fields to fetch from the user
    **/
    select?: userSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: userInclude | null
    /**
     * Filter, which user to fetch.
    **/
    where?: userWhereInput
    orderBy?: Enumerable<userOrderByInput>
    cursor?: userWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * user findMany
   */
  export type FindManyuserArgs = {
    /**
     * Select specific fields to fetch from the user
    **/
    select?: userSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: userInclude | null
    /**
     * Filter, which users to fetch.
    **/
    where?: userWhereInput
    /**
     * Determine the order of the users to fetch.
    **/
    orderBy?: Enumerable<userOrderByInput>
    /**
     * Sets the position for listing users.
    **/
    cursor?: userWhereUniqueInput
    /**
     * The number of users to fetch. If negative number, it will take users before the `cursor`.
    **/
    take?: number
    /**
     * Skip the first `n` users.
    **/
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * user create
   */
  export type userCreateArgs = {
    /**
     * Select specific fields to fetch from the user
    **/
    select?: userSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: userInclude | null
    /**
     * The data needed to create a user.
    **/
    data: userCreateInput
  }


  /**
   * user update
   */
  export type userUpdateArgs = {
    /**
     * Select specific fields to fetch from the user
    **/
    select?: userSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: userInclude | null
    /**
     * The data needed to update a user.
    **/
    data: userUpdateInput
    /**
     * Choose, which user to update.
    **/
    where: userWhereUniqueInput
  }


  /**
   * user updateMany
   */
  export type userUpdateManyArgs = {
    data: userUpdateManyMutationInput
    where?: userWhereInput
  }


  /**
   * user upsert
   */
  export type userUpsertArgs = {
    /**
     * Select specific fields to fetch from the user
    **/
    select?: userSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: userInclude | null
    /**
     * The filter to search for the user to update in case it exists.
    **/
    where: userWhereUniqueInput
    /**
     * In case the user found by the `where` argument doesn't exist, create a new user with this data.
    **/
    create: userCreateInput
    /**
     * In case the user was found with the provided `where` argument, update it with this data.
    **/
    update: userUpdateInput
  }


  /**
   * user delete
   */
  export type userDeleteArgs = {
    /**
     * Select specific fields to fetch from the user
    **/
    select?: userSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: userInclude | null
    /**
     * Filter which user to delete.
    **/
    where: userWhereUniqueInput
  }


  /**
   * user deleteMany
   */
  export type userDeleteManyArgs = {
    where?: userWhereInput
  }


  /**
   * user without action
   */
  export type userArgs = {
    /**
     * Select specific fields to fetch from the user
    **/
    select?: userSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: userInclude | null
  }



  /**
   * Model user_accepted_privacy_policy
   */


  export type AggregateUser_accepted_privacy_policy = {
    count: number | null
    avg: User_accepted_privacy_policyAvgAggregateOutputType | null
    sum: User_accepted_privacy_policySumAggregateOutputType | null
    min: User_accepted_privacy_policyMinAggregateOutputType | null
    max: User_accepted_privacy_policyMaxAggregateOutputType | null
  }

  export type User_accepted_privacy_policyAvgAggregateOutputType = {
    id: number
    id_privacy_policy: number
    id_user: number
  }

  export type User_accepted_privacy_policySumAggregateOutputType = {
    id: number
    id_privacy_policy: number
    id_user: number
  }

  export type User_accepted_privacy_policyMinAggregateOutputType = {
    id: number
    accepted_date: Date | null
    id_privacy_policy: number
    id_user: number
  }

  export type User_accepted_privacy_policyMaxAggregateOutputType = {
    id: number
    accepted_date: Date | null
    id_privacy_policy: number
    id_user: number
  }

  export type User_accepted_privacy_policyCountAggregateOutputType = {
    id: number
    accepted_date: number | null
    id_privacy_policy: number
    id_user: number
    _all: number
  }


  export type User_accepted_privacy_policyAvgAggregateInputType = {
    id?: true
    id_privacy_policy?: true
    id_user?: true
  }

  export type User_accepted_privacy_policySumAggregateInputType = {
    id?: true
    id_privacy_policy?: true
    id_user?: true
  }

  export type User_accepted_privacy_policyMinAggregateInputType = {
    id?: true
    accepted_date?: true
    id_privacy_policy?: true
    id_user?: true
  }

  export type User_accepted_privacy_policyMaxAggregateInputType = {
    id?: true
    accepted_date?: true
    id_privacy_policy?: true
    id_user?: true
  }

  export type User_accepted_privacy_policyCountAggregateInputType = {
    id?: true
    accepted_date?: true
    id_privacy_policy?: true
    id_user?: true
    _all?: true
  }

  export type AggregateUser_accepted_privacy_policyArgs = {
    where?: user_accepted_privacy_policyWhereInput
    orderBy?: Enumerable<user_accepted_privacy_policyOrderByInput>
    cursor?: user_accepted_privacy_policyWhereUniqueInput
    take?: number
    skip?: number
    count?: true
    avg?: User_accepted_privacy_policyAvgAggregateInputType
    sum?: User_accepted_privacy_policySumAggregateInputType
    min?: User_accepted_privacy_policyMinAggregateInputType
    max?: User_accepted_privacy_policyMaxAggregateInputType
  }

  export type GetUser_accepted_privacy_policyAggregateType<T extends AggregateUser_accepted_privacy_policyArgs> = {
    [P in keyof T]: P extends 'count' ? number : GetUser_accepted_privacy_policyAggregateScalarType<T[P]>
  }

  export type GetUser_accepted_privacy_policyAggregateScalarType<T extends any> = {
    [P in keyof T]: P extends keyof User_accepted_privacy_policyAvgAggregateOutputType ? User_accepted_privacy_policyAvgAggregateOutputType[P] : never
  }

    



  export type user_accepted_privacy_policySelect = {
    id?: boolean
    accepted_date?: boolean
    id_privacy_policy?: boolean
    id_user?: boolean
    privacy_policy?: boolean | privacy_policyArgs
    user?: boolean | userArgs
  }

  export type user_accepted_privacy_policyInclude = {
    privacy_policy?: boolean | privacy_policyArgs
    user?: boolean | userArgs
  }

  export type user_accepted_privacy_policyGetPayload<
    S extends boolean | null | undefined | user_accepted_privacy_policyArgs,
    U = keyof S
      > = S extends true
        ? user_accepted_privacy_policy
    : S extends undefined
    ? never
    : S extends user_accepted_privacy_policyArgs | FindManyuser_accepted_privacy_policyArgs
    ?'include' extends U
    ? user_accepted_privacy_policy  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'privacy_policy'
        ? privacy_policyGetPayload<S['include'][P]> :
        P extends 'user'
        ? userGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof user_accepted_privacy_policy ?user_accepted_privacy_policy [P]
  : 
          P extends 'privacy_policy'
        ? privacy_policyGetPayload<S['select'][P]> :
        P extends 'user'
        ? userGetPayload<S['select'][P]> : never
  } 
    : user_accepted_privacy_policy
  : user_accepted_privacy_policy


  export interface user_accepted_privacy_policyDelegate {
    /**
     * Find zero or one User_accepted_privacy_policy that matches the filter.
     * @param {FindUniqueuser_accepted_privacy_policyArgs} args - Arguments to find a User_accepted_privacy_policy
     * @example
     * // Get one User_accepted_privacy_policy
     * const user_accepted_privacy_policy = await prisma.user_accepted_privacy_policy.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FindUniqueuser_accepted_privacy_policyArgs>(
      args: Subset<T, FindUniqueuser_accepted_privacy_policyArgs>
    ): CheckSelect<T, Prisma__user_accepted_privacy_policyClient<user_accepted_privacy_policy | null>, Prisma__user_accepted_privacy_policyClient<user_accepted_privacy_policyGetPayload<T> | null>>
    /**
     * Find the first User_accepted_privacy_policy that matches the filter.
     * @param {FindFirstuser_accepted_privacy_policyArgs} args - Arguments to find a User_accepted_privacy_policy
     * @example
     * // Get one User_accepted_privacy_policy
     * const user_accepted_privacy_policy = await prisma.user_accepted_privacy_policy.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FindFirstuser_accepted_privacy_policyArgs>(
      args?: Subset<T, FindFirstuser_accepted_privacy_policyArgs>
    ): CheckSelect<T, Prisma__user_accepted_privacy_policyClient<user_accepted_privacy_policy | null>, Prisma__user_accepted_privacy_policyClient<user_accepted_privacy_policyGetPayload<T> | null>>
    /**
     * Find zero or more User_accepted_privacy_policies that matches the filter.
     * @param {FindManyuser_accepted_privacy_policyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_accepted_privacy_policies
     * const user_accepted_privacy_policies = await prisma.user_accepted_privacy_policy.findMany()
     * 
     * // Get first 10 User_accepted_privacy_policies
     * const user_accepted_privacy_policies = await prisma.user_accepted_privacy_policy.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const user_accepted_privacy_policyWithIdOnly = await prisma.user_accepted_privacy_policy.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FindManyuser_accepted_privacy_policyArgs>(
      args?: Subset<T, FindManyuser_accepted_privacy_policyArgs>
    ): CheckSelect<T, Promise<Array<user_accepted_privacy_policy>>, Promise<Array<user_accepted_privacy_policyGetPayload<T>>>>
    /**
     * Create a User_accepted_privacy_policy.
     * @param {user_accepted_privacy_policyCreateArgs} args - Arguments to create a User_accepted_privacy_policy.
     * @example
     * // Create one User_accepted_privacy_policy
     * const User_accepted_privacy_policy = await prisma.user_accepted_privacy_policy.create({
     *   data: {
     *     // ... data to create a User_accepted_privacy_policy
     *   }
     * })
     * 
    **/
    create<T extends user_accepted_privacy_policyCreateArgs>(
      args: Subset<T, user_accepted_privacy_policyCreateArgs>
    ): CheckSelect<T, Prisma__user_accepted_privacy_policyClient<user_accepted_privacy_policy>, Prisma__user_accepted_privacy_policyClient<user_accepted_privacy_policyGetPayload<T>>>
    /**
     * Delete a User_accepted_privacy_policy.
     * @param {user_accepted_privacy_policyDeleteArgs} args - Arguments to delete one User_accepted_privacy_policy.
     * @example
     * // Delete one User_accepted_privacy_policy
     * const User_accepted_privacy_policy = await prisma.user_accepted_privacy_policy.delete({
     *   where: {
     *     // ... filter to delete one User_accepted_privacy_policy
     *   }
     * })
     * 
    **/
    delete<T extends user_accepted_privacy_policyDeleteArgs>(
      args: Subset<T, user_accepted_privacy_policyDeleteArgs>
    ): CheckSelect<T, Prisma__user_accepted_privacy_policyClient<user_accepted_privacy_policy>, Prisma__user_accepted_privacy_policyClient<user_accepted_privacy_policyGetPayload<T>>>
    /**
     * Update one User_accepted_privacy_policy.
     * @param {user_accepted_privacy_policyUpdateArgs} args - Arguments to update one User_accepted_privacy_policy.
     * @example
     * // Update one User_accepted_privacy_policy
     * const user_accepted_privacy_policy = await prisma.user_accepted_privacy_policy.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends user_accepted_privacy_policyUpdateArgs>(
      args: Subset<T, user_accepted_privacy_policyUpdateArgs>
    ): CheckSelect<T, Prisma__user_accepted_privacy_policyClient<user_accepted_privacy_policy>, Prisma__user_accepted_privacy_policyClient<user_accepted_privacy_policyGetPayload<T>>>
    /**
     * Delete zero or more User_accepted_privacy_policies.
     * @param {user_accepted_privacy_policyDeleteManyArgs} args - Arguments to filter User_accepted_privacy_policies to delete.
     * @example
     * // Delete a few User_accepted_privacy_policies
     * const { count } = await prisma.user_accepted_privacy_policy.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends user_accepted_privacy_policyDeleteManyArgs>(
      args?: Subset<T, user_accepted_privacy_policyDeleteManyArgs>
    ): Promise<BatchPayload>
    /**
     * Update zero or more User_accepted_privacy_policies.
     * @param {user_accepted_privacy_policyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_accepted_privacy_policies
     * const user_accepted_privacy_policy = await prisma.user_accepted_privacy_policy.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends user_accepted_privacy_policyUpdateManyArgs>(
      args: Subset<T, user_accepted_privacy_policyUpdateManyArgs>
    ): Promise<BatchPayload>
    /**
     * Create or update one User_accepted_privacy_policy.
     * @param {user_accepted_privacy_policyUpsertArgs} args - Arguments to update or create a User_accepted_privacy_policy.
     * @example
     * // Update or create a User_accepted_privacy_policy
     * const user_accepted_privacy_policy = await prisma.user_accepted_privacy_policy.upsert({
     *   create: {
     *     // ... data to create a User_accepted_privacy_policy
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_accepted_privacy_policy we want to update
     *   }
     * })
    **/
    upsert<T extends user_accepted_privacy_policyUpsertArgs>(
      args: Subset<T, user_accepted_privacy_policyUpsertArgs>
    ): CheckSelect<T, Prisma__user_accepted_privacy_policyClient<user_accepted_privacy_policy>, Prisma__user_accepted_privacy_policyClient<user_accepted_privacy_policyGetPayload<T>>>
    /**
     * Find zero or one User_accepted_privacy_policy that matches the filter.
     * @param {FindUniqueuser_accepted_privacy_policyArgs} args - Arguments to find a User_accepted_privacy_policy
     * @deprecated This will be deprecated please use prisma.user_accepted_privacy_policy.findUnique
     * @example
     * // Get one User_accepted_privacy_policy
     * const user_accepted_privacy_policy = await prisma.user_accepted_privacy_policy.findOne({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findOne<T extends FindUniqueuser_accepted_privacy_policyArgs>(
      args: Subset<T, FindUniqueuser_accepted_privacy_policyArgs>
    ): CheckSelect<T, Prisma__user_accepted_privacy_policyClient<user_accepted_privacy_policy | null>, Prisma__user_accepted_privacy_policyClient<user_accepted_privacy_policyGetPayload<T> | null>>
    /**
     * Count
     */
    count(args?: Omit<FindManyuser_accepted_privacy_policyArgs, 'select' | 'include'>): Promise<number>

  

    /**
     * Aggregate
     */
    aggregate<T extends AggregateUser_accepted_privacy_policyArgs>(args: Subset<T, AggregateUser_accepted_privacy_policyArgs>): Promise<GetUser_accepted_privacy_policyAggregateType<T>>
  }

  /**
   * The delegate class that acts as a "Promise-like" for user_accepted_privacy_policy.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__user_accepted_privacy_policyClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    privacy_policy<T extends privacy_policyArgs = {}>(args?: Subset<T, privacy_policyArgs>): CheckSelect<T, Prisma__privacy_policyClient<privacy_policy | null>, Prisma__privacy_policyClient<privacy_policyGetPayload<T> | null>>;

    user<T extends userArgs = {}>(args?: Subset<T, userArgs>): CheckSelect<T, Prisma__userClient<user | null>, Prisma__userClient<userGetPayload<T> | null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * user_accepted_privacy_policy findUnique
   */
  export type FindUniqueuser_accepted_privacy_policyArgs = {
    /**
     * Select specific fields to fetch from the user_accepted_privacy_policy
    **/
    select?: user_accepted_privacy_policySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: user_accepted_privacy_policyInclude | null
    /**
     * Filter, which user_accepted_privacy_policy to fetch.
    **/
    where: user_accepted_privacy_policyWhereUniqueInput
  }


  /**
   * user_accepted_privacy_policy findFirst
   */
  export type FindFirstuser_accepted_privacy_policyArgs = {
    /**
     * Select specific fields to fetch from the user_accepted_privacy_policy
    **/
    select?: user_accepted_privacy_policySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: user_accepted_privacy_policyInclude | null
    /**
     * Filter, which user_accepted_privacy_policy to fetch.
    **/
    where?: user_accepted_privacy_policyWhereInput
    orderBy?: Enumerable<user_accepted_privacy_policyOrderByInput>
    cursor?: user_accepted_privacy_policyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<User_accepted_privacy_policyScalarFieldEnum>
  }


  /**
   * user_accepted_privacy_policy findMany
   */
  export type FindManyuser_accepted_privacy_policyArgs = {
    /**
     * Select specific fields to fetch from the user_accepted_privacy_policy
    **/
    select?: user_accepted_privacy_policySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: user_accepted_privacy_policyInclude | null
    /**
     * Filter, which user_accepted_privacy_policies to fetch.
    **/
    where?: user_accepted_privacy_policyWhereInput
    /**
     * Determine the order of the user_accepted_privacy_policies to fetch.
    **/
    orderBy?: Enumerable<user_accepted_privacy_policyOrderByInput>
    /**
     * Sets the position for listing user_accepted_privacy_policies.
    **/
    cursor?: user_accepted_privacy_policyWhereUniqueInput
    /**
     * The number of user_accepted_privacy_policies to fetch. If negative number, it will take user_accepted_privacy_policies before the `cursor`.
    **/
    take?: number
    /**
     * Skip the first `n` user_accepted_privacy_policies.
    **/
    skip?: number
    distinct?: Enumerable<User_accepted_privacy_policyScalarFieldEnum>
  }


  /**
   * user_accepted_privacy_policy create
   */
  export type user_accepted_privacy_policyCreateArgs = {
    /**
     * Select specific fields to fetch from the user_accepted_privacy_policy
    **/
    select?: user_accepted_privacy_policySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: user_accepted_privacy_policyInclude | null
    /**
     * The data needed to create a user_accepted_privacy_policy.
    **/
    data: user_accepted_privacy_policyCreateInput
  }


  /**
   * user_accepted_privacy_policy update
   */
  export type user_accepted_privacy_policyUpdateArgs = {
    /**
     * Select specific fields to fetch from the user_accepted_privacy_policy
    **/
    select?: user_accepted_privacy_policySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: user_accepted_privacy_policyInclude | null
    /**
     * The data needed to update a user_accepted_privacy_policy.
    **/
    data: user_accepted_privacy_policyUpdateInput
    /**
     * Choose, which user_accepted_privacy_policy to update.
    **/
    where: user_accepted_privacy_policyWhereUniqueInput
  }


  /**
   * user_accepted_privacy_policy updateMany
   */
  export type user_accepted_privacy_policyUpdateManyArgs = {
    data: user_accepted_privacy_policyUpdateManyMutationInput
    where?: user_accepted_privacy_policyWhereInput
  }


  /**
   * user_accepted_privacy_policy upsert
   */
  export type user_accepted_privacy_policyUpsertArgs = {
    /**
     * Select specific fields to fetch from the user_accepted_privacy_policy
    **/
    select?: user_accepted_privacy_policySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: user_accepted_privacy_policyInclude | null
    /**
     * The filter to search for the user_accepted_privacy_policy to update in case it exists.
    **/
    where: user_accepted_privacy_policyWhereUniqueInput
    /**
     * In case the user_accepted_privacy_policy found by the `where` argument doesn't exist, create a new user_accepted_privacy_policy with this data.
    **/
    create: user_accepted_privacy_policyCreateInput
    /**
     * In case the user_accepted_privacy_policy was found with the provided `where` argument, update it with this data.
    **/
    update: user_accepted_privacy_policyUpdateInput
  }


  /**
   * user_accepted_privacy_policy delete
   */
  export type user_accepted_privacy_policyDeleteArgs = {
    /**
     * Select specific fields to fetch from the user_accepted_privacy_policy
    **/
    select?: user_accepted_privacy_policySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: user_accepted_privacy_policyInclude | null
    /**
     * Filter which user_accepted_privacy_policy to delete.
    **/
    where: user_accepted_privacy_policyWhereUniqueInput
  }


  /**
   * user_accepted_privacy_policy deleteMany
   */
  export type user_accepted_privacy_policyDeleteManyArgs = {
    where?: user_accepted_privacy_policyWhereInput
  }


  /**
   * user_accepted_privacy_policy without action
   */
  export type user_accepted_privacy_policyArgs = {
    /**
     * Select specific fields to fetch from the user_accepted_privacy_policy
    **/
    select?: user_accepted_privacy_policySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: user_accepted_privacy_policyInclude | null
  }



  /**
   * Model user_accepted_terms
   */


  export type AggregateUser_accepted_terms = {
    count: number | null
    avg: User_accepted_termsAvgAggregateOutputType | null
    sum: User_accepted_termsSumAggregateOutputType | null
    min: User_accepted_termsMinAggregateOutputType | null
    max: User_accepted_termsMaxAggregateOutputType | null
  }

  export type User_accepted_termsAvgAggregateOutputType = {
    id: number
    id_user: number
    id_terms_and_conditions: number
  }

  export type User_accepted_termsSumAggregateOutputType = {
    id: number
    id_user: number
    id_terms_and_conditions: number
  }

  export type User_accepted_termsMinAggregateOutputType = {
    id: number
    accepted_date: Date | null
    id_user: number
    id_terms_and_conditions: number
  }

  export type User_accepted_termsMaxAggregateOutputType = {
    id: number
    accepted_date: Date | null
    id_user: number
    id_terms_and_conditions: number
  }

  export type User_accepted_termsCountAggregateOutputType = {
    id: number
    accepted_date: number | null
    id_user: number
    id_terms_and_conditions: number
    _all: number
  }


  export type User_accepted_termsAvgAggregateInputType = {
    id?: true
    id_user?: true
    id_terms_and_conditions?: true
  }

  export type User_accepted_termsSumAggregateInputType = {
    id?: true
    id_user?: true
    id_terms_and_conditions?: true
  }

  export type User_accepted_termsMinAggregateInputType = {
    id?: true
    accepted_date?: true
    id_user?: true
    id_terms_and_conditions?: true
  }

  export type User_accepted_termsMaxAggregateInputType = {
    id?: true
    accepted_date?: true
    id_user?: true
    id_terms_and_conditions?: true
  }

  export type User_accepted_termsCountAggregateInputType = {
    id?: true
    accepted_date?: true
    id_user?: true
    id_terms_and_conditions?: true
    _all?: true
  }

  export type AggregateUser_accepted_termsArgs = {
    where?: user_accepted_termsWhereInput
    orderBy?: Enumerable<user_accepted_termsOrderByInput>
    cursor?: user_accepted_termsWhereUniqueInput
    take?: number
    skip?: number
    count?: true
    avg?: User_accepted_termsAvgAggregateInputType
    sum?: User_accepted_termsSumAggregateInputType
    min?: User_accepted_termsMinAggregateInputType
    max?: User_accepted_termsMaxAggregateInputType
  }

  export type GetUser_accepted_termsAggregateType<T extends AggregateUser_accepted_termsArgs> = {
    [P in keyof T]: P extends 'count' ? number : GetUser_accepted_termsAggregateScalarType<T[P]>
  }

  export type GetUser_accepted_termsAggregateScalarType<T extends any> = {
    [P in keyof T]: P extends keyof User_accepted_termsAvgAggregateOutputType ? User_accepted_termsAvgAggregateOutputType[P] : never
  }

    



  export type user_accepted_termsSelect = {
    id?: boolean
    accepted_date?: boolean
    id_user?: boolean
    id_terms_and_conditions?: boolean
    terms_and_conditions?: boolean | terms_and_conditionsArgs
    user?: boolean | userArgs
  }

  export type user_accepted_termsInclude = {
    terms_and_conditions?: boolean | terms_and_conditionsArgs
    user?: boolean | userArgs
  }

  export type user_accepted_termsGetPayload<
    S extends boolean | null | undefined | user_accepted_termsArgs,
    U = keyof S
      > = S extends true
        ? user_accepted_terms
    : S extends undefined
    ? never
    : S extends user_accepted_termsArgs | FindManyuser_accepted_termsArgs
    ?'include' extends U
    ? user_accepted_terms  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'terms_and_conditions'
        ? terms_and_conditionsGetPayload<S['include'][P]> :
        P extends 'user'
        ? userGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof user_accepted_terms ?user_accepted_terms [P]
  : 
          P extends 'terms_and_conditions'
        ? terms_and_conditionsGetPayload<S['select'][P]> :
        P extends 'user'
        ? userGetPayload<S['select'][P]> : never
  } 
    : user_accepted_terms
  : user_accepted_terms


  export interface user_accepted_termsDelegate {
    /**
     * Find zero or one User_accepted_terms that matches the filter.
     * @param {FindUniqueuser_accepted_termsArgs} args - Arguments to find a User_accepted_terms
     * @example
     * // Get one User_accepted_terms
     * const user_accepted_terms = await prisma.user_accepted_terms.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FindUniqueuser_accepted_termsArgs>(
      args: Subset<T, FindUniqueuser_accepted_termsArgs>
    ): CheckSelect<T, Prisma__user_accepted_termsClient<user_accepted_terms | null>, Prisma__user_accepted_termsClient<user_accepted_termsGetPayload<T> | null>>
    /**
     * Find the first User_accepted_terms that matches the filter.
     * @param {FindFirstuser_accepted_termsArgs} args - Arguments to find a User_accepted_terms
     * @example
     * // Get one User_accepted_terms
     * const user_accepted_terms = await prisma.user_accepted_terms.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FindFirstuser_accepted_termsArgs>(
      args?: Subset<T, FindFirstuser_accepted_termsArgs>
    ): CheckSelect<T, Prisma__user_accepted_termsClient<user_accepted_terms | null>, Prisma__user_accepted_termsClient<user_accepted_termsGetPayload<T> | null>>
    /**
     * Find zero or more User_accepted_terms that matches the filter.
     * @param {FindManyuser_accepted_termsArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_accepted_terms
     * const user_accepted_terms = await prisma.user_accepted_terms.findMany()
     * 
     * // Get first 10 User_accepted_terms
     * const user_accepted_terms = await prisma.user_accepted_terms.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const user_accepted_termsWithIdOnly = await prisma.user_accepted_terms.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FindManyuser_accepted_termsArgs>(
      args?: Subset<T, FindManyuser_accepted_termsArgs>
    ): CheckSelect<T, Promise<Array<user_accepted_terms>>, Promise<Array<user_accepted_termsGetPayload<T>>>>
    /**
     * Create a User_accepted_terms.
     * @param {user_accepted_termsCreateArgs} args - Arguments to create a User_accepted_terms.
     * @example
     * // Create one User_accepted_terms
     * const User_accepted_terms = await prisma.user_accepted_terms.create({
     *   data: {
     *     // ... data to create a User_accepted_terms
     *   }
     * })
     * 
    **/
    create<T extends user_accepted_termsCreateArgs>(
      args: Subset<T, user_accepted_termsCreateArgs>
    ): CheckSelect<T, Prisma__user_accepted_termsClient<user_accepted_terms>, Prisma__user_accepted_termsClient<user_accepted_termsGetPayload<T>>>
    /**
     * Delete a User_accepted_terms.
     * @param {user_accepted_termsDeleteArgs} args - Arguments to delete one User_accepted_terms.
     * @example
     * // Delete one User_accepted_terms
     * const User_accepted_terms = await prisma.user_accepted_terms.delete({
     *   where: {
     *     // ... filter to delete one User_accepted_terms
     *   }
     * })
     * 
    **/
    delete<T extends user_accepted_termsDeleteArgs>(
      args: Subset<T, user_accepted_termsDeleteArgs>
    ): CheckSelect<T, Prisma__user_accepted_termsClient<user_accepted_terms>, Prisma__user_accepted_termsClient<user_accepted_termsGetPayload<T>>>
    /**
     * Update one User_accepted_terms.
     * @param {user_accepted_termsUpdateArgs} args - Arguments to update one User_accepted_terms.
     * @example
     * // Update one User_accepted_terms
     * const user_accepted_terms = await prisma.user_accepted_terms.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends user_accepted_termsUpdateArgs>(
      args: Subset<T, user_accepted_termsUpdateArgs>
    ): CheckSelect<T, Prisma__user_accepted_termsClient<user_accepted_terms>, Prisma__user_accepted_termsClient<user_accepted_termsGetPayload<T>>>
    /**
     * Delete zero or more User_accepted_terms.
     * @param {user_accepted_termsDeleteManyArgs} args - Arguments to filter User_accepted_terms to delete.
     * @example
     * // Delete a few User_accepted_terms
     * const { count } = await prisma.user_accepted_terms.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends user_accepted_termsDeleteManyArgs>(
      args?: Subset<T, user_accepted_termsDeleteManyArgs>
    ): Promise<BatchPayload>
    /**
     * Update zero or more User_accepted_terms.
     * @param {user_accepted_termsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_accepted_terms
     * const user_accepted_terms = await prisma.user_accepted_terms.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends user_accepted_termsUpdateManyArgs>(
      args: Subset<T, user_accepted_termsUpdateManyArgs>
    ): Promise<BatchPayload>
    /**
     * Create or update one User_accepted_terms.
     * @param {user_accepted_termsUpsertArgs} args - Arguments to update or create a User_accepted_terms.
     * @example
     * // Update or create a User_accepted_terms
     * const user_accepted_terms = await prisma.user_accepted_terms.upsert({
     *   create: {
     *     // ... data to create a User_accepted_terms
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_accepted_terms we want to update
     *   }
     * })
    **/
    upsert<T extends user_accepted_termsUpsertArgs>(
      args: Subset<T, user_accepted_termsUpsertArgs>
    ): CheckSelect<T, Prisma__user_accepted_termsClient<user_accepted_terms>, Prisma__user_accepted_termsClient<user_accepted_termsGetPayload<T>>>
    /**
     * Find zero or one User_accepted_terms that matches the filter.
     * @param {FindUniqueuser_accepted_termsArgs} args - Arguments to find a User_accepted_terms
     * @deprecated This will be deprecated please use prisma.user_accepted_terms.findUnique
     * @example
     * // Get one User_accepted_terms
     * const user_accepted_terms = await prisma.user_accepted_terms.findOne({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findOne<T extends FindUniqueuser_accepted_termsArgs>(
      args: Subset<T, FindUniqueuser_accepted_termsArgs>
    ): CheckSelect<T, Prisma__user_accepted_termsClient<user_accepted_terms | null>, Prisma__user_accepted_termsClient<user_accepted_termsGetPayload<T> | null>>
    /**
     * Count
     */
    count(args?: Omit<FindManyuser_accepted_termsArgs, 'select' | 'include'>): Promise<number>

  

    /**
     * Aggregate
     */
    aggregate<T extends AggregateUser_accepted_termsArgs>(args: Subset<T, AggregateUser_accepted_termsArgs>): Promise<GetUser_accepted_termsAggregateType<T>>
  }

  /**
   * The delegate class that acts as a "Promise-like" for user_accepted_terms.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__user_accepted_termsClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    terms_and_conditions<T extends terms_and_conditionsArgs = {}>(args?: Subset<T, terms_and_conditionsArgs>): CheckSelect<T, Prisma__terms_and_conditionsClient<terms_and_conditions | null>, Prisma__terms_and_conditionsClient<terms_and_conditionsGetPayload<T> | null>>;

    user<T extends userArgs = {}>(args?: Subset<T, userArgs>): CheckSelect<T, Prisma__userClient<user | null>, Prisma__userClient<userGetPayload<T> | null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * user_accepted_terms findUnique
   */
  export type FindUniqueuser_accepted_termsArgs = {
    /**
     * Select specific fields to fetch from the user_accepted_terms
    **/
    select?: user_accepted_termsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: user_accepted_termsInclude | null
    /**
     * Filter, which user_accepted_terms to fetch.
    **/
    where: user_accepted_termsWhereUniqueInput
  }


  /**
   * user_accepted_terms findFirst
   */
  export type FindFirstuser_accepted_termsArgs = {
    /**
     * Select specific fields to fetch from the user_accepted_terms
    **/
    select?: user_accepted_termsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: user_accepted_termsInclude | null
    /**
     * Filter, which user_accepted_terms to fetch.
    **/
    where?: user_accepted_termsWhereInput
    orderBy?: Enumerable<user_accepted_termsOrderByInput>
    cursor?: user_accepted_termsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<User_accepted_termsScalarFieldEnum>
  }


  /**
   * user_accepted_terms findMany
   */
  export type FindManyuser_accepted_termsArgs = {
    /**
     * Select specific fields to fetch from the user_accepted_terms
    **/
    select?: user_accepted_termsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: user_accepted_termsInclude | null
    /**
     * Filter, which user_accepted_terms to fetch.
    **/
    where?: user_accepted_termsWhereInput
    /**
     * Determine the order of the user_accepted_terms to fetch.
    **/
    orderBy?: Enumerable<user_accepted_termsOrderByInput>
    /**
     * Sets the position for listing user_accepted_terms.
    **/
    cursor?: user_accepted_termsWhereUniqueInput
    /**
     * The number of user_accepted_terms to fetch. If negative number, it will take user_accepted_terms before the `cursor`.
    **/
    take?: number
    /**
     * Skip the first `n` user_accepted_terms.
    **/
    skip?: number
    distinct?: Enumerable<User_accepted_termsScalarFieldEnum>
  }


  /**
   * user_accepted_terms create
   */
  export type user_accepted_termsCreateArgs = {
    /**
     * Select specific fields to fetch from the user_accepted_terms
    **/
    select?: user_accepted_termsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: user_accepted_termsInclude | null
    /**
     * The data needed to create a user_accepted_terms.
    **/
    data: user_accepted_termsCreateInput
  }


  /**
   * user_accepted_terms update
   */
  export type user_accepted_termsUpdateArgs = {
    /**
     * Select specific fields to fetch from the user_accepted_terms
    **/
    select?: user_accepted_termsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: user_accepted_termsInclude | null
    /**
     * The data needed to update a user_accepted_terms.
    **/
    data: user_accepted_termsUpdateInput
    /**
     * Choose, which user_accepted_terms to update.
    **/
    where: user_accepted_termsWhereUniqueInput
  }


  /**
   * user_accepted_terms updateMany
   */
  export type user_accepted_termsUpdateManyArgs = {
    data: user_accepted_termsUpdateManyMutationInput
    where?: user_accepted_termsWhereInput
  }


  /**
   * user_accepted_terms upsert
   */
  export type user_accepted_termsUpsertArgs = {
    /**
     * Select specific fields to fetch from the user_accepted_terms
    **/
    select?: user_accepted_termsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: user_accepted_termsInclude | null
    /**
     * The filter to search for the user_accepted_terms to update in case it exists.
    **/
    where: user_accepted_termsWhereUniqueInput
    /**
     * In case the user_accepted_terms found by the `where` argument doesn't exist, create a new user_accepted_terms with this data.
    **/
    create: user_accepted_termsCreateInput
    /**
     * In case the user_accepted_terms was found with the provided `where` argument, update it with this data.
    **/
    update: user_accepted_termsUpdateInput
  }


  /**
   * user_accepted_terms delete
   */
  export type user_accepted_termsDeleteArgs = {
    /**
     * Select specific fields to fetch from the user_accepted_terms
    **/
    select?: user_accepted_termsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: user_accepted_termsInclude | null
    /**
     * Filter which user_accepted_terms to delete.
    **/
    where: user_accepted_termsWhereUniqueInput
  }


  /**
   * user_accepted_terms deleteMany
   */
  export type user_accepted_termsDeleteManyArgs = {
    where?: user_accepted_termsWhereInput
  }


  /**
   * user_accepted_terms without action
   */
  export type user_accepted_termsArgs = {
    /**
     * Select specific fields to fetch from the user_accepted_terms
    **/
    select?: user_accepted_termsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: user_accepted_termsInclude | null
  }



  /**
   * Model user_role
   */


  export type AggregateUser_role = {
    count: number | null
    avg: User_roleAvgAggregateOutputType | null
    sum: User_roleSumAggregateOutputType | null
    min: User_roleMinAggregateOutputType | null
    max: User_roleMaxAggregateOutputType | null
  }

  export type User_roleAvgAggregateOutputType = {
    id: number
    user_id: number
    role_id: number
  }

  export type User_roleSumAggregateOutputType = {
    id: number
    user_id: number
    role_id: number
  }

  export type User_roleMinAggregateOutputType = {
    id: number
    user_id: number
    role_id: number
  }

  export type User_roleMaxAggregateOutputType = {
    id: number
    user_id: number
    role_id: number
  }

  export type User_roleCountAggregateOutputType = {
    id: number
    user_id: number
    role_id: number
    _all: number
  }


  export type User_roleAvgAggregateInputType = {
    id?: true
    user_id?: true
    role_id?: true
  }

  export type User_roleSumAggregateInputType = {
    id?: true
    user_id?: true
    role_id?: true
  }

  export type User_roleMinAggregateInputType = {
    id?: true
    user_id?: true
    role_id?: true
  }

  export type User_roleMaxAggregateInputType = {
    id?: true
    user_id?: true
    role_id?: true
  }

  export type User_roleCountAggregateInputType = {
    id?: true
    user_id?: true
    role_id?: true
    _all?: true
  }

  export type AggregateUser_roleArgs = {
    where?: user_roleWhereInput
    orderBy?: Enumerable<user_roleOrderByInput>
    cursor?: user_roleWhereUniqueInput
    take?: number
    skip?: number
    count?: true
    avg?: User_roleAvgAggregateInputType
    sum?: User_roleSumAggregateInputType
    min?: User_roleMinAggregateInputType
    max?: User_roleMaxAggregateInputType
  }

  export type GetUser_roleAggregateType<T extends AggregateUser_roleArgs> = {
    [P in keyof T]: P extends 'count' ? number : GetUser_roleAggregateScalarType<T[P]>
  }

  export type GetUser_roleAggregateScalarType<T extends any> = {
    [P in keyof T]: P extends keyof User_roleAvgAggregateOutputType ? User_roleAvgAggregateOutputType[P] : never
  }

    



  export type user_roleSelect = {
    id?: boolean
    user_id?: boolean
    role_id?: boolean
    role?: boolean | roleArgs
    user?: boolean | userArgs
  }

  export type user_roleInclude = {
    role?: boolean | roleArgs
    user?: boolean | userArgs
  }

  export type user_roleGetPayload<
    S extends boolean | null | undefined | user_roleArgs,
    U = keyof S
      > = S extends true
        ? user_role
    : S extends undefined
    ? never
    : S extends user_roleArgs | FindManyuser_roleArgs
    ?'include' extends U
    ? user_role  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'role'
        ? roleGetPayload<S['include'][P]> :
        P extends 'user'
        ? userGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof user_role ?user_role [P]
  : 
          P extends 'role'
        ? roleGetPayload<S['select'][P]> :
        P extends 'user'
        ? userGetPayload<S['select'][P]> : never
  } 
    : user_role
  : user_role


  export interface user_roleDelegate {
    /**
     * Find zero or one User_role that matches the filter.
     * @param {FindUniqueuser_roleArgs} args - Arguments to find a User_role
     * @example
     * // Get one User_role
     * const user_role = await prisma.user_role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FindUniqueuser_roleArgs>(
      args: Subset<T, FindUniqueuser_roleArgs>
    ): CheckSelect<T, Prisma__user_roleClient<user_role | null>, Prisma__user_roleClient<user_roleGetPayload<T> | null>>
    /**
     * Find the first User_role that matches the filter.
     * @param {FindFirstuser_roleArgs} args - Arguments to find a User_role
     * @example
     * // Get one User_role
     * const user_role = await prisma.user_role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FindFirstuser_roleArgs>(
      args?: Subset<T, FindFirstuser_roleArgs>
    ): CheckSelect<T, Prisma__user_roleClient<user_role | null>, Prisma__user_roleClient<user_roleGetPayload<T> | null>>
    /**
     * Find zero or more User_roles that matches the filter.
     * @param {FindManyuser_roleArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_roles
     * const user_roles = await prisma.user_role.findMany()
     * 
     * // Get first 10 User_roles
     * const user_roles = await prisma.user_role.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const user_roleWithIdOnly = await prisma.user_role.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FindManyuser_roleArgs>(
      args?: Subset<T, FindManyuser_roleArgs>
    ): CheckSelect<T, Promise<Array<user_role>>, Promise<Array<user_roleGetPayload<T>>>>
    /**
     * Create a User_role.
     * @param {user_roleCreateArgs} args - Arguments to create a User_role.
     * @example
     * // Create one User_role
     * const User_role = await prisma.user_role.create({
     *   data: {
     *     // ... data to create a User_role
     *   }
     * })
     * 
    **/
    create<T extends user_roleCreateArgs>(
      args: Subset<T, user_roleCreateArgs>
    ): CheckSelect<T, Prisma__user_roleClient<user_role>, Prisma__user_roleClient<user_roleGetPayload<T>>>
    /**
     * Delete a User_role.
     * @param {user_roleDeleteArgs} args - Arguments to delete one User_role.
     * @example
     * // Delete one User_role
     * const User_role = await prisma.user_role.delete({
     *   where: {
     *     // ... filter to delete one User_role
     *   }
     * })
     * 
    **/
    delete<T extends user_roleDeleteArgs>(
      args: Subset<T, user_roleDeleteArgs>
    ): CheckSelect<T, Prisma__user_roleClient<user_role>, Prisma__user_roleClient<user_roleGetPayload<T>>>
    /**
     * Update one User_role.
     * @param {user_roleUpdateArgs} args - Arguments to update one User_role.
     * @example
     * // Update one User_role
     * const user_role = await prisma.user_role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends user_roleUpdateArgs>(
      args: Subset<T, user_roleUpdateArgs>
    ): CheckSelect<T, Prisma__user_roleClient<user_role>, Prisma__user_roleClient<user_roleGetPayload<T>>>
    /**
     * Delete zero or more User_roles.
     * @param {user_roleDeleteManyArgs} args - Arguments to filter User_roles to delete.
     * @example
     * // Delete a few User_roles
     * const { count } = await prisma.user_role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends user_roleDeleteManyArgs>(
      args?: Subset<T, user_roleDeleteManyArgs>
    ): Promise<BatchPayload>
    /**
     * Update zero or more User_roles.
     * @param {user_roleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_roles
     * const user_role = await prisma.user_role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends user_roleUpdateManyArgs>(
      args: Subset<T, user_roleUpdateManyArgs>
    ): Promise<BatchPayload>
    /**
     * Create or update one User_role.
     * @param {user_roleUpsertArgs} args - Arguments to update or create a User_role.
     * @example
     * // Update or create a User_role
     * const user_role = await prisma.user_role.upsert({
     *   create: {
     *     // ... data to create a User_role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_role we want to update
     *   }
     * })
    **/
    upsert<T extends user_roleUpsertArgs>(
      args: Subset<T, user_roleUpsertArgs>
    ): CheckSelect<T, Prisma__user_roleClient<user_role>, Prisma__user_roleClient<user_roleGetPayload<T>>>
    /**
     * Find zero or one User_role that matches the filter.
     * @param {FindUniqueuser_roleArgs} args - Arguments to find a User_role
     * @deprecated This will be deprecated please use prisma.user_role.findUnique
     * @example
     * // Get one User_role
     * const user_role = await prisma.user_role.findOne({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findOne<T extends FindUniqueuser_roleArgs>(
      args: Subset<T, FindUniqueuser_roleArgs>
    ): CheckSelect<T, Prisma__user_roleClient<user_role | null>, Prisma__user_roleClient<user_roleGetPayload<T> | null>>
    /**
     * Count
     */
    count(args?: Omit<FindManyuser_roleArgs, 'select' | 'include'>): Promise<number>

  

    /**
     * Aggregate
     */
    aggregate<T extends AggregateUser_roleArgs>(args: Subset<T, AggregateUser_roleArgs>): Promise<GetUser_roleAggregateType<T>>
  }

  /**
   * The delegate class that acts as a "Promise-like" for user_role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__user_roleClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    role<T extends roleArgs = {}>(args?: Subset<T, roleArgs>): CheckSelect<T, Prisma__roleClient<role | null>, Prisma__roleClient<roleGetPayload<T> | null>>;

    user<T extends userArgs = {}>(args?: Subset<T, userArgs>): CheckSelect<T, Prisma__userClient<user | null>, Prisma__userClient<userGetPayload<T> | null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * user_role findUnique
   */
  export type FindUniqueuser_roleArgs = {
    /**
     * Select specific fields to fetch from the user_role
    **/
    select?: user_roleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: user_roleInclude | null
    /**
     * Filter, which user_role to fetch.
    **/
    where: user_roleWhereUniqueInput
  }


  /**
   * user_role findFirst
   */
  export type FindFirstuser_roleArgs = {
    /**
     * Select specific fields to fetch from the user_role
    **/
    select?: user_roleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: user_roleInclude | null
    /**
     * Filter, which user_role to fetch.
    **/
    where?: user_roleWhereInput
    orderBy?: Enumerable<user_roleOrderByInput>
    cursor?: user_roleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<User_roleScalarFieldEnum>
  }


  /**
   * user_role findMany
   */
  export type FindManyuser_roleArgs = {
    /**
     * Select specific fields to fetch from the user_role
    **/
    select?: user_roleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: user_roleInclude | null
    /**
     * Filter, which user_roles to fetch.
    **/
    where?: user_roleWhereInput
    /**
     * Determine the order of the user_roles to fetch.
    **/
    orderBy?: Enumerable<user_roleOrderByInput>
    /**
     * Sets the position for listing user_roles.
    **/
    cursor?: user_roleWhereUniqueInput
    /**
     * The number of user_roles to fetch. If negative number, it will take user_roles before the `cursor`.
    **/
    take?: number
    /**
     * Skip the first `n` user_roles.
    **/
    skip?: number
    distinct?: Enumerable<User_roleScalarFieldEnum>
  }


  /**
   * user_role create
   */
  export type user_roleCreateArgs = {
    /**
     * Select specific fields to fetch from the user_role
    **/
    select?: user_roleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: user_roleInclude | null
    /**
     * The data needed to create a user_role.
    **/
    data: user_roleCreateInput
  }


  /**
   * user_role update
   */
  export type user_roleUpdateArgs = {
    /**
     * Select specific fields to fetch from the user_role
    **/
    select?: user_roleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: user_roleInclude | null
    /**
     * The data needed to update a user_role.
    **/
    data: user_roleUpdateInput
    /**
     * Choose, which user_role to update.
    **/
    where: user_roleWhereUniqueInput
  }


  /**
   * user_role updateMany
   */
  export type user_roleUpdateManyArgs = {
    data: user_roleUpdateManyMutationInput
    where?: user_roleWhereInput
  }


  /**
   * user_role upsert
   */
  export type user_roleUpsertArgs = {
    /**
     * Select specific fields to fetch from the user_role
    **/
    select?: user_roleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: user_roleInclude | null
    /**
     * The filter to search for the user_role to update in case it exists.
    **/
    where: user_roleWhereUniqueInput
    /**
     * In case the user_role found by the `where` argument doesn't exist, create a new user_role with this data.
    **/
    create: user_roleCreateInput
    /**
     * In case the user_role was found with the provided `where` argument, update it with this data.
    **/
    update: user_roleUpdateInput
  }


  /**
   * user_role delete
   */
  export type user_roleDeleteArgs = {
    /**
     * Select specific fields to fetch from the user_role
    **/
    select?: user_roleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: user_roleInclude | null
    /**
     * Filter which user_role to delete.
    **/
    where: user_roleWhereUniqueInput
  }


  /**
   * user_role deleteMany
   */
  export type user_roleDeleteManyArgs = {
    where?: user_roleWhereInput
  }


  /**
   * user_role without action
   */
  export type user_roleArgs = {
    /**
     * Select specific fields to fetch from the user_role
    **/
    select?: user_roleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: user_roleInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const AddressScalarFieldEnum: {
    id: 'id',
    street: 'street',
    city: 'city',
    number: 'number',
    km: 'km',
    postal_code: 'postal_code',
    complement: 'complement',
    neighborhood: 'neighborhood',
    phone_number: 'phone_number',
    contact_name: 'contact_name',
    state_id: 'state_id',
    mobile_number: 'mobile_number',
    email: 'email'
  };

  export type AddressScalarFieldEnum = (typeof AddressScalarFieldEnum)[keyof typeof AddressScalarFieldEnum]


  export const AreaScalarFieldEnum: {
    id: 'id',
    code: 'code',
    lat: 'lat',
    long: 'long',
    coordinates: 'coordinates',
    name: 'name',
    zone: 'zone',
    state_initials: 'state_initials',
    city: 'city',
    farm_id: 'farm_id',
    demand: 'demand'
  };

  export type AreaScalarFieldEnum = (typeof AreaScalarFieldEnum)[keyof typeof AreaScalarFieldEnum]


  export const CompanyScalarFieldEnum: {
    id: 'id',
    name: 'name',
    works_with_drone: 'works_with_drone',
    works_with_plane: 'works_with_plane',
    works_with_tractor: 'works_with_tractor',
    lat: 'lat',
    long: 'long',
    address_id: 'address_id'
  };

  export type CompanyScalarFieldEnum = (typeof CompanyScalarFieldEnum)[keyof typeof CompanyScalarFieldEnum]


  export const CropScalarFieldEnum: {
    id: 'id',
    crop_type: 'crop_type',
    variety: 'variety',
    sowing_date: 'sowing_date',
    expected_harvest_date: 'expected_harvest_date',
    number: 'number',
    is_diagnosis_hired: 'is_diagnosis_hired',
    field_id: 'field_id'
  };

  export type CropScalarFieldEnum = (typeof CropScalarFieldEnum)[keyof typeof CropScalarFieldEnum]


  export const DiagnosisScalarFieldEnum: {
    id: 'id',
    report_date: 'report_date',
    affected_area_ha: 'affected_area_ha',
    crop_id: 'crop_id'
  };

  export type DiagnosisScalarFieldEnum = (typeof DiagnosisScalarFieldEnum)[keyof typeof DiagnosisScalarFieldEnum]


  export const EmailScalarFieldEnum: {
    id: 'id',
    email: 'email'
  };

  export type EmailScalarFieldEnum = (typeof EmailScalarFieldEnum)[keyof typeof EmailScalarFieldEnum]


  export const FarmScalarFieldEnum: {
    id: 'id',
    cnpj: 'cnpj',
    social_name: 'social_name',
    fantasy_name: 'fantasy_name',
    lat: 'lat',
    long: 'long',
    address_id: 'address_id'
  };

  export type FarmScalarFieldEnum = (typeof FarmScalarFieldEnum)[keyof typeof FarmScalarFieldEnum]


  export const FieldScalarFieldEnum: {
    id: 'id',
    code: 'code',
    area_ha: 'area_ha',
    lat: 'lat',
    long: 'long',
    coordinates: 'coordinates',
    name: 'name',
    image_uri: 'image_uri',
    area_id: 'area_id',
    visiona_area_id: 'visiona_area_id',
    event: 'event'
  };

  export type FieldScalarFieldEnum = (typeof FieldScalarFieldEnum)[keyof typeof FieldScalarFieldEnum]


  export const ImagingScalarFieldEnum: {
    id: 'id',
    directory: 'directory',
    processing_timestamp: 'processing_timestamp',
    imaging_date: 'imaging_date',
    farm_id: 'farm_id'
  };

  export type ImagingScalarFieldEnum = (typeof ImagingScalarFieldEnum)[keyof typeof ImagingScalarFieldEnum]


  export const InfestationScalarFieldEnum: {
    id: 'id',
    area_ha: 'area_ha',
    points: 'points',
    diagnosis_id: 'diagnosis_id',
    plague_id: 'plague_id'
  };

  export type InfestationScalarFieldEnum = (typeof InfestationScalarFieldEnum)[keyof typeof InfestationScalarFieldEnum]


  export const Many_quotation_modal_package_has_many_fieldScalarFieldEnum: {
    id_quotation_modal_package: 'id_quotation_modal_package',
    id_field: 'id_field'
  };

  export type Many_quotation_modal_package_has_many_fieldScalarFieldEnum = (typeof Many_quotation_modal_package_has_many_fieldScalarFieldEnum)[keyof typeof Many_quotation_modal_package_has_many_fieldScalarFieldEnum]


  export const Many_user_has_many_farmScalarFieldEnum: {
    user_id: 'user_id',
    farm_id: 'farm_id'
  };

  export type Many_user_has_many_farmScalarFieldEnum = (typeof Many_user_has_many_farmScalarFieldEnum)[keyof typeof Many_user_has_many_farmScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    type: 'type',
    body: 'body',
    sent_date: 'sent_date',
    read_date: 'read_date',
    delivered_date: 'delivered_date',
    user_id: 'user_id'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const PlagueScalarFieldEnum: {
    id: 'id',
    name: 'name',
    display_name: 'display_name',
    color: 'color',
    in_use: 'in_use',
    relevance_order: 'relevance_order'
  };

  export type PlagueScalarFieldEnum = (typeof PlagueScalarFieldEnum)[keyof typeof PlagueScalarFieldEnum]


  export const PrescriptionScalarFieldEnum: {
    id: 'id',
    date: 'date',
    content: 'content',
    pulverization_method: 'pulverization_method',
    author: 'author',
    phone_number: 'phone_number',
    diagnosis_id: 'diagnosis_id'
  };

  export type PrescriptionScalarFieldEnum = (typeof PrescriptionScalarFieldEnum)[keyof typeof PrescriptionScalarFieldEnum]


  export const Privacy_policyScalarFieldEnum: {
    id: 'id',
    content: 'content',
    publish_date: 'publish_date'
  };

  export type Privacy_policyScalarFieldEnum = (typeof Privacy_policyScalarFieldEnum)[keyof typeof Privacy_policyScalarFieldEnum]


  export const QuotationScalarFieldEnum: {
    id: 'id',
    response_date: 'response_date',
    expiration_date: 'expiration_date',
    antecipated_price: 'antecipated_price',
    cash_price: 'cash_price',
    delayed_price: 'delayed_price',
    company_id: 'company_id',
    quotation_modal_package_id: 'quotation_modal_package_id'
  };

  export type QuotationScalarFieldEnum = (typeof QuotationScalarFieldEnum)[keyof typeof QuotationScalarFieldEnum]


  export const Quotation_checkoutScalarFieldEnum: {
    id: 'id',
    checkout_date: 'checkout_date',
    selected_price: 'selected_price',
    quotation_id: 'quotation_id'
  };

  export type Quotation_checkoutScalarFieldEnum = (typeof Quotation_checkoutScalarFieldEnum)[keyof typeof Quotation_checkoutScalarFieldEnum]


  export const Quotation_modal_packageScalarFieldEnum: {
    id: 'id',
    pulverization_method: 'pulverization_method',
    quotation_package_id: 'quotation_package_id'
  };

  export type Quotation_modal_packageScalarFieldEnum = (typeof Quotation_modal_packageScalarFieldEnum)[keyof typeof Quotation_modal_packageScalarFieldEnum]


  export const Quotation_packageScalarFieldEnum: {
    id: 'id',
    code: 'code',
    request_date: 'request_date',
    pulverization_start_date: 'pulverization_start_date',
    pulverization_end_date: 'pulverization_end_date'
  };

  export type Quotation_packageScalarFieldEnum = (typeof Quotation_packageScalarFieldEnum)[keyof typeof Quotation_packageScalarFieldEnum]


  export const RoleScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const Seed_revisionScalarFieldEnum: {
    id: 'id',
    revision: 'revision',
    seeding_timestamp: 'seeding_timestamp',
    version_major: 'version_major',
    version_minor: 'version_minor',
    version_patch: 'version_patch'
  };

  export type Seed_revisionScalarFieldEnum = (typeof Seed_revisionScalarFieldEnum)[keyof typeof Seed_revisionScalarFieldEnum]


  export const StateScalarFieldEnum: {
    id: 'id',
    initials: 'initials',
    name: 'name',
    ibge_code: 'ibge_code',
    country_code: 'country_code',
    area_code: 'area_code'
  };

  export type StateScalarFieldEnum = (typeof StateScalarFieldEnum)[keyof typeof StateScalarFieldEnum]


  export const Terms_and_conditionsScalarFieldEnum: {
    id: 'id',
    content: 'content',
    publish_date: 'publish_date'
  };

  export type Terms_and_conditionsScalarFieldEnum = (typeof Terms_and_conditionsScalarFieldEnum)[keyof typeof Terms_and_conditionsScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    first_name: 'first_name',
    last_name: 'last_name',
    username: 'username',
    password: 'password',
    cpf: 'cpf',
    phone_number: 'phone_number',
    email: 'email',
    active: 'active',
    creation_date: 'creation_date',
    access_date: 'access_date',
    update_date: 'update_date',
    yellow_threshold: 'yellow_threshold',
    red_threshold: 'red_threshold',
    fcm_token: 'fcm_token',
    avatar: 'avatar'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const User_accepted_privacy_policyScalarFieldEnum: {
    id: 'id',
    accepted_date: 'accepted_date',
    id_privacy_policy: 'id_privacy_policy',
    id_user: 'id_user'
  };

  export type User_accepted_privacy_policyScalarFieldEnum = (typeof User_accepted_privacy_policyScalarFieldEnum)[keyof typeof User_accepted_privacy_policyScalarFieldEnum]


  export const User_accepted_termsScalarFieldEnum: {
    id: 'id',
    accepted_date: 'accepted_date',
    id_user: 'id_user',
    id_terms_and_conditions: 'id_terms_and_conditions'
  };

  export type User_accepted_termsScalarFieldEnum = (typeof User_accepted_termsScalarFieldEnum)[keyof typeof User_accepted_termsScalarFieldEnum]


  export const User_roleScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    role_id: 'role_id'
  };

  export type User_roleScalarFieldEnum = (typeof User_roleScalarFieldEnum)[keyof typeof User_roleScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  /**
   * Deep Input Types
   */


  export type addressWhereInput = {
    AND?: Enumerable<addressWhereInput>
    OR?: Enumerable<addressWhereInput>
    NOT?: Enumerable<addressWhereInput>
    id?: IntFilter | number
    street?: StringFilter | string
    city?: StringFilter | string
    number?: IntNullableFilter | number | null
    km?: IntNullableFilter | number | null
    postal_code?: StringNullableFilter | string | null
    complement?: StringNullableFilter | string | null
    neighborhood?: StringNullableFilter | string | null
    phone_number?: StringNullableFilter | string | null
    contact_name?: StringNullableFilter | string | null
    state_id?: IntFilter | number
    mobile_number?: StringNullableFilter | string | null
    email?: StringNullableFilter | string | null
    state?: XOR<stateWhereInput, StateRelationFilter>
    company?: CompanyListRelationFilter
    farm?: FarmListRelationFilter
  }

  export type addressOrderByInput = {
    id?: SortOrder
    street?: SortOrder
    city?: SortOrder
    number?: SortOrder
    km?: SortOrder
    postal_code?: SortOrder
    complement?: SortOrder
    neighborhood?: SortOrder
    phone_number?: SortOrder
    contact_name?: SortOrder
    state_id?: SortOrder
    mobile_number?: SortOrder
    email?: SortOrder
  }

  export type addressWhereUniqueInput = {
    id?: number
  }

  export type areaWhereInput = {
    AND?: Enumerable<areaWhereInput>
    OR?: Enumerable<areaWhereInput>
    NOT?: Enumerable<areaWhereInput>
    id?: IntFilter | number
    code?: IntFilter | number
    lat?: FloatFilter | number
    long?: FloatFilter | number
    coordinates?: JsonNullableFilter
    name?: StringFilter | string
    zone?: StringNullableFilter | string | null
    state_initials?: StringNullableFilter | string | null
    city?: StringNullableFilter | string | null
    farm_id?: IntFilter | number
    demand?: StringNullableFilter | string | null
    farm?: XOR<farmWhereInput, FarmRelationFilter>
    field?: FieldListRelationFilter
  }

  export type areaOrderByInput = {
    id?: SortOrder
    code?: SortOrder
    lat?: SortOrder
    long?: SortOrder
    coordinates?: SortOrder
    name?: SortOrder
    zone?: SortOrder
    state_initials?: SortOrder
    city?: SortOrder
    farm_id?: SortOrder
    demand?: SortOrder
  }

  export type areaWhereUniqueInput = {
    id?: number
    name_per_farm_un?: Name_per_farm_unCompoundUniqueInput
  }

  export type companyWhereInput = {
    AND?: Enumerable<companyWhereInput>
    OR?: Enumerable<companyWhereInput>
    NOT?: Enumerable<companyWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    works_with_drone?: BoolFilter | boolean
    works_with_plane?: BoolFilter | boolean
    works_with_tractor?: BoolFilter | boolean
    lat?: FloatFilter | number
    long?: FloatFilter | number
    address_id?: IntFilter | number
    address?: XOR<addressWhereInput, AddressRelationFilter>
    quotation?: QuotationListRelationFilter
  }

  export type companyOrderByInput = {
    id?: SortOrder
    name?: SortOrder
    works_with_drone?: SortOrder
    works_with_plane?: SortOrder
    works_with_tractor?: SortOrder
    lat?: SortOrder
    long?: SortOrder
    address_id?: SortOrder
  }

  export type companyWhereUniqueInput = {
    id?: number
  }

  export type cropWhereInput = {
    AND?: Enumerable<cropWhereInput>
    OR?: Enumerable<cropWhereInput>
    NOT?: Enumerable<cropWhereInput>
    id?: IntFilter | number
    crop_type?: StringFilter | string
    variety?: StringFilter | string
    sowing_date?: DateTimeFilter | Date | string
    expected_harvest_date?: DateTimeFilter | Date | string
    number?: IntFilter | number
    is_diagnosis_hired?: BoolNullableFilter | boolean | null
    field_id?: IntFilter | number
    field?: XOR<fieldWhereInput, FieldRelationFilter>
    diagnosis?: DiagnosisListRelationFilter
  }

  export type cropOrderByInput = {
    id?: SortOrder
    crop_type?: SortOrder
    variety?: SortOrder
    sowing_date?: SortOrder
    expected_harvest_date?: SortOrder
    number?: SortOrder
    is_diagnosis_hired?: SortOrder
    field_id?: SortOrder
  }

  export type cropWhereUniqueInput = {
    id?: number
  }

  export type diagnosisWhereInput = {
    AND?: Enumerable<diagnosisWhereInput>
    OR?: Enumerable<diagnosisWhereInput>
    NOT?: Enumerable<diagnosisWhereInput>
    id?: IntFilter | number
    report_date?: DateTimeFilter | Date | string
    affected_area_ha?: FloatFilter | number
    crop_id?: IntNullableFilter | number | null
    crop?: XOR<cropWhereInput, CropRelationFilter> | null
    infestation?: InfestationListRelationFilter
    prescription?: PrescriptionListRelationFilter
  }

  export type diagnosisOrderByInput = {
    id?: SortOrder
    report_date?: SortOrder
    affected_area_ha?: SortOrder
    crop_id?: SortOrder
  }

  export type diagnosisWhereUniqueInput = {
    id?: number
  }

  export type emailWhereInput = {
    AND?: Enumerable<emailWhereInput>
    OR?: Enumerable<emailWhereInput>
    NOT?: Enumerable<emailWhereInput>
    id?: IntFilter | number
    email?: StringFilter | string
  }

  export type emailOrderByInput = {
    id?: SortOrder
    email?: SortOrder
  }

  export type emailWhereUniqueInput = {
    id?: number
  }

  export type farmWhereInput = {
    AND?: Enumerable<farmWhereInput>
    OR?: Enumerable<farmWhereInput>
    NOT?: Enumerable<farmWhereInput>
    id?: IntFilter | number
    cnpj?: StringNullableFilter | string | null
    social_name?: StringNullableFilter | string | null
    fantasy_name?: StringFilter | string
    lat?: FloatNullableFilter | number | null
    long?: FloatNullableFilter | number | null
    address_id?: IntFilter | number
    address?: XOR<addressWhereInput, AddressRelationFilter>
    area?: AreaListRelationFilter
    imaging?: ImagingListRelationFilter
    many_user_has_many_farm?: Many_user_has_many_farmListRelationFilter
  }

  export type farmOrderByInput = {
    id?: SortOrder
    cnpj?: SortOrder
    social_name?: SortOrder
    fantasy_name?: SortOrder
    lat?: SortOrder
    long?: SortOrder
    address_id?: SortOrder
  }

  export type farmWhereUniqueInput = {
    id?: number
    cnpj?: string
    social_name?: string
  }

  export type fieldWhereInput = {
    AND?: Enumerable<fieldWhereInput>
    OR?: Enumerable<fieldWhereInput>
    NOT?: Enumerable<fieldWhereInput>
    id?: IntFilter | number
    code?: IntFilter | number
    area_ha?: FloatFilter | number
    lat?: FloatFilter | number
    long?: FloatFilter | number
    coordinates?: JsonFilter
    name?: StringFilter | string
    image_uri?: StringNullableFilter | string | null
    area_id?: IntFilter | number
    visiona_area_id?: IntNullableFilter | number | null
    event?: StringNullableFilter | string | null
    area?: XOR<areaWhereInput, AreaRelationFilter>
    crop?: CropListRelationFilter
    many_quotation_modal_package_has_many_field?: Many_quotation_modal_package_has_many_fieldListRelationFilter
  }

  export type fieldOrderByInput = {
    id?: SortOrder
    code?: SortOrder
    area_ha?: SortOrder
    lat?: SortOrder
    long?: SortOrder
    coordinates?: SortOrder
    name?: SortOrder
    image_uri?: SortOrder
    area_id?: SortOrder
    visiona_area_id?: SortOrder
    event?: SortOrder
  }

  export type fieldWhereUniqueInput = {
    id?: number
    name_per_area_un?: Name_per_area_unCompoundUniqueInput
  }

  export type imagingWhereInput = {
    AND?: Enumerable<imagingWhereInput>
    OR?: Enumerable<imagingWhereInput>
    NOT?: Enumerable<imagingWhereInput>
    id?: IntFilter | number
    directory?: StringFilter | string
    processing_timestamp?: DateTimeFilter | Date | string
    imaging_date?: DateTimeFilter | Date | string
    farm_id?: IntNullableFilter | number | null
    farm?: XOR<farmWhereInput, FarmRelationFilter> | null
  }

  export type imagingOrderByInput = {
    id?: SortOrder
    directory?: SortOrder
    processing_timestamp?: SortOrder
    imaging_date?: SortOrder
    farm_id?: SortOrder
  }

  export type imagingWhereUniqueInput = {
    id?: number
  }

  export type infestationWhereInput = {
    AND?: Enumerable<infestationWhereInput>
    OR?: Enumerable<infestationWhereInput>
    NOT?: Enumerable<infestationWhereInput>
    id?: IntFilter | number
    area_ha?: FloatFilter | number
    points?: JsonNullableFilter
    diagnosis_id?: IntFilter | number
    plague_id?: IntFilter | number
    diagnosis?: XOR<diagnosisWhereInput, DiagnosisRelationFilter>
    plague?: XOR<plagueWhereInput, PlagueRelationFilter>
  }

  export type infestationOrderByInput = {
    id?: SortOrder
    area_ha?: SortOrder
    points?: SortOrder
    diagnosis_id?: SortOrder
    plague_id?: SortOrder
  }

  export type infestationWhereUniqueInput = {
    id?: number
    diagnosis_plague_un?: Diagnosis_plague_unCompoundUniqueInput
  }

  export type many_quotation_modal_package_has_many_fieldWhereInput = {
    AND?: Enumerable<many_quotation_modal_package_has_many_fieldWhereInput>
    OR?: Enumerable<many_quotation_modal_package_has_many_fieldWhereInput>
    NOT?: Enumerable<many_quotation_modal_package_has_many_fieldWhereInput>
    id_quotation_modal_package?: IntFilter | number
    id_field?: IntFilter | number
    field?: XOR<fieldWhereInput, FieldRelationFilter>
    quotation_modal_package?: XOR<quotation_modal_packageWhereInput, Quotation_modal_packageRelationFilter>
  }

  export type many_quotation_modal_package_has_many_fieldOrderByInput = {
    id_quotation_modal_package?: SortOrder
    id_field?: SortOrder
  }

  export type many_quotation_modal_package_has_many_fieldWhereUniqueInput = {
    id_quotation_modal_package_id_field?: Id_quotation_modal_packageId_fieldCompoundUniqueInput
  }

  export type many_user_has_many_farmWhereInput = {
    AND?: Enumerable<many_user_has_many_farmWhereInput>
    OR?: Enumerable<many_user_has_many_farmWhereInput>
    NOT?: Enumerable<many_user_has_many_farmWhereInput>
    user_id?: IntFilter | number
    farm_id?: IntFilter | number
    farm?: XOR<farmWhereInput, FarmRelationFilter>
    user?: XOR<userWhereInput, UserRelationFilter>
  }

  export type many_user_has_many_farmOrderByInput = {
    user_id?: SortOrder
    farm_id?: SortOrder
  }

  export type many_user_has_many_farmWhereUniqueInput = {
    user_id_farm_id?: User_idFarm_idCompoundUniqueInput
  }

  export type notificationWhereInput = {
    AND?: Enumerable<notificationWhereInput>
    OR?: Enumerable<notificationWhereInput>
    NOT?: Enumerable<notificationWhereInput>
    id?: IntFilter | number
    type?: IntFilter | number
    body?: JsonFilter
    sent_date?: DateTimeFilter | Date | string
    read_date?: DateTimeNullableFilter | Date | string | null
    delivered_date?: DateTimeNullableFilter | Date | string | null
    user_id?: IntFilter | number
    user?: XOR<userWhereInput, UserRelationFilter>
  }

  export type notificationOrderByInput = {
    id?: SortOrder
    type?: SortOrder
    body?: SortOrder
    sent_date?: SortOrder
    read_date?: SortOrder
    delivered_date?: SortOrder
    user_id?: SortOrder
  }

  export type notificationWhereUniqueInput = {
    id?: number
  }

  export type plagueWhereInput = {
    AND?: Enumerable<plagueWhereInput>
    OR?: Enumerable<plagueWhereInput>
    NOT?: Enumerable<plagueWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    display_name?: StringNullableFilter | string | null
    color?: StringFilter | string
    in_use?: BoolNullableFilter | boolean | null
    relevance_order?: IntNullableFilter | number | null
    infestation?: InfestationListRelationFilter
  }

  export type plagueOrderByInput = {
    id?: SortOrder
    name?: SortOrder
    display_name?: SortOrder
    color?: SortOrder
    in_use?: SortOrder
    relevance_order?: SortOrder
  }

  export type plagueWhereUniqueInput = {
    id?: number
    name?: string
  }

  export type prescriptionWhereInput = {
    AND?: Enumerable<prescriptionWhereInput>
    OR?: Enumerable<prescriptionWhereInput>
    NOT?: Enumerable<prescriptionWhereInput>
    id?: IntFilter | number
    date?: DateTimeFilter | Date | string
    content?: JsonFilter
    pulverization_method?: IntFilter | number
    author?: StringNullableFilter | string | null
    phone_number?: StringNullableFilter | string | null
    diagnosis_id?: IntFilter | number
    diagnosis?: XOR<diagnosisWhereInput, DiagnosisRelationFilter>
  }

  export type prescriptionOrderByInput = {
    id?: SortOrder
    date?: SortOrder
    content?: SortOrder
    pulverization_method?: SortOrder
    author?: SortOrder
    phone_number?: SortOrder
    diagnosis_id?: SortOrder
  }

  export type prescriptionWhereUniqueInput = {
    id?: number
  }

  export type privacy_policyWhereInput = {
    AND?: Enumerable<privacy_policyWhereInput>
    OR?: Enumerable<privacy_policyWhereInput>
    NOT?: Enumerable<privacy_policyWhereInput>
    id?: IntFilter | number
    content?: StringFilter | string
    publish_date?: DateTimeFilter | Date | string
    user_accepted_privacy_policy?: User_accepted_privacy_policyListRelationFilter
  }

  export type privacy_policyOrderByInput = {
    id?: SortOrder
    content?: SortOrder
    publish_date?: SortOrder
  }

  export type privacy_policyWhereUniqueInput = {
    id?: number
  }

  export type quotationWhereInput = {
    AND?: Enumerable<quotationWhereInput>
    OR?: Enumerable<quotationWhereInput>
    NOT?: Enumerable<quotationWhereInput>
    id?: IntFilter | number
    response_date?: DateTimeNullableFilter | Date | string | null
    expiration_date?: DateTimeNullableFilter | Date | string | null
    antecipated_price?: IntNullableFilter | number | null
    cash_price?: IntNullableFilter | number | null
    delayed_price?: IntNullableFilter | number | null
    company_id?: IntFilter | number
    quotation_modal_package_id?: IntFilter | number
    company?: XOR<companyWhereInput, CompanyRelationFilter>
    quotation_modal_package?: XOR<quotation_modal_packageWhereInput, Quotation_modal_packageRelationFilter>
    quotation_checkout?: XOR<quotation_checkoutWhereInput, Quotation_checkoutRelationFilter> | null
  }

  export type quotationOrderByInput = {
    id?: SortOrder
    response_date?: SortOrder
    expiration_date?: SortOrder
    antecipated_price?: SortOrder
    cash_price?: SortOrder
    delayed_price?: SortOrder
    company_id?: SortOrder
    quotation_modal_package_id?: SortOrder
  }

  export type quotationWhereUniqueInput = {
    id?: number
  }

  export type quotation_checkoutWhereInput = {
    AND?: Enumerable<quotation_checkoutWhereInput>
    OR?: Enumerable<quotation_checkoutWhereInput>
    NOT?: Enumerable<quotation_checkoutWhereInput>
    id?: IntFilter | number
    checkout_date?: DateTimeFilter | Date | string
    selected_price?: IntFilter | number
    quotation_id?: IntFilter | number
    quotation?: XOR<quotationWhereInput, QuotationRelationFilter>
  }

  export type quotation_checkoutOrderByInput = {
    id?: SortOrder
    checkout_date?: SortOrder
    selected_price?: SortOrder
    quotation_id?: SortOrder
  }

  export type quotation_checkoutWhereUniqueInput = {
    id?: number
    quotation_id?: number
  }

  export type quotation_modal_packageWhereInput = {
    AND?: Enumerable<quotation_modal_packageWhereInput>
    OR?: Enumerable<quotation_modal_packageWhereInput>
    NOT?: Enumerable<quotation_modal_packageWhereInput>
    id?: IntFilter | number
    pulverization_method?: IntFilter | number
    quotation_package_id?: IntFilter | number
    quotation_package?: XOR<quotation_packageWhereInput, Quotation_packageRelationFilter>
    many_quotation_modal_package_has_many_field?: Many_quotation_modal_package_has_many_fieldListRelationFilter
    quotation?: QuotationListRelationFilter
  }

  export type quotation_modal_packageOrderByInput = {
    id?: SortOrder
    pulverization_method?: SortOrder
    quotation_package_id?: SortOrder
  }

  export type quotation_modal_packageWhereUniqueInput = {
    id?: number
  }

  export type quotation_packageWhereInput = {
    AND?: Enumerable<quotation_packageWhereInput>
    OR?: Enumerable<quotation_packageWhereInput>
    NOT?: Enumerable<quotation_packageWhereInput>
    id?: IntFilter | number
    code?: IntFilter | number
    request_date?: DateTimeFilter | Date | string
    pulverization_start_date?: DateTimeFilter | Date | string
    pulverization_end_date?: DateTimeFilter | Date | string
    quotation_modal_package?: Quotation_modal_packageListRelationFilter
  }

  export type quotation_packageOrderByInput = {
    id?: SortOrder
    code?: SortOrder
    request_date?: SortOrder
    pulverization_start_date?: SortOrder
    pulverization_end_date?: SortOrder
  }

  export type quotation_packageWhereUniqueInput = {
    id?: number
  }

  export type roleWhereInput = {
    AND?: Enumerable<roleWhereInput>
    OR?: Enumerable<roleWhereInput>
    NOT?: Enumerable<roleWhereInput>
    id?: IntFilter | number
    name?: StringNullableFilter | string | null
    user_role?: User_roleListRelationFilter
  }

  export type roleOrderByInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type roleWhereUniqueInput = {
    id?: number
    name?: string
  }

  export type seed_revisionWhereInput = {
    AND?: Enumerable<seed_revisionWhereInput>
    OR?: Enumerable<seed_revisionWhereInput>
    NOT?: Enumerable<seed_revisionWhereInput>
    id?: IntFilter | number
    revision?: IntFilter | number
    seeding_timestamp?: DateTimeFilter | Date | string
    version_major?: IntNullableFilter | number | null
    version_minor?: IntNullableFilter | number | null
    version_patch?: IntNullableFilter | number | null
  }

  export type seed_revisionOrderByInput = {
    id?: SortOrder
    revision?: SortOrder
    seeding_timestamp?: SortOrder
    version_major?: SortOrder
    version_minor?: SortOrder
    version_patch?: SortOrder
  }

  export type seed_revisionWhereUniqueInput = {
    id?: number
  }

  export type stateWhereInput = {
    AND?: Enumerable<stateWhereInput>
    OR?: Enumerable<stateWhereInput>
    NOT?: Enumerable<stateWhereInput>
    id?: IntFilter | number
    initials?: StringFilter | string
    name?: StringFilter | string
    ibge_code?: IntNullableFilter | number | null
    country_code?: IntNullableFilter | number | null
    area_code?: JsonNullableFilter
    address?: AddressListRelationFilter
  }

  export type stateOrderByInput = {
    id?: SortOrder
    initials?: SortOrder
    name?: SortOrder
    ibge_code?: SortOrder
    country_code?: SortOrder
    area_code?: SortOrder
  }

  export type stateWhereUniqueInput = {
    id?: number
    initials?: string
  }

  export type terms_and_conditionsWhereInput = {
    AND?: Enumerable<terms_and_conditionsWhereInput>
    OR?: Enumerable<terms_and_conditionsWhereInput>
    NOT?: Enumerable<terms_and_conditionsWhereInput>
    id?: IntFilter | number
    content?: StringFilter | string
    publish_date?: DateTimeFilter | Date | string
    user_accepted_terms?: User_accepted_termsListRelationFilter
  }

  export type terms_and_conditionsOrderByInput = {
    id?: SortOrder
    content?: SortOrder
    publish_date?: SortOrder
  }

  export type terms_and_conditionsWhereUniqueInput = {
    id?: number
  }

  export type userWhereInput = {
    AND?: Enumerable<userWhereInput>
    OR?: Enumerable<userWhereInput>
    NOT?: Enumerable<userWhereInput>
    id?: IntFilter | number
    first_name?: StringFilter | string
    last_name?: StringFilter | string
    username?: StringFilter | string
    password?: StringFilter | string
    cpf?: StringNullableFilter | string | null
    phone_number?: StringFilter | string
    email?: StringNullableFilter | string | null
    active?: BoolFilter | boolean
    creation_date?: DateTimeFilter | Date | string
    access_date?: DateTimeFilter | Date | string
    update_date?: DateTimeFilter | Date | string
    yellow_threshold?: FloatFilter | number
    red_threshold?: FloatFilter | number
    fcm_token?: StringNullableFilter | string | null
    avatar?: StringNullableFilter | string | null
    many_user_has_many_farm?: Many_user_has_many_farmListRelationFilter
    notification?: NotificationListRelationFilter
    user_accepted_privacy_policy?: User_accepted_privacy_policyListRelationFilter
    user_accepted_terms?: User_accepted_termsListRelationFilter
    user_role?: User_roleListRelationFilter
  }

  export type userOrderByInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    username?: SortOrder
    password?: SortOrder
    cpf?: SortOrder
    phone_number?: SortOrder
    email?: SortOrder
    active?: SortOrder
    creation_date?: SortOrder
    access_date?: SortOrder
    update_date?: SortOrder
    yellow_threshold?: SortOrder
    red_threshold?: SortOrder
    fcm_token?: SortOrder
    avatar?: SortOrder
  }

  export type userWhereUniqueInput = {
    id?: number
    username?: string
    password?: string
  }

  export type user_accepted_privacy_policyWhereInput = {
    AND?: Enumerable<user_accepted_privacy_policyWhereInput>
    OR?: Enumerable<user_accepted_privacy_policyWhereInput>
    NOT?: Enumerable<user_accepted_privacy_policyWhereInput>
    id?: IntFilter | number
    accepted_date?: DateTimeFilter | Date | string
    id_privacy_policy?: IntFilter | number
    id_user?: IntFilter | number
    privacy_policy?: XOR<privacy_policyWhereInput, Privacy_policyRelationFilter>
    user?: XOR<userWhereInput, UserRelationFilter>
  }

  export type user_accepted_privacy_policyOrderByInput = {
    id?: SortOrder
    accepted_date?: SortOrder
    id_privacy_policy?: SortOrder
    id_user?: SortOrder
  }

  export type user_accepted_privacy_policyWhereUniqueInput = {
    id?: number
  }

  export type user_accepted_termsWhereInput = {
    AND?: Enumerable<user_accepted_termsWhereInput>
    OR?: Enumerable<user_accepted_termsWhereInput>
    NOT?: Enumerable<user_accepted_termsWhereInput>
    id?: IntFilter | number
    accepted_date?: DateTimeFilter | Date | string
    id_user?: IntFilter | number
    id_terms_and_conditions?: IntFilter | number
    terms_and_conditions?: XOR<terms_and_conditionsWhereInput, Terms_and_conditionsRelationFilter>
    user?: XOR<userWhereInput, UserRelationFilter>
  }

  export type user_accepted_termsOrderByInput = {
    id?: SortOrder
    accepted_date?: SortOrder
    id_user?: SortOrder
    id_terms_and_conditions?: SortOrder
  }

  export type user_accepted_termsWhereUniqueInput = {
    id?: number
  }

  export type user_roleWhereInput = {
    AND?: Enumerable<user_roleWhereInput>
    OR?: Enumerable<user_roleWhereInput>
    NOT?: Enumerable<user_roleWhereInput>
    id?: IntFilter | number
    user_id?: IntFilter | number
    role_id?: IntFilter | number
    role?: XOR<roleWhereInput, RoleRelationFilter>
    user?: XOR<userWhereInput, UserRelationFilter>
  }

  export type user_roleOrderByInput = {
    id?: SortOrder
    user_id?: SortOrder
    role_id?: SortOrder
  }

  export type user_roleWhereUniqueInput = {
    id?: number
  }

  export type addressCreateInput = {
    street: string
    city: string
    number?: number | null
    km?: number | null
    postal_code?: string | null
    complement?: string | null
    neighborhood?: string | null
    phone_number?: string | null
    contact_name?: string | null
    mobile_number?: string | null
    email?: string | null
    state: stateCreateOneWithoutAddressInput
    company?: companyCreateManyWithoutAddressInput
    farm?: farmCreateManyWithoutAddressInput
  }

  export type addressUpdateInput = {
    street?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    number?: NullableIntFieldUpdateOperationsInput | number | null
    km?: NullableIntFieldUpdateOperationsInput | number | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    contact_name?: NullableStringFieldUpdateOperationsInput | string | null
    mobile_number?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    state?: stateUpdateOneRequiredWithoutAddressInput
    company?: companyUpdateManyWithoutAddressInput
    farm?: farmUpdateManyWithoutAddressInput
  }

  export type addressUpdateManyMutationInput = {
    street?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    number?: NullableIntFieldUpdateOperationsInput | number | null
    km?: NullableIntFieldUpdateOperationsInput | number | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    contact_name?: NullableStringFieldUpdateOperationsInput | string | null
    mobile_number?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type areaCreateInput = {
    code: number
    lat: number
    long: number
    coordinates?: InputJsonValue | null
    name: string
    zone?: string | null
    state_initials?: string | null
    city?: string | null
    demand?: string | null
    farm: farmCreateOneWithoutAreaInput
    field?: fieldCreateManyWithoutAreaInput
  }

  export type areaUpdateInput = {
    code?: IntFieldUpdateOperationsInput | number
    lat?: FloatFieldUpdateOperationsInput | number
    long?: FloatFieldUpdateOperationsInput | number
    coordinates?: InputJsonValue | null
    name?: StringFieldUpdateOperationsInput | string
    zone?: NullableStringFieldUpdateOperationsInput | string | null
    state_initials?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    demand?: NullableStringFieldUpdateOperationsInput | string | null
    farm?: farmUpdateOneRequiredWithoutAreaInput
    field?: fieldUpdateManyWithoutAreaInput
  }

  export type areaUpdateManyMutationInput = {
    code?: IntFieldUpdateOperationsInput | number
    lat?: FloatFieldUpdateOperationsInput | number
    long?: FloatFieldUpdateOperationsInput | number
    coordinates?: InputJsonValue | null
    name?: StringFieldUpdateOperationsInput | string
    zone?: NullableStringFieldUpdateOperationsInput | string | null
    state_initials?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    demand?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type companyCreateInput = {
    name: string
    works_with_drone: boolean
    works_with_plane: boolean
    works_with_tractor: boolean
    lat: number
    long: number
    address: addressCreateOneWithoutCompanyInput
    quotation?: quotationCreateManyWithoutCompanyInput
  }

  export type companyUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    works_with_drone?: BoolFieldUpdateOperationsInput | boolean
    works_with_plane?: BoolFieldUpdateOperationsInput | boolean
    works_with_tractor?: BoolFieldUpdateOperationsInput | boolean
    lat?: FloatFieldUpdateOperationsInput | number
    long?: FloatFieldUpdateOperationsInput | number
    address?: addressUpdateOneRequiredWithoutCompanyInput
    quotation?: quotationUpdateManyWithoutCompanyInput
  }

  export type companyUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    works_with_drone?: BoolFieldUpdateOperationsInput | boolean
    works_with_plane?: BoolFieldUpdateOperationsInput | boolean
    works_with_tractor?: BoolFieldUpdateOperationsInput | boolean
    lat?: FloatFieldUpdateOperationsInput | number
    long?: FloatFieldUpdateOperationsInput | number
  }

  export type cropCreateInput = {
    crop_type: string
    variety: string
    sowing_date: Date | string
    expected_harvest_date: Date | string
    number?: number
    is_diagnosis_hired?: boolean | null
    field: fieldCreateOneWithoutCropInput
    diagnosis?: diagnosisCreateManyWithoutCropInput
  }

  export type cropUpdateInput = {
    crop_type?: StringFieldUpdateOperationsInput | string
    variety?: StringFieldUpdateOperationsInput | string
    sowing_date?: DateTimeFieldUpdateOperationsInput | Date | string
    expected_harvest_date?: DateTimeFieldUpdateOperationsInput | Date | string
    number?: IntFieldUpdateOperationsInput | number
    is_diagnosis_hired?: NullableBoolFieldUpdateOperationsInput | boolean | null
    field?: fieldUpdateOneRequiredWithoutCropInput
    diagnosis?: diagnosisUpdateManyWithoutCropInput
  }

  export type cropUpdateManyMutationInput = {
    crop_type?: StringFieldUpdateOperationsInput | string
    variety?: StringFieldUpdateOperationsInput | string
    sowing_date?: DateTimeFieldUpdateOperationsInput | Date | string
    expected_harvest_date?: DateTimeFieldUpdateOperationsInput | Date | string
    number?: IntFieldUpdateOperationsInput | number
    is_diagnosis_hired?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type diagnosisCreateInput = {
    report_date: Date | string
    affected_area_ha: number
    crop?: cropCreateOneWithoutDiagnosisInput
    infestation?: infestationCreateManyWithoutDiagnosisInput
    prescription?: prescriptionCreateManyWithoutDiagnosisInput
  }

  export type diagnosisUpdateInput = {
    report_date?: DateTimeFieldUpdateOperationsInput | Date | string
    affected_area_ha?: FloatFieldUpdateOperationsInput | number
    crop?: cropUpdateOneWithoutDiagnosisInput
    infestation?: infestationUpdateManyWithoutDiagnosisInput
    prescription?: prescriptionUpdateManyWithoutDiagnosisInput
  }

  export type diagnosisUpdateManyMutationInput = {
    report_date?: DateTimeFieldUpdateOperationsInput | Date | string
    affected_area_ha?: FloatFieldUpdateOperationsInput | number
  }

  export type emailCreateInput = {
    email: string
  }

  export type emailUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
  }

  export type emailUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
  }

  export type farmCreateInput = {
    cnpj?: string | null
    social_name?: string | null
    fantasy_name: string
    lat?: number | null
    long?: number | null
    address: addressCreateOneWithoutFarmInput
    area?: areaCreateManyWithoutFarmInput
    imaging?: imagingCreateManyWithoutFarmInput
    many_user_has_many_farm?: many_user_has_many_farmCreateManyWithoutFarmInput
  }

  export type farmUpdateInput = {
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    social_name?: NullableStringFieldUpdateOperationsInput | string | null
    fantasy_name?: StringFieldUpdateOperationsInput | string
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    long?: NullableFloatFieldUpdateOperationsInput | number | null
    address?: addressUpdateOneRequiredWithoutFarmInput
    area?: areaUpdateManyWithoutFarmInput
    imaging?: imagingUpdateManyWithoutFarmInput
    many_user_has_many_farm?: many_user_has_many_farmUpdateManyWithoutFarmInput
  }

  export type farmUpdateManyMutationInput = {
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    social_name?: NullableStringFieldUpdateOperationsInput | string | null
    fantasy_name?: StringFieldUpdateOperationsInput | string
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    long?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type fieldCreateInput = {
    code: number
    area_ha: number
    lat: number
    long: number
    coordinates: InputJsonValue
    name: string
    image_uri?: string | null
    visiona_area_id?: number | null
    event?: string | null
    area: areaCreateOneWithoutFieldInput
    crop?: cropCreateManyWithoutFieldInput
    many_quotation_modal_package_has_many_field?: many_quotation_modal_package_has_many_fieldCreateManyWithoutFieldInput
  }

  export type fieldUpdateInput = {
    code?: IntFieldUpdateOperationsInput | number
    area_ha?: FloatFieldUpdateOperationsInput | number
    lat?: FloatFieldUpdateOperationsInput | number
    long?: FloatFieldUpdateOperationsInput | number
    coordinates?: InputJsonValue
    name?: StringFieldUpdateOperationsInput | string
    image_uri?: NullableStringFieldUpdateOperationsInput | string | null
    visiona_area_id?: NullableIntFieldUpdateOperationsInput | number | null
    event?: NullableStringFieldUpdateOperationsInput | string | null
    area?: areaUpdateOneRequiredWithoutFieldInput
    crop?: cropUpdateManyWithoutFieldInput
    many_quotation_modal_package_has_many_field?: many_quotation_modal_package_has_many_fieldUpdateManyWithoutFieldInput
  }

  export type fieldUpdateManyMutationInput = {
    code?: IntFieldUpdateOperationsInput | number
    area_ha?: FloatFieldUpdateOperationsInput | number
    lat?: FloatFieldUpdateOperationsInput | number
    long?: FloatFieldUpdateOperationsInput | number
    coordinates?: InputJsonValue
    name?: StringFieldUpdateOperationsInput | string
    image_uri?: NullableStringFieldUpdateOperationsInput | string | null
    visiona_area_id?: NullableIntFieldUpdateOperationsInput | number | null
    event?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type imagingCreateInput = {
    directory: string
    processing_timestamp: Date | string
    imaging_date: Date | string
    farm?: farmCreateOneWithoutImagingInput
  }

  export type imagingUpdateInput = {
    directory?: StringFieldUpdateOperationsInput | string
    processing_timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    imaging_date?: DateTimeFieldUpdateOperationsInput | Date | string
    farm?: farmUpdateOneWithoutImagingInput
  }

  export type imagingUpdateManyMutationInput = {
    directory?: StringFieldUpdateOperationsInput | string
    processing_timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    imaging_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type infestationCreateInput = {
    area_ha?: number
    points?: InputJsonValue | null
    diagnosis: diagnosisCreateOneWithoutInfestationInput
    plague: plagueCreateOneWithoutInfestationInput
  }

  export type infestationUpdateInput = {
    area_ha?: FloatFieldUpdateOperationsInput | number
    points?: InputJsonValue | null
    diagnosis?: diagnosisUpdateOneRequiredWithoutInfestationInput
    plague?: plagueUpdateOneRequiredWithoutInfestationInput
  }

  export type infestationUpdateManyMutationInput = {
    area_ha?: FloatFieldUpdateOperationsInput | number
    points?: InputJsonValue | null
  }

  export type many_quotation_modal_package_has_many_fieldCreateInput = {
    field: fieldCreateOneWithoutMany_quotation_modal_package_has_many_fieldInput
    quotation_modal_package: quotation_modal_packageCreateOneWithoutMany_quotation_modal_package_has_many_fieldInput
  }

  export type many_quotation_modal_package_has_many_fieldUpdateInput = {
    field?: fieldUpdateOneRequiredWithoutMany_quotation_modal_package_has_many_fieldInput
    quotation_modal_package?: quotation_modal_packageUpdateOneRequiredWithoutMany_quotation_modal_package_has_many_fieldInput
  }

  export type many_quotation_modal_package_has_many_fieldUpdateManyMutationInput = {

  }

  export type many_user_has_many_farmCreateInput = {
    farm: farmCreateOneWithoutMany_user_has_many_farmInput
    user: userCreateOneWithoutMany_user_has_many_farmInput
  }

  export type many_user_has_many_farmUpdateInput = {
    farm?: farmUpdateOneRequiredWithoutMany_user_has_many_farmInput
    user?: userUpdateOneRequiredWithoutMany_user_has_many_farmInput
  }

  export type many_user_has_many_farmUpdateManyMutationInput = {

  }

  export type notificationCreateInput = {
    type: number
    body: InputJsonValue
    sent_date: Date | string
    read_date?: Date | string | null
    delivered_date?: Date | string | null
    user: userCreateOneWithoutNotificationInput
  }

  export type notificationUpdateInput = {
    type?: IntFieldUpdateOperationsInput | number
    body?: InputJsonValue
    sent_date?: DateTimeFieldUpdateOperationsInput | Date | string
    read_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    delivered_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneRequiredWithoutNotificationInput
  }

  export type notificationUpdateManyMutationInput = {
    type?: IntFieldUpdateOperationsInput | number
    body?: InputJsonValue
    sent_date?: DateTimeFieldUpdateOperationsInput | Date | string
    read_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    delivered_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type plagueCreateInput = {
    name: string
    display_name?: string | null
    color: string
    in_use?: boolean | null
    relevance_order?: number | null
    infestation?: infestationCreateManyWithoutPlagueInput
  }

  export type plagueUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    display_name?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    in_use?: NullableBoolFieldUpdateOperationsInput | boolean | null
    relevance_order?: NullableIntFieldUpdateOperationsInput | number | null
    infestation?: infestationUpdateManyWithoutPlagueInput
  }

  export type plagueUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    display_name?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    in_use?: NullableBoolFieldUpdateOperationsInput | boolean | null
    relevance_order?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type prescriptionCreateInput = {
    date: Date | string
    content?: InputJsonValue
    pulverization_method: number
    author?: string | null
    phone_number?: string | null
    diagnosis: diagnosisCreateOneWithoutPrescriptionInput
  }

  export type prescriptionUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: InputJsonValue
    pulverization_method?: IntFieldUpdateOperationsInput | number
    author?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosis?: diagnosisUpdateOneRequiredWithoutPrescriptionInput
  }

  export type prescriptionUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: InputJsonValue
    pulverization_method?: IntFieldUpdateOperationsInput | number
    author?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type privacy_policyCreateInput = {
    content: string
    publish_date: Date | string
    user_accepted_privacy_policy?: user_accepted_privacy_policyCreateManyWithoutPrivacy_policyInput
  }

  export type privacy_policyUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string
    publish_date?: DateTimeFieldUpdateOperationsInput | Date | string
    user_accepted_privacy_policy?: user_accepted_privacy_policyUpdateManyWithoutPrivacy_policyInput
  }

  export type privacy_policyUpdateManyMutationInput = {
    content?: StringFieldUpdateOperationsInput | string
    publish_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type quotationCreateInput = {
    response_date?: Date | string | null
    expiration_date?: Date | string | null
    antecipated_price?: number | null
    cash_price?: number | null
    delayed_price?: number | null
    company: companyCreateOneWithoutQuotationInput
    quotation_modal_package: quotation_modal_packageCreateOneWithoutQuotationInput
    quotation_checkout?: quotation_checkoutCreateOneWithoutQuotationInput
  }

  export type quotationUpdateInput = {
    response_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiration_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    antecipated_price?: NullableIntFieldUpdateOperationsInput | number | null
    cash_price?: NullableIntFieldUpdateOperationsInput | number | null
    delayed_price?: NullableIntFieldUpdateOperationsInput | number | null
    company?: companyUpdateOneRequiredWithoutQuotationInput
    quotation_modal_package?: quotation_modal_packageUpdateOneRequiredWithoutQuotationInput
    quotation_checkout?: quotation_checkoutUpdateOneWithoutQuotationInput
  }

  export type quotationUpdateManyMutationInput = {
    response_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiration_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    antecipated_price?: NullableIntFieldUpdateOperationsInput | number | null
    cash_price?: NullableIntFieldUpdateOperationsInput | number | null
    delayed_price?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type quotation_checkoutCreateInput = {
    checkout_date: Date | string
    selected_price: number
    quotation: quotationCreateOneWithoutQuotation_checkoutInput
  }

  export type quotation_checkoutUpdateInput = {
    checkout_date?: DateTimeFieldUpdateOperationsInput | Date | string
    selected_price?: IntFieldUpdateOperationsInput | number
    quotation?: quotationUpdateOneRequiredWithoutQuotation_checkoutInput
  }

  export type quotation_checkoutUpdateManyMutationInput = {
    checkout_date?: DateTimeFieldUpdateOperationsInput | Date | string
    selected_price?: IntFieldUpdateOperationsInput | number
  }

  export type quotation_modal_packageCreateInput = {
    pulverization_method: number
    quotation_package: quotation_packageCreateOneWithoutQuotation_modal_packageInput
    many_quotation_modal_package_has_many_field?: many_quotation_modal_package_has_many_fieldCreateManyWithoutQuotation_modal_packageInput
    quotation?: quotationCreateManyWithoutQuotation_modal_packageInput
  }

  export type quotation_modal_packageUpdateInput = {
    pulverization_method?: IntFieldUpdateOperationsInput | number
    quotation_package?: quotation_packageUpdateOneRequiredWithoutQuotation_modal_packageInput
    many_quotation_modal_package_has_many_field?: many_quotation_modal_package_has_many_fieldUpdateManyWithoutQuotation_modal_packageInput
    quotation?: quotationUpdateManyWithoutQuotation_modal_packageInput
  }

  export type quotation_modal_packageUpdateManyMutationInput = {
    pulverization_method?: IntFieldUpdateOperationsInput | number
  }

  export type quotation_packageCreateInput = {
    code: number
    request_date: Date | string
    pulverization_start_date: Date | string
    pulverization_end_date: Date | string
    quotation_modal_package?: quotation_modal_packageCreateManyWithoutQuotation_packageInput
  }

  export type quotation_packageUpdateInput = {
    code?: IntFieldUpdateOperationsInput | number
    request_date?: DateTimeFieldUpdateOperationsInput | Date | string
    pulverization_start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    pulverization_end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    quotation_modal_package?: quotation_modal_packageUpdateManyWithoutQuotation_packageInput
  }

  export type quotation_packageUpdateManyMutationInput = {
    code?: IntFieldUpdateOperationsInput | number
    request_date?: DateTimeFieldUpdateOperationsInput | Date | string
    pulverization_start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    pulverization_end_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type roleCreateInput = {
    name?: string | null
    user_role?: user_roleCreateManyWithoutRoleInput
  }

  export type roleUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    user_role?: user_roleUpdateManyWithoutRoleInput
  }

  export type roleUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type seed_revisionCreateInput = {
    revision?: number
    seeding_timestamp: Date | string
    version_major?: number | null
    version_minor?: number | null
    version_patch?: number | null
  }

  export type seed_revisionUpdateInput = {
    revision?: IntFieldUpdateOperationsInput | number
    seeding_timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    version_major?: NullableIntFieldUpdateOperationsInput | number | null
    version_minor?: NullableIntFieldUpdateOperationsInput | number | null
    version_patch?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type seed_revisionUpdateManyMutationInput = {
    revision?: IntFieldUpdateOperationsInput | number
    seeding_timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    version_major?: NullableIntFieldUpdateOperationsInput | number | null
    version_minor?: NullableIntFieldUpdateOperationsInput | number | null
    version_patch?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type stateCreateInput = {
    initials: string
    name: string
    ibge_code?: number | null
    country_code?: number | null
    area_code?: InputJsonValue | null
    address?: addressCreateManyWithoutStateInput
  }

  export type stateUpdateInput = {
    initials?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ibge_code?: NullableIntFieldUpdateOperationsInput | number | null
    country_code?: NullableIntFieldUpdateOperationsInput | number | null
    area_code?: InputJsonValue | null
    address?: addressUpdateManyWithoutStateInput
  }

  export type stateUpdateManyMutationInput = {
    initials?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ibge_code?: NullableIntFieldUpdateOperationsInput | number | null
    country_code?: NullableIntFieldUpdateOperationsInput | number | null
    area_code?: InputJsonValue | null
  }

  export type terms_and_conditionsCreateInput = {
    content: string
    publish_date: Date | string
    user_accepted_terms?: user_accepted_termsCreateManyWithoutTerms_and_conditionsInput
  }

  export type terms_and_conditionsUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string
    publish_date?: DateTimeFieldUpdateOperationsInput | Date | string
    user_accepted_terms?: user_accepted_termsUpdateManyWithoutTerms_and_conditionsInput
  }

  export type terms_and_conditionsUpdateManyMutationInput = {
    content?: StringFieldUpdateOperationsInput | string
    publish_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type userCreateInput = {
    first_name: string
    last_name: string
    username: string
    password: string
    cpf?: string | null
    phone_number: string
    email?: string | null
    active: boolean
    creation_date: Date | string
    access_date: Date | string
    update_date: Date | string
    yellow_threshold?: number
    red_threshold?: number
    fcm_token?: string | null
    avatar?: string | null
    many_user_has_many_farm?: many_user_has_many_farmCreateManyWithoutUserInput
    notification?: notificationCreateManyWithoutUserInput
    user_accepted_privacy_policy?: user_accepted_privacy_policyCreateManyWithoutUserInput
    user_accepted_terms?: user_accepted_termsCreateManyWithoutUserInput
    user_role?: user_roleCreateManyWithoutUserInput
  }

  export type userUpdateInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    creation_date?: DateTimeFieldUpdateOperationsInput | Date | string
    access_date?: DateTimeFieldUpdateOperationsInput | Date | string
    update_date?: DateTimeFieldUpdateOperationsInput | Date | string
    yellow_threshold?: FloatFieldUpdateOperationsInput | number
    red_threshold?: FloatFieldUpdateOperationsInput | number
    fcm_token?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    many_user_has_many_farm?: many_user_has_many_farmUpdateManyWithoutUserInput
    notification?: notificationUpdateManyWithoutUserInput
    user_accepted_privacy_policy?: user_accepted_privacy_policyUpdateManyWithoutUserInput
    user_accepted_terms?: user_accepted_termsUpdateManyWithoutUserInput
    user_role?: user_roleUpdateManyWithoutUserInput
  }

  export type userUpdateManyMutationInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    creation_date?: DateTimeFieldUpdateOperationsInput | Date | string
    access_date?: DateTimeFieldUpdateOperationsInput | Date | string
    update_date?: DateTimeFieldUpdateOperationsInput | Date | string
    yellow_threshold?: FloatFieldUpdateOperationsInput | number
    red_threshold?: FloatFieldUpdateOperationsInput | number
    fcm_token?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type user_accepted_privacy_policyCreateInput = {
    accepted_date: Date | string
    privacy_policy: privacy_policyCreateOneWithoutUser_accepted_privacy_policyInput
    user: userCreateOneWithoutUser_accepted_privacy_policyInput
  }

  export type user_accepted_privacy_policyUpdateInput = {
    accepted_date?: DateTimeFieldUpdateOperationsInput | Date | string
    privacy_policy?: privacy_policyUpdateOneRequiredWithoutUser_accepted_privacy_policyInput
    user?: userUpdateOneRequiredWithoutUser_accepted_privacy_policyInput
  }

  export type user_accepted_privacy_policyUpdateManyMutationInput = {
    accepted_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_accepted_termsCreateInput = {
    accepted_date: Date | string
    terms_and_conditions: terms_and_conditionsCreateOneWithoutUser_accepted_termsInput
    user: userCreateOneWithoutUser_accepted_termsInput
  }

  export type user_accepted_termsUpdateInput = {
    accepted_date?: DateTimeFieldUpdateOperationsInput | Date | string
    terms_and_conditions?: terms_and_conditionsUpdateOneRequiredWithoutUser_accepted_termsInput
    user?: userUpdateOneRequiredWithoutUser_accepted_termsInput
  }

  export type user_accepted_termsUpdateManyMutationInput = {
    accepted_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_roleCreateInput = {
    role: roleCreateOneWithoutUser_roleInput
    user: userCreateOneWithoutUser_roleInput
  }

  export type user_roleUpdateInput = {
    role?: roleUpdateOneRequiredWithoutUser_roleInput
    user?: userUpdateOneRequiredWithoutUser_roleInput
  }

  export type user_roleUpdateManyMutationInput = {

  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringFilter | string
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter | string | null
  }

  export type StateRelationFilter = {
    is?: stateWhereInput
    isNot?: stateWhereInput
  }

  export type CompanyListRelationFilter = {
    every?: companyWhereInput
    some?: companyWhereInput
    none?: companyWhereInput
  }

  export type FarmListRelationFilter = {
    every?: farmWhereInput
    some?: farmWhereInput
    none?: farmWhereInput
  }

  export type FloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type JsonNullableFilter = {
    equals?: InputJsonValue | null
    not?: InputJsonValue | null
  }

  export type FarmRelationFilter = {
    is?: farmWhereInput
    isNot?: farmWhereInput
  }

  export type FieldListRelationFilter = {
    every?: fieldWhereInput
    some?: fieldWhereInput
    none?: fieldWhereInput
  }

  export type Name_per_farm_unCompoundUniqueInput = {
    farm_id: number
    name: string
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type AddressRelationFilter = {
    is?: addressWhereInput
    isNot?: addressWhereInput
  }

  export type QuotationListRelationFilter = {
    every?: quotationWhereInput
    some?: quotationWhereInput
    none?: quotationWhereInput
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type BoolNullableFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableFilter | boolean | null
  }

  export type FieldRelationFilter = {
    is?: fieldWhereInput
    isNot?: fieldWhereInput
  }

  export type DiagnosisListRelationFilter = {
    every?: diagnosisWhereInput
    some?: diagnosisWhereInput
    none?: diagnosisWhereInput
  }

  export type CropRelationFilter = {
    is?: cropWhereInput | null
    isNot?: cropWhereInput | null
  }

  export type InfestationListRelationFilter = {
    every?: infestationWhereInput
    some?: infestationWhereInput
    none?: infestationWhereInput
  }

  export type PrescriptionListRelationFilter = {
    every?: prescriptionWhereInput
    some?: prescriptionWhereInput
    none?: prescriptionWhereInput
  }

  export type FloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type AreaListRelationFilter = {
    every?: areaWhereInput
    some?: areaWhereInput
    none?: areaWhereInput
  }

  export type ImagingListRelationFilter = {
    every?: imagingWhereInput
    some?: imagingWhereInput
    none?: imagingWhereInput
  }

  export type Many_user_has_many_farmListRelationFilter = {
    every?: many_user_has_many_farmWhereInput
    some?: many_user_has_many_farmWhereInput
    none?: many_user_has_many_farmWhereInput
  }

  export type JsonFilter = {
    equals?: InputJsonValue
    not?: InputJsonValue
  }

  export type AreaRelationFilter = {
    is?: areaWhereInput
    isNot?: areaWhereInput
  }

  export type CropListRelationFilter = {
    every?: cropWhereInput
    some?: cropWhereInput
    none?: cropWhereInput
  }

  export type Many_quotation_modal_package_has_many_fieldListRelationFilter = {
    every?: many_quotation_modal_package_has_many_fieldWhereInput
    some?: many_quotation_modal_package_has_many_fieldWhereInput
    none?: many_quotation_modal_package_has_many_fieldWhereInput
  }

  export type Name_per_area_unCompoundUniqueInput = {
    name: string
    area_id: number
  }

  export type DiagnosisRelationFilter = {
    is?: diagnosisWhereInput
    isNot?: diagnosisWhereInput
  }

  export type PlagueRelationFilter = {
    is?: plagueWhereInput
    isNot?: plagueWhereInput
  }

  export type Diagnosis_plague_unCompoundUniqueInput = {
    plague_id: number
    diagnosis_id: number
  }

  export type Quotation_modal_packageRelationFilter = {
    is?: quotation_modal_packageWhereInput
    isNot?: quotation_modal_packageWhereInput
  }

  export type Id_quotation_modal_packageId_fieldCompoundUniqueInput = {
    id_quotation_modal_package: number
    id_field: number
  }

  export type UserRelationFilter = {
    is?: userWhereInput
    isNot?: userWhereInput
  }

  export type User_idFarm_idCompoundUniqueInput = {
    user_id: number
    farm_id: number
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type User_accepted_privacy_policyListRelationFilter = {
    every?: user_accepted_privacy_policyWhereInput
    some?: user_accepted_privacy_policyWhereInput
    none?: user_accepted_privacy_policyWhereInput
  }

  export type CompanyRelationFilter = {
    is?: companyWhereInput
    isNot?: companyWhereInput
  }

  export type Quotation_checkoutRelationFilter = {
    is?: quotation_checkoutWhereInput | null
    isNot?: quotation_checkoutWhereInput | null
  }

  export type QuotationRelationFilter = {
    is?: quotationWhereInput
    isNot?: quotationWhereInput
  }

  export type Quotation_packageRelationFilter = {
    is?: quotation_packageWhereInput
    isNot?: quotation_packageWhereInput
  }

  export type Quotation_modal_packageListRelationFilter = {
    every?: quotation_modal_packageWhereInput
    some?: quotation_modal_packageWhereInput
    none?: quotation_modal_packageWhereInput
  }

  export type User_roleListRelationFilter = {
    every?: user_roleWhereInput
    some?: user_roleWhereInput
    none?: user_roleWhereInput
  }

  export type AddressListRelationFilter = {
    every?: addressWhereInput
    some?: addressWhereInput
    none?: addressWhereInput
  }

  export type User_accepted_termsListRelationFilter = {
    every?: user_accepted_termsWhereInput
    some?: user_accepted_termsWhereInput
    none?: user_accepted_termsWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: notificationWhereInput
    some?: notificationWhereInput
    none?: notificationWhereInput
  }

  export type Privacy_policyRelationFilter = {
    is?: privacy_policyWhereInput
    isNot?: privacy_policyWhereInput
  }

  export type Terms_and_conditionsRelationFilter = {
    is?: terms_and_conditionsWhereInput
    isNot?: terms_and_conditionsWhereInput
  }

  export type RoleRelationFilter = {
    is?: roleWhereInput
    isNot?: roleWhereInput
  }

  export type stateCreateOneWithoutAddressInput = {
    create?: stateCreateWithoutAddressInput
    connect?: stateWhereUniqueInput
    connectOrCreate?: stateCreateOrConnectWithoutaddressInput
  }

  export type companyCreateManyWithoutAddressInput = {
    create?: Enumerable<companyCreateWithoutAddressInput>
    connect?: Enumerable<companyWhereUniqueInput>
    connectOrCreate?: Enumerable<companyCreateOrConnectWithoutaddressInput>
  }

  export type farmCreateManyWithoutAddressInput = {
    create?: Enumerable<farmCreateWithoutAddressInput>
    connect?: Enumerable<farmWhereUniqueInput>
    connectOrCreate?: Enumerable<farmCreateOrConnectWithoutaddressInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type stateUpdateOneRequiredWithoutAddressInput = {
    create?: stateCreateWithoutAddressInput
    connect?: stateWhereUniqueInput
    update?: stateUpdateWithoutAddressInput
    upsert?: stateUpsertWithoutAddressInput
    connectOrCreate?: stateCreateOrConnectWithoutaddressInput
  }

  export type companyUpdateManyWithoutAddressInput = {
    create?: Enumerable<companyCreateWithoutAddressInput>
    connect?: Enumerable<companyWhereUniqueInput>
    set?: Enumerable<companyWhereUniqueInput>
    disconnect?: Enumerable<companyWhereUniqueInput>
    delete?: Enumerable<companyWhereUniqueInput>
    update?: Enumerable<companyUpdateWithWhereUniqueWithoutAddressInput>
    updateMany?: Enumerable<companyUpdateManyWithWhereWithoutAddressInput>
    deleteMany?: Enumerable<companyScalarWhereInput>
    upsert?: Enumerable<companyUpsertWithWhereUniqueWithoutAddressInput>
    connectOrCreate?: Enumerable<companyCreateOrConnectWithoutaddressInput>
  }

  export type farmUpdateManyWithoutAddressInput = {
    create?: Enumerable<farmCreateWithoutAddressInput>
    connect?: Enumerable<farmWhereUniqueInput>
    set?: Enumerable<farmWhereUniqueInput>
    disconnect?: Enumerable<farmWhereUniqueInput>
    delete?: Enumerable<farmWhereUniqueInput>
    update?: Enumerable<farmUpdateWithWhereUniqueWithoutAddressInput>
    updateMany?: Enumerable<farmUpdateManyWithWhereWithoutAddressInput>
    deleteMany?: Enumerable<farmScalarWhereInput>
    upsert?: Enumerable<farmUpsertWithWhereUniqueWithoutAddressInput>
    connectOrCreate?: Enumerable<farmCreateOrConnectWithoutaddressInput>
  }

  export type farmCreateOneWithoutAreaInput = {
    create?: farmCreateWithoutAreaInput
    connect?: farmWhereUniqueInput
    connectOrCreate?: farmCreateOrConnectWithoutareaInput
  }

  export type fieldCreateManyWithoutAreaInput = {
    create?: Enumerable<fieldCreateWithoutAreaInput>
    connect?: Enumerable<fieldWhereUniqueInput>
    connectOrCreate?: Enumerable<fieldCreateOrConnectWithoutareaInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type farmUpdateOneRequiredWithoutAreaInput = {
    create?: farmCreateWithoutAreaInput
    connect?: farmWhereUniqueInput
    update?: farmUpdateWithoutAreaInput
    upsert?: farmUpsertWithoutAreaInput
    connectOrCreate?: farmCreateOrConnectWithoutareaInput
  }

  export type fieldUpdateManyWithoutAreaInput = {
    create?: Enumerable<fieldCreateWithoutAreaInput>
    connect?: Enumerable<fieldWhereUniqueInput>
    set?: Enumerable<fieldWhereUniqueInput>
    disconnect?: Enumerable<fieldWhereUniqueInput>
    delete?: Enumerable<fieldWhereUniqueInput>
    update?: Enumerable<fieldUpdateWithWhereUniqueWithoutAreaInput>
    updateMany?: Enumerable<fieldUpdateManyWithWhereWithoutAreaInput>
    deleteMany?: Enumerable<fieldScalarWhereInput>
    upsert?: Enumerable<fieldUpsertWithWhereUniqueWithoutAreaInput>
    connectOrCreate?: Enumerable<fieldCreateOrConnectWithoutareaInput>
  }

  export type addressCreateOneWithoutCompanyInput = {
    create?: addressCreateWithoutCompanyInput
    connect?: addressWhereUniqueInput
    connectOrCreate?: addressCreateOrConnectWithoutcompanyInput
  }

  export type quotationCreateManyWithoutCompanyInput = {
    create?: Enumerable<quotationCreateWithoutCompanyInput>
    connect?: Enumerable<quotationWhereUniqueInput>
    connectOrCreate?: Enumerable<quotationCreateOrConnectWithoutcompanyInput>
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type addressUpdateOneRequiredWithoutCompanyInput = {
    create?: addressCreateWithoutCompanyInput
    connect?: addressWhereUniqueInput
    update?: addressUpdateWithoutCompanyInput
    upsert?: addressUpsertWithoutCompanyInput
    connectOrCreate?: addressCreateOrConnectWithoutcompanyInput
  }

  export type quotationUpdateManyWithoutCompanyInput = {
    create?: Enumerable<quotationCreateWithoutCompanyInput>
    connect?: Enumerable<quotationWhereUniqueInput>
    set?: Enumerable<quotationWhereUniqueInput>
    disconnect?: Enumerable<quotationWhereUniqueInput>
    delete?: Enumerable<quotationWhereUniqueInput>
    update?: Enumerable<quotationUpdateWithWhereUniqueWithoutCompanyInput>
    updateMany?: Enumerable<quotationUpdateManyWithWhereWithoutCompanyInput>
    deleteMany?: Enumerable<quotationScalarWhereInput>
    upsert?: Enumerable<quotationUpsertWithWhereUniqueWithoutCompanyInput>
    connectOrCreate?: Enumerable<quotationCreateOrConnectWithoutcompanyInput>
  }

  export type fieldCreateOneWithoutCropInput = {
    create?: fieldCreateWithoutCropInput
    connect?: fieldWhereUniqueInput
    connectOrCreate?: fieldCreateOrConnectWithoutcropInput
  }

  export type diagnosisCreateManyWithoutCropInput = {
    create?: Enumerable<diagnosisCreateWithoutCropInput>
    connect?: Enumerable<diagnosisWhereUniqueInput>
    connectOrCreate?: Enumerable<diagnosisCreateOrConnectWithoutcropInput>
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type fieldUpdateOneRequiredWithoutCropInput = {
    create?: fieldCreateWithoutCropInput
    connect?: fieldWhereUniqueInput
    update?: fieldUpdateWithoutCropInput
    upsert?: fieldUpsertWithoutCropInput
    connectOrCreate?: fieldCreateOrConnectWithoutcropInput
  }

  export type diagnosisUpdateManyWithoutCropInput = {
    create?: Enumerable<diagnosisCreateWithoutCropInput>
    connect?: Enumerable<diagnosisWhereUniqueInput>
    set?: Enumerable<diagnosisWhereUniqueInput>
    disconnect?: Enumerable<diagnosisWhereUniqueInput>
    delete?: Enumerable<diagnosisWhereUniqueInput>
    update?: Enumerable<diagnosisUpdateWithWhereUniqueWithoutCropInput>
    updateMany?: Enumerable<diagnosisUpdateManyWithWhereWithoutCropInput>
    deleteMany?: Enumerable<diagnosisScalarWhereInput>
    upsert?: Enumerable<diagnosisUpsertWithWhereUniqueWithoutCropInput>
    connectOrCreate?: Enumerable<diagnosisCreateOrConnectWithoutcropInput>
  }

  export type cropCreateOneWithoutDiagnosisInput = {
    create?: cropCreateWithoutDiagnosisInput
    connect?: cropWhereUniqueInput
    connectOrCreate?: cropCreateOrConnectWithoutdiagnosisInput
  }

  export type infestationCreateManyWithoutDiagnosisInput = {
    create?: Enumerable<infestationCreateWithoutDiagnosisInput>
    connect?: Enumerable<infestationWhereUniqueInput>
    connectOrCreate?: Enumerable<infestationCreateOrConnectWithoutdiagnosisInput>
  }

  export type prescriptionCreateManyWithoutDiagnosisInput = {
    create?: Enumerable<prescriptionCreateWithoutDiagnosisInput>
    connect?: Enumerable<prescriptionWhereUniqueInput>
    connectOrCreate?: Enumerable<prescriptionCreateOrConnectWithoutdiagnosisInput>
  }

  export type cropUpdateOneWithoutDiagnosisInput = {
    create?: cropCreateWithoutDiagnosisInput
    connect?: cropWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: cropUpdateWithoutDiagnosisInput
    upsert?: cropUpsertWithoutDiagnosisInput
    connectOrCreate?: cropCreateOrConnectWithoutdiagnosisInput
  }

  export type infestationUpdateManyWithoutDiagnosisInput = {
    create?: Enumerable<infestationCreateWithoutDiagnosisInput>
    connect?: Enumerable<infestationWhereUniqueInput>
    set?: Enumerable<infestationWhereUniqueInput>
    disconnect?: Enumerable<infestationWhereUniqueInput>
    delete?: Enumerable<infestationWhereUniqueInput>
    update?: Enumerable<infestationUpdateWithWhereUniqueWithoutDiagnosisInput>
    updateMany?: Enumerable<infestationUpdateManyWithWhereWithoutDiagnosisInput>
    deleteMany?: Enumerable<infestationScalarWhereInput>
    upsert?: Enumerable<infestationUpsertWithWhereUniqueWithoutDiagnosisInput>
    connectOrCreate?: Enumerable<infestationCreateOrConnectWithoutdiagnosisInput>
  }

  export type prescriptionUpdateManyWithoutDiagnosisInput = {
    create?: Enumerable<prescriptionCreateWithoutDiagnosisInput>
    connect?: Enumerable<prescriptionWhereUniqueInput>
    set?: Enumerable<prescriptionWhereUniqueInput>
    disconnect?: Enumerable<prescriptionWhereUniqueInput>
    delete?: Enumerable<prescriptionWhereUniqueInput>
    update?: Enumerable<prescriptionUpdateWithWhereUniqueWithoutDiagnosisInput>
    updateMany?: Enumerable<prescriptionUpdateManyWithWhereWithoutDiagnosisInput>
    deleteMany?: Enumerable<prescriptionScalarWhereInput>
    upsert?: Enumerable<prescriptionUpsertWithWhereUniqueWithoutDiagnosisInput>
    connectOrCreate?: Enumerable<prescriptionCreateOrConnectWithoutdiagnosisInput>
  }

  export type addressCreateOneWithoutFarmInput = {
    create?: addressCreateWithoutFarmInput
    connect?: addressWhereUniqueInput
    connectOrCreate?: addressCreateOrConnectWithoutfarmInput
  }

  export type areaCreateManyWithoutFarmInput = {
    create?: Enumerable<areaCreateWithoutFarmInput>
    connect?: Enumerable<areaWhereUniqueInput>
    connectOrCreate?: Enumerable<areaCreateOrConnectWithoutfarmInput>
  }

  export type imagingCreateManyWithoutFarmInput = {
    create?: Enumerable<imagingCreateWithoutFarmInput>
    connect?: Enumerable<imagingWhereUniqueInput>
    connectOrCreate?: Enumerable<imagingCreateOrConnectWithoutfarmInput>
  }

  export type many_user_has_many_farmCreateManyWithoutFarmInput = {
    create?: Enumerable<many_user_has_many_farmCreateWithoutFarmInput>
    connect?: Enumerable<many_user_has_many_farmWhereUniqueInput>
    connectOrCreate?: Enumerable<many_user_has_many_farmCreateOrConnectWithoutfarmInput>
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type addressUpdateOneRequiredWithoutFarmInput = {
    create?: addressCreateWithoutFarmInput
    connect?: addressWhereUniqueInput
    update?: addressUpdateWithoutFarmInput
    upsert?: addressUpsertWithoutFarmInput
    connectOrCreate?: addressCreateOrConnectWithoutfarmInput
  }

  export type areaUpdateManyWithoutFarmInput = {
    create?: Enumerable<areaCreateWithoutFarmInput>
    connect?: Enumerable<areaWhereUniqueInput>
    set?: Enumerable<areaWhereUniqueInput>
    disconnect?: Enumerable<areaWhereUniqueInput>
    delete?: Enumerable<areaWhereUniqueInput>
    update?: Enumerable<areaUpdateWithWhereUniqueWithoutFarmInput>
    updateMany?: Enumerable<areaUpdateManyWithWhereWithoutFarmInput>
    deleteMany?: Enumerable<areaScalarWhereInput>
    upsert?: Enumerable<areaUpsertWithWhereUniqueWithoutFarmInput>
    connectOrCreate?: Enumerable<areaCreateOrConnectWithoutfarmInput>
  }

  export type imagingUpdateManyWithoutFarmInput = {
    create?: Enumerable<imagingCreateWithoutFarmInput>
    connect?: Enumerable<imagingWhereUniqueInput>
    set?: Enumerable<imagingWhereUniqueInput>
    disconnect?: Enumerable<imagingWhereUniqueInput>
    delete?: Enumerable<imagingWhereUniqueInput>
    update?: Enumerable<imagingUpdateWithWhereUniqueWithoutFarmInput>
    updateMany?: Enumerable<imagingUpdateManyWithWhereWithoutFarmInput>
    deleteMany?: Enumerable<imagingScalarWhereInput>
    upsert?: Enumerable<imagingUpsertWithWhereUniqueWithoutFarmInput>
    connectOrCreate?: Enumerable<imagingCreateOrConnectWithoutfarmInput>
  }

  export type many_user_has_many_farmUpdateManyWithoutFarmInput = {
    create?: Enumerable<many_user_has_many_farmCreateWithoutFarmInput>
    connect?: Enumerable<many_user_has_many_farmWhereUniqueInput>
    set?: Enumerable<many_user_has_many_farmWhereUniqueInput>
    disconnect?: Enumerable<many_user_has_many_farmWhereUniqueInput>
    delete?: Enumerable<many_user_has_many_farmWhereUniqueInput>
    update?: Enumerable<many_user_has_many_farmUpdateWithWhereUniqueWithoutFarmInput>
    updateMany?: Enumerable<many_user_has_many_farmUpdateManyWithWhereWithoutFarmInput>
    deleteMany?: Enumerable<many_user_has_many_farmScalarWhereInput>
    upsert?: Enumerable<many_user_has_many_farmUpsertWithWhereUniqueWithoutFarmInput>
    connectOrCreate?: Enumerable<many_user_has_many_farmCreateOrConnectWithoutfarmInput>
  }

  export type areaCreateOneWithoutFieldInput = {
    create?: areaCreateWithoutFieldInput
    connect?: areaWhereUniqueInput
    connectOrCreate?: areaCreateOrConnectWithoutfieldInput
  }

  export type cropCreateManyWithoutFieldInput = {
    create?: Enumerable<cropCreateWithoutFieldInput>
    connect?: Enumerable<cropWhereUniqueInput>
    connectOrCreate?: Enumerable<cropCreateOrConnectWithoutfieldInput>
  }

  export type many_quotation_modal_package_has_many_fieldCreateManyWithoutFieldInput = {
    create?: Enumerable<many_quotation_modal_package_has_many_fieldCreateWithoutFieldInput>
    connect?: Enumerable<many_quotation_modal_package_has_many_fieldWhereUniqueInput>
    connectOrCreate?: Enumerable<many_quotation_modal_package_has_many_fieldCreateOrConnectWithoutfieldInput>
  }

  export type areaUpdateOneRequiredWithoutFieldInput = {
    create?: areaCreateWithoutFieldInput
    connect?: areaWhereUniqueInput
    update?: areaUpdateWithoutFieldInput
    upsert?: areaUpsertWithoutFieldInput
    connectOrCreate?: areaCreateOrConnectWithoutfieldInput
  }

  export type cropUpdateManyWithoutFieldInput = {
    create?: Enumerable<cropCreateWithoutFieldInput>
    connect?: Enumerable<cropWhereUniqueInput>
    set?: Enumerable<cropWhereUniqueInput>
    disconnect?: Enumerable<cropWhereUniqueInput>
    delete?: Enumerable<cropWhereUniqueInput>
    update?: Enumerable<cropUpdateWithWhereUniqueWithoutFieldInput>
    updateMany?: Enumerable<cropUpdateManyWithWhereWithoutFieldInput>
    deleteMany?: Enumerable<cropScalarWhereInput>
    upsert?: Enumerable<cropUpsertWithWhereUniqueWithoutFieldInput>
    connectOrCreate?: Enumerable<cropCreateOrConnectWithoutfieldInput>
  }

  export type many_quotation_modal_package_has_many_fieldUpdateManyWithoutFieldInput = {
    create?: Enumerable<many_quotation_modal_package_has_many_fieldCreateWithoutFieldInput>
    connect?: Enumerable<many_quotation_modal_package_has_many_fieldWhereUniqueInput>
    set?: Enumerable<many_quotation_modal_package_has_many_fieldWhereUniqueInput>
    disconnect?: Enumerable<many_quotation_modal_package_has_many_fieldWhereUniqueInput>
    delete?: Enumerable<many_quotation_modal_package_has_many_fieldWhereUniqueInput>
    update?: Enumerable<many_quotation_modal_package_has_many_fieldUpdateWithWhereUniqueWithoutFieldInput>
    updateMany?: Enumerable<many_quotation_modal_package_has_many_fieldUpdateManyWithWhereWithoutFieldInput>
    deleteMany?: Enumerable<many_quotation_modal_package_has_many_fieldScalarWhereInput>
    upsert?: Enumerable<many_quotation_modal_package_has_many_fieldUpsertWithWhereUniqueWithoutFieldInput>
    connectOrCreate?: Enumerable<many_quotation_modal_package_has_many_fieldCreateOrConnectWithoutfieldInput>
  }

  export type farmCreateOneWithoutImagingInput = {
    create?: farmCreateWithoutImagingInput
    connect?: farmWhereUniqueInput
    connectOrCreate?: farmCreateOrConnectWithoutimagingInput
  }

  export type farmUpdateOneWithoutImagingInput = {
    create?: farmCreateWithoutImagingInput
    connect?: farmWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: farmUpdateWithoutImagingInput
    upsert?: farmUpsertWithoutImagingInput
    connectOrCreate?: farmCreateOrConnectWithoutimagingInput
  }

  export type diagnosisCreateOneWithoutInfestationInput = {
    create?: diagnosisCreateWithoutInfestationInput
    connect?: diagnosisWhereUniqueInput
    connectOrCreate?: diagnosisCreateOrConnectWithoutinfestationInput
  }

  export type plagueCreateOneWithoutInfestationInput = {
    create?: plagueCreateWithoutInfestationInput
    connect?: plagueWhereUniqueInput
    connectOrCreate?: plagueCreateOrConnectWithoutinfestationInput
  }

  export type diagnosisUpdateOneRequiredWithoutInfestationInput = {
    create?: diagnosisCreateWithoutInfestationInput
    connect?: diagnosisWhereUniqueInput
    update?: diagnosisUpdateWithoutInfestationInput
    upsert?: diagnosisUpsertWithoutInfestationInput
    connectOrCreate?: diagnosisCreateOrConnectWithoutinfestationInput
  }

  export type plagueUpdateOneRequiredWithoutInfestationInput = {
    create?: plagueCreateWithoutInfestationInput
    connect?: plagueWhereUniqueInput
    update?: plagueUpdateWithoutInfestationInput
    upsert?: plagueUpsertWithoutInfestationInput
    connectOrCreate?: plagueCreateOrConnectWithoutinfestationInput
  }

  export type fieldCreateOneWithoutMany_quotation_modal_package_has_many_fieldInput = {
    create?: fieldCreateWithoutMany_quotation_modal_package_has_many_fieldInput
    connect?: fieldWhereUniqueInput
    connectOrCreate?: fieldCreateOrConnectWithoutmany_quotation_modal_package_has_many_fieldInput
  }

  export type quotation_modal_packageCreateOneWithoutMany_quotation_modal_package_has_many_fieldInput = {
    create?: quotation_modal_packageCreateWithoutMany_quotation_modal_package_has_many_fieldInput
    connect?: quotation_modal_packageWhereUniqueInput
    connectOrCreate?: quotation_modal_packageCreateOrConnectWithoutmany_quotation_modal_package_has_many_fieldInput
  }

  export type fieldUpdateOneRequiredWithoutMany_quotation_modal_package_has_many_fieldInput = {
    create?: fieldCreateWithoutMany_quotation_modal_package_has_many_fieldInput
    connect?: fieldWhereUniqueInput
    update?: fieldUpdateWithoutMany_quotation_modal_package_has_many_fieldInput
    upsert?: fieldUpsertWithoutMany_quotation_modal_package_has_many_fieldInput
    connectOrCreate?: fieldCreateOrConnectWithoutmany_quotation_modal_package_has_many_fieldInput
  }

  export type quotation_modal_packageUpdateOneRequiredWithoutMany_quotation_modal_package_has_many_fieldInput = {
    create?: quotation_modal_packageCreateWithoutMany_quotation_modal_package_has_many_fieldInput
    connect?: quotation_modal_packageWhereUniqueInput
    update?: quotation_modal_packageUpdateWithoutMany_quotation_modal_package_has_many_fieldInput
    upsert?: quotation_modal_packageUpsertWithoutMany_quotation_modal_package_has_many_fieldInput
    connectOrCreate?: quotation_modal_packageCreateOrConnectWithoutmany_quotation_modal_package_has_many_fieldInput
  }

  export type farmCreateOneWithoutMany_user_has_many_farmInput = {
    create?: farmCreateWithoutMany_user_has_many_farmInput
    connect?: farmWhereUniqueInput
    connectOrCreate?: farmCreateOrConnectWithoutmany_user_has_many_farmInput
  }

  export type userCreateOneWithoutMany_user_has_many_farmInput = {
    create?: userCreateWithoutMany_user_has_many_farmInput
    connect?: userWhereUniqueInput
    connectOrCreate?: userCreateOrConnectWithoutmany_user_has_many_farmInput
  }

  export type farmUpdateOneRequiredWithoutMany_user_has_many_farmInput = {
    create?: farmCreateWithoutMany_user_has_many_farmInput
    connect?: farmWhereUniqueInput
    update?: farmUpdateWithoutMany_user_has_many_farmInput
    upsert?: farmUpsertWithoutMany_user_has_many_farmInput
    connectOrCreate?: farmCreateOrConnectWithoutmany_user_has_many_farmInput
  }

  export type userUpdateOneRequiredWithoutMany_user_has_many_farmInput = {
    create?: userCreateWithoutMany_user_has_many_farmInput
    connect?: userWhereUniqueInput
    update?: userUpdateWithoutMany_user_has_many_farmInput
    upsert?: userUpsertWithoutMany_user_has_many_farmInput
    connectOrCreate?: userCreateOrConnectWithoutmany_user_has_many_farmInput
  }

  export type userCreateOneWithoutNotificationInput = {
    create?: userCreateWithoutNotificationInput
    connect?: userWhereUniqueInput
    connectOrCreate?: userCreateOrConnectWithoutnotificationInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type userUpdateOneRequiredWithoutNotificationInput = {
    create?: userCreateWithoutNotificationInput
    connect?: userWhereUniqueInput
    update?: userUpdateWithoutNotificationInput
    upsert?: userUpsertWithoutNotificationInput
    connectOrCreate?: userCreateOrConnectWithoutnotificationInput
  }

  export type infestationCreateManyWithoutPlagueInput = {
    create?: Enumerable<infestationCreateWithoutPlagueInput>
    connect?: Enumerable<infestationWhereUniqueInput>
    connectOrCreate?: Enumerable<infestationCreateOrConnectWithoutplagueInput>
  }

  export type infestationUpdateManyWithoutPlagueInput = {
    create?: Enumerable<infestationCreateWithoutPlagueInput>
    connect?: Enumerable<infestationWhereUniqueInput>
    set?: Enumerable<infestationWhereUniqueInput>
    disconnect?: Enumerable<infestationWhereUniqueInput>
    delete?: Enumerable<infestationWhereUniqueInput>
    update?: Enumerable<infestationUpdateWithWhereUniqueWithoutPlagueInput>
    updateMany?: Enumerable<infestationUpdateManyWithWhereWithoutPlagueInput>
    deleteMany?: Enumerable<infestationScalarWhereInput>
    upsert?: Enumerable<infestationUpsertWithWhereUniqueWithoutPlagueInput>
    connectOrCreate?: Enumerable<infestationCreateOrConnectWithoutplagueInput>
  }

  export type diagnosisCreateOneWithoutPrescriptionInput = {
    create?: diagnosisCreateWithoutPrescriptionInput
    connect?: diagnosisWhereUniqueInput
    connectOrCreate?: diagnosisCreateOrConnectWithoutprescriptionInput
  }

  export type diagnosisUpdateOneRequiredWithoutPrescriptionInput = {
    create?: diagnosisCreateWithoutPrescriptionInput
    connect?: diagnosisWhereUniqueInput
    update?: diagnosisUpdateWithoutPrescriptionInput
    upsert?: diagnosisUpsertWithoutPrescriptionInput
    connectOrCreate?: diagnosisCreateOrConnectWithoutprescriptionInput
  }

  export type user_accepted_privacy_policyCreateManyWithoutPrivacy_policyInput = {
    create?: Enumerable<user_accepted_privacy_policyCreateWithoutPrivacy_policyInput>
    connect?: Enumerable<user_accepted_privacy_policyWhereUniqueInput>
    connectOrCreate?: Enumerable<user_accepted_privacy_policyCreateOrConnectWithoutprivacy_policyInput>
  }

  export type user_accepted_privacy_policyUpdateManyWithoutPrivacy_policyInput = {
    create?: Enumerable<user_accepted_privacy_policyCreateWithoutPrivacy_policyInput>
    connect?: Enumerable<user_accepted_privacy_policyWhereUniqueInput>
    set?: Enumerable<user_accepted_privacy_policyWhereUniqueInput>
    disconnect?: Enumerable<user_accepted_privacy_policyWhereUniqueInput>
    delete?: Enumerable<user_accepted_privacy_policyWhereUniqueInput>
    update?: Enumerable<user_accepted_privacy_policyUpdateWithWhereUniqueWithoutPrivacy_policyInput>
    updateMany?: Enumerable<user_accepted_privacy_policyUpdateManyWithWhereWithoutPrivacy_policyInput>
    deleteMany?: Enumerable<user_accepted_privacy_policyScalarWhereInput>
    upsert?: Enumerable<user_accepted_privacy_policyUpsertWithWhereUniqueWithoutPrivacy_policyInput>
    connectOrCreate?: Enumerable<user_accepted_privacy_policyCreateOrConnectWithoutprivacy_policyInput>
  }

  export type companyCreateOneWithoutQuotationInput = {
    create?: companyCreateWithoutQuotationInput
    connect?: companyWhereUniqueInput
    connectOrCreate?: companyCreateOrConnectWithoutquotationInput
  }

  export type quotation_modal_packageCreateOneWithoutQuotationInput = {
    create?: quotation_modal_packageCreateWithoutQuotationInput
    connect?: quotation_modal_packageWhereUniqueInput
    connectOrCreate?: quotation_modal_packageCreateOrConnectWithoutquotationInput
  }

  export type quotation_checkoutCreateOneWithoutQuotationInput = {
    create?: quotation_checkoutCreateWithoutQuotationInput
    connect?: quotation_checkoutWhereUniqueInput
    connectOrCreate?: quotation_checkoutCreateOrConnectWithoutquotationInput
  }

  export type companyUpdateOneRequiredWithoutQuotationInput = {
    create?: companyCreateWithoutQuotationInput
    connect?: companyWhereUniqueInput
    update?: companyUpdateWithoutQuotationInput
    upsert?: companyUpsertWithoutQuotationInput
    connectOrCreate?: companyCreateOrConnectWithoutquotationInput
  }

  export type quotation_modal_packageUpdateOneRequiredWithoutQuotationInput = {
    create?: quotation_modal_packageCreateWithoutQuotationInput
    connect?: quotation_modal_packageWhereUniqueInput
    update?: quotation_modal_packageUpdateWithoutQuotationInput
    upsert?: quotation_modal_packageUpsertWithoutQuotationInput
    connectOrCreate?: quotation_modal_packageCreateOrConnectWithoutquotationInput
  }

  export type quotation_checkoutUpdateOneWithoutQuotationInput = {
    create?: quotation_checkoutCreateWithoutQuotationInput
    connect?: quotation_checkoutWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: quotation_checkoutUpdateWithoutQuotationInput
    upsert?: quotation_checkoutUpsertWithoutQuotationInput
    connectOrCreate?: quotation_checkoutCreateOrConnectWithoutquotationInput
  }

  export type quotationCreateOneWithoutQuotation_checkoutInput = {
    create?: quotationCreateWithoutQuotation_checkoutInput
    connect?: quotationWhereUniqueInput
    connectOrCreate?: quotationCreateOrConnectWithoutquotation_checkoutInput
  }

  export type quotationUpdateOneRequiredWithoutQuotation_checkoutInput = {
    create?: quotationCreateWithoutQuotation_checkoutInput
    connect?: quotationWhereUniqueInput
    update?: quotationUpdateWithoutQuotation_checkoutInput
    upsert?: quotationUpsertWithoutQuotation_checkoutInput
    connectOrCreate?: quotationCreateOrConnectWithoutquotation_checkoutInput
  }

  export type quotation_packageCreateOneWithoutQuotation_modal_packageInput = {
    create?: quotation_packageCreateWithoutQuotation_modal_packageInput
    connect?: quotation_packageWhereUniqueInput
    connectOrCreate?: quotation_packageCreateOrConnectWithoutquotation_modal_packageInput
  }

  export type many_quotation_modal_package_has_many_fieldCreateManyWithoutQuotation_modal_packageInput = {
    create?: Enumerable<many_quotation_modal_package_has_many_fieldCreateWithoutQuotation_modal_packageInput>
    connect?: Enumerable<many_quotation_modal_package_has_many_fieldWhereUniqueInput>
    connectOrCreate?: Enumerable<many_quotation_modal_package_has_many_fieldCreateOrConnectWithoutquotation_modal_packageInput>
  }

  export type quotationCreateManyWithoutQuotation_modal_packageInput = {
    create?: Enumerable<quotationCreateWithoutQuotation_modal_packageInput>
    connect?: Enumerable<quotationWhereUniqueInput>
    connectOrCreate?: Enumerable<quotationCreateOrConnectWithoutquotation_modal_packageInput>
  }

  export type quotation_packageUpdateOneRequiredWithoutQuotation_modal_packageInput = {
    create?: quotation_packageCreateWithoutQuotation_modal_packageInput
    connect?: quotation_packageWhereUniqueInput
    update?: quotation_packageUpdateWithoutQuotation_modal_packageInput
    upsert?: quotation_packageUpsertWithoutQuotation_modal_packageInput
    connectOrCreate?: quotation_packageCreateOrConnectWithoutquotation_modal_packageInput
  }

  export type many_quotation_modal_package_has_many_fieldUpdateManyWithoutQuotation_modal_packageInput = {
    create?: Enumerable<many_quotation_modal_package_has_many_fieldCreateWithoutQuotation_modal_packageInput>
    connect?: Enumerable<many_quotation_modal_package_has_many_fieldWhereUniqueInput>
    set?: Enumerable<many_quotation_modal_package_has_many_fieldWhereUniqueInput>
    disconnect?: Enumerable<many_quotation_modal_package_has_many_fieldWhereUniqueInput>
    delete?: Enumerable<many_quotation_modal_package_has_many_fieldWhereUniqueInput>
    update?: Enumerable<many_quotation_modal_package_has_many_fieldUpdateWithWhereUniqueWithoutQuotation_modal_packageInput>
    updateMany?: Enumerable<many_quotation_modal_package_has_many_fieldUpdateManyWithWhereWithoutQuotation_modal_packageInput>
    deleteMany?: Enumerable<many_quotation_modal_package_has_many_fieldScalarWhereInput>
    upsert?: Enumerable<many_quotation_modal_package_has_many_fieldUpsertWithWhereUniqueWithoutQuotation_modal_packageInput>
    connectOrCreate?: Enumerable<many_quotation_modal_package_has_many_fieldCreateOrConnectWithoutquotation_modal_packageInput>
  }

  export type quotationUpdateManyWithoutQuotation_modal_packageInput = {
    create?: Enumerable<quotationCreateWithoutQuotation_modal_packageInput>
    connect?: Enumerable<quotationWhereUniqueInput>
    set?: Enumerable<quotationWhereUniqueInput>
    disconnect?: Enumerable<quotationWhereUniqueInput>
    delete?: Enumerable<quotationWhereUniqueInput>
    update?: Enumerable<quotationUpdateWithWhereUniqueWithoutQuotation_modal_packageInput>
    updateMany?: Enumerable<quotationUpdateManyWithWhereWithoutQuotation_modal_packageInput>
    deleteMany?: Enumerable<quotationScalarWhereInput>
    upsert?: Enumerable<quotationUpsertWithWhereUniqueWithoutQuotation_modal_packageInput>
    connectOrCreate?: Enumerable<quotationCreateOrConnectWithoutquotation_modal_packageInput>
  }

  export type quotation_modal_packageCreateManyWithoutQuotation_packageInput = {
    create?: Enumerable<quotation_modal_packageCreateWithoutQuotation_packageInput>
    connect?: Enumerable<quotation_modal_packageWhereUniqueInput>
    connectOrCreate?: Enumerable<quotation_modal_packageCreateOrConnectWithoutquotation_packageInput>
  }

  export type quotation_modal_packageUpdateManyWithoutQuotation_packageInput = {
    create?: Enumerable<quotation_modal_packageCreateWithoutQuotation_packageInput>
    connect?: Enumerable<quotation_modal_packageWhereUniqueInput>
    set?: Enumerable<quotation_modal_packageWhereUniqueInput>
    disconnect?: Enumerable<quotation_modal_packageWhereUniqueInput>
    delete?: Enumerable<quotation_modal_packageWhereUniqueInput>
    update?: Enumerable<quotation_modal_packageUpdateWithWhereUniqueWithoutQuotation_packageInput>
    updateMany?: Enumerable<quotation_modal_packageUpdateManyWithWhereWithoutQuotation_packageInput>
    deleteMany?: Enumerable<quotation_modal_packageScalarWhereInput>
    upsert?: Enumerable<quotation_modal_packageUpsertWithWhereUniqueWithoutQuotation_packageInput>
    connectOrCreate?: Enumerable<quotation_modal_packageCreateOrConnectWithoutquotation_packageInput>
  }

  export type user_roleCreateManyWithoutRoleInput = {
    create?: Enumerable<user_roleCreateWithoutRoleInput>
    connect?: Enumerable<user_roleWhereUniqueInput>
    connectOrCreate?: Enumerable<user_roleCreateOrConnectWithoutroleInput>
  }

  export type user_roleUpdateManyWithoutRoleInput = {
    create?: Enumerable<user_roleCreateWithoutRoleInput>
    connect?: Enumerable<user_roleWhereUniqueInput>
    set?: Enumerable<user_roleWhereUniqueInput>
    disconnect?: Enumerable<user_roleWhereUniqueInput>
    delete?: Enumerable<user_roleWhereUniqueInput>
    update?: Enumerable<user_roleUpdateWithWhereUniqueWithoutRoleInput>
    updateMany?: Enumerable<user_roleUpdateManyWithWhereWithoutRoleInput>
    deleteMany?: Enumerable<user_roleScalarWhereInput>
    upsert?: Enumerable<user_roleUpsertWithWhereUniqueWithoutRoleInput>
    connectOrCreate?: Enumerable<user_roleCreateOrConnectWithoutroleInput>
  }

  export type addressCreateManyWithoutStateInput = {
    create?: Enumerable<addressCreateWithoutStateInput>
    connect?: Enumerable<addressWhereUniqueInput>
    connectOrCreate?: Enumerable<addressCreateOrConnectWithoutstateInput>
  }

  export type addressUpdateManyWithoutStateInput = {
    create?: Enumerable<addressCreateWithoutStateInput>
    connect?: Enumerable<addressWhereUniqueInput>
    set?: Enumerable<addressWhereUniqueInput>
    disconnect?: Enumerable<addressWhereUniqueInput>
    delete?: Enumerable<addressWhereUniqueInput>
    update?: Enumerable<addressUpdateWithWhereUniqueWithoutStateInput>
    updateMany?: Enumerable<addressUpdateManyWithWhereWithoutStateInput>
    deleteMany?: Enumerable<addressScalarWhereInput>
    upsert?: Enumerable<addressUpsertWithWhereUniqueWithoutStateInput>
    connectOrCreate?: Enumerable<addressCreateOrConnectWithoutstateInput>
  }

  export type user_accepted_termsCreateManyWithoutTerms_and_conditionsInput = {
    create?: Enumerable<user_accepted_termsCreateWithoutTerms_and_conditionsInput>
    connect?: Enumerable<user_accepted_termsWhereUniqueInput>
    connectOrCreate?: Enumerable<user_accepted_termsCreateOrConnectWithoutterms_and_conditionsInput>
  }

  export type user_accepted_termsUpdateManyWithoutTerms_and_conditionsInput = {
    create?: Enumerable<user_accepted_termsCreateWithoutTerms_and_conditionsInput>
    connect?: Enumerable<user_accepted_termsWhereUniqueInput>
    set?: Enumerable<user_accepted_termsWhereUniqueInput>
    disconnect?: Enumerable<user_accepted_termsWhereUniqueInput>
    delete?: Enumerable<user_accepted_termsWhereUniqueInput>
    update?: Enumerable<user_accepted_termsUpdateWithWhereUniqueWithoutTerms_and_conditionsInput>
    updateMany?: Enumerable<user_accepted_termsUpdateManyWithWhereWithoutTerms_and_conditionsInput>
    deleteMany?: Enumerable<user_accepted_termsScalarWhereInput>
    upsert?: Enumerable<user_accepted_termsUpsertWithWhereUniqueWithoutTerms_and_conditionsInput>
    connectOrCreate?: Enumerable<user_accepted_termsCreateOrConnectWithoutterms_and_conditionsInput>
  }

  export type many_user_has_many_farmCreateManyWithoutUserInput = {
    create?: Enumerable<many_user_has_many_farmCreateWithoutUserInput>
    connect?: Enumerable<many_user_has_many_farmWhereUniqueInput>
    connectOrCreate?: Enumerable<many_user_has_many_farmCreateOrConnectWithoutuserInput>
  }

  export type notificationCreateManyWithoutUserInput = {
    create?: Enumerable<notificationCreateWithoutUserInput>
    connect?: Enumerable<notificationWhereUniqueInput>
    connectOrCreate?: Enumerable<notificationCreateOrConnectWithoutuserInput>
  }

  export type user_accepted_privacy_policyCreateManyWithoutUserInput = {
    create?: Enumerable<user_accepted_privacy_policyCreateWithoutUserInput>
    connect?: Enumerable<user_accepted_privacy_policyWhereUniqueInput>
    connectOrCreate?: Enumerable<user_accepted_privacy_policyCreateOrConnectWithoutuserInput>
  }

  export type user_accepted_termsCreateManyWithoutUserInput = {
    create?: Enumerable<user_accepted_termsCreateWithoutUserInput>
    connect?: Enumerable<user_accepted_termsWhereUniqueInput>
    connectOrCreate?: Enumerable<user_accepted_termsCreateOrConnectWithoutuserInput>
  }

  export type user_roleCreateManyWithoutUserInput = {
    create?: Enumerable<user_roleCreateWithoutUserInput>
    connect?: Enumerable<user_roleWhereUniqueInput>
    connectOrCreate?: Enumerable<user_roleCreateOrConnectWithoutuserInput>
  }

  export type many_user_has_many_farmUpdateManyWithoutUserInput = {
    create?: Enumerable<many_user_has_many_farmCreateWithoutUserInput>
    connect?: Enumerable<many_user_has_many_farmWhereUniqueInput>
    set?: Enumerable<many_user_has_many_farmWhereUniqueInput>
    disconnect?: Enumerable<many_user_has_many_farmWhereUniqueInput>
    delete?: Enumerable<many_user_has_many_farmWhereUniqueInput>
    update?: Enumerable<many_user_has_many_farmUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<many_user_has_many_farmUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<many_user_has_many_farmScalarWhereInput>
    upsert?: Enumerable<many_user_has_many_farmUpsertWithWhereUniqueWithoutUserInput>
    connectOrCreate?: Enumerable<many_user_has_many_farmCreateOrConnectWithoutuserInput>
  }

  export type notificationUpdateManyWithoutUserInput = {
    create?: Enumerable<notificationCreateWithoutUserInput>
    connect?: Enumerable<notificationWhereUniqueInput>
    set?: Enumerable<notificationWhereUniqueInput>
    disconnect?: Enumerable<notificationWhereUniqueInput>
    delete?: Enumerable<notificationWhereUniqueInput>
    update?: Enumerable<notificationUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<notificationUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<notificationScalarWhereInput>
    upsert?: Enumerable<notificationUpsertWithWhereUniqueWithoutUserInput>
    connectOrCreate?: Enumerable<notificationCreateOrConnectWithoutuserInput>
  }

  export type user_accepted_privacy_policyUpdateManyWithoutUserInput = {
    create?: Enumerable<user_accepted_privacy_policyCreateWithoutUserInput>
    connect?: Enumerable<user_accepted_privacy_policyWhereUniqueInput>
    set?: Enumerable<user_accepted_privacy_policyWhereUniqueInput>
    disconnect?: Enumerable<user_accepted_privacy_policyWhereUniqueInput>
    delete?: Enumerable<user_accepted_privacy_policyWhereUniqueInput>
    update?: Enumerable<user_accepted_privacy_policyUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<user_accepted_privacy_policyUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<user_accepted_privacy_policyScalarWhereInput>
    upsert?: Enumerable<user_accepted_privacy_policyUpsertWithWhereUniqueWithoutUserInput>
    connectOrCreate?: Enumerable<user_accepted_privacy_policyCreateOrConnectWithoutuserInput>
  }

  export type user_accepted_termsUpdateManyWithoutUserInput = {
    create?: Enumerable<user_accepted_termsCreateWithoutUserInput>
    connect?: Enumerable<user_accepted_termsWhereUniqueInput>
    set?: Enumerable<user_accepted_termsWhereUniqueInput>
    disconnect?: Enumerable<user_accepted_termsWhereUniqueInput>
    delete?: Enumerable<user_accepted_termsWhereUniqueInput>
    update?: Enumerable<user_accepted_termsUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<user_accepted_termsUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<user_accepted_termsScalarWhereInput>
    upsert?: Enumerable<user_accepted_termsUpsertWithWhereUniqueWithoutUserInput>
    connectOrCreate?: Enumerable<user_accepted_termsCreateOrConnectWithoutuserInput>
  }

  export type user_roleUpdateManyWithoutUserInput = {
    create?: Enumerable<user_roleCreateWithoutUserInput>
    connect?: Enumerable<user_roleWhereUniqueInput>
    set?: Enumerable<user_roleWhereUniqueInput>
    disconnect?: Enumerable<user_roleWhereUniqueInput>
    delete?: Enumerable<user_roleWhereUniqueInput>
    update?: Enumerable<user_roleUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<user_roleUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<user_roleScalarWhereInput>
    upsert?: Enumerable<user_roleUpsertWithWhereUniqueWithoutUserInput>
    connectOrCreate?: Enumerable<user_roleCreateOrConnectWithoutuserInput>
  }

  export type privacy_policyCreateOneWithoutUser_accepted_privacy_policyInput = {
    create?: privacy_policyCreateWithoutUser_accepted_privacy_policyInput
    connect?: privacy_policyWhereUniqueInput
    connectOrCreate?: privacy_policyCreateOrConnectWithoutuser_accepted_privacy_policyInput
  }

  export type userCreateOneWithoutUser_accepted_privacy_policyInput = {
    create?: userCreateWithoutUser_accepted_privacy_policyInput
    connect?: userWhereUniqueInput
    connectOrCreate?: userCreateOrConnectWithoutuser_accepted_privacy_policyInput
  }

  export type privacy_policyUpdateOneRequiredWithoutUser_accepted_privacy_policyInput = {
    create?: privacy_policyCreateWithoutUser_accepted_privacy_policyInput
    connect?: privacy_policyWhereUniqueInput
    update?: privacy_policyUpdateWithoutUser_accepted_privacy_policyInput
    upsert?: privacy_policyUpsertWithoutUser_accepted_privacy_policyInput
    connectOrCreate?: privacy_policyCreateOrConnectWithoutuser_accepted_privacy_policyInput
  }

  export type userUpdateOneRequiredWithoutUser_accepted_privacy_policyInput = {
    create?: userCreateWithoutUser_accepted_privacy_policyInput
    connect?: userWhereUniqueInput
    update?: userUpdateWithoutUser_accepted_privacy_policyInput
    upsert?: userUpsertWithoutUser_accepted_privacy_policyInput
    connectOrCreate?: userCreateOrConnectWithoutuser_accepted_privacy_policyInput
  }

  export type terms_and_conditionsCreateOneWithoutUser_accepted_termsInput = {
    create?: terms_and_conditionsCreateWithoutUser_accepted_termsInput
    connect?: terms_and_conditionsWhereUniqueInput
    connectOrCreate?: terms_and_conditionsCreateOrConnectWithoutuser_accepted_termsInput
  }

  export type userCreateOneWithoutUser_accepted_termsInput = {
    create?: userCreateWithoutUser_accepted_termsInput
    connect?: userWhereUniqueInput
    connectOrCreate?: userCreateOrConnectWithoutuser_accepted_termsInput
  }

  export type terms_and_conditionsUpdateOneRequiredWithoutUser_accepted_termsInput = {
    create?: terms_and_conditionsCreateWithoutUser_accepted_termsInput
    connect?: terms_and_conditionsWhereUniqueInput
    update?: terms_and_conditionsUpdateWithoutUser_accepted_termsInput
    upsert?: terms_and_conditionsUpsertWithoutUser_accepted_termsInput
    connectOrCreate?: terms_and_conditionsCreateOrConnectWithoutuser_accepted_termsInput
  }

  export type userUpdateOneRequiredWithoutUser_accepted_termsInput = {
    create?: userCreateWithoutUser_accepted_termsInput
    connect?: userWhereUniqueInput
    update?: userUpdateWithoutUser_accepted_termsInput
    upsert?: userUpsertWithoutUser_accepted_termsInput
    connectOrCreate?: userCreateOrConnectWithoutuser_accepted_termsInput
  }

  export type roleCreateOneWithoutUser_roleInput = {
    create?: roleCreateWithoutUser_roleInput
    connect?: roleWhereUniqueInput
    connectOrCreate?: roleCreateOrConnectWithoutuser_roleInput
  }

  export type userCreateOneWithoutUser_roleInput = {
    create?: userCreateWithoutUser_roleInput
    connect?: userWhereUniqueInput
    connectOrCreate?: userCreateOrConnectWithoutuser_roleInput
  }

  export type roleUpdateOneRequiredWithoutUser_roleInput = {
    create?: roleCreateWithoutUser_roleInput
    connect?: roleWhereUniqueInput
    update?: roleUpdateWithoutUser_roleInput
    upsert?: roleUpsertWithoutUser_roleInput
    connectOrCreate?: roleCreateOrConnectWithoutuser_roleInput
  }

  export type userUpdateOneRequiredWithoutUser_roleInput = {
    create?: userCreateWithoutUser_roleInput
    connect?: userWhereUniqueInput
    update?: userUpdateWithoutUser_roleInput
    upsert?: userUpsertWithoutUser_roleInput
    connectOrCreate?: userCreateOrConnectWithoutuser_roleInput
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedBoolNullableFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableFilter | boolean | null
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type stateCreateWithoutAddressInput = {
    initials: string
    name: string
    ibge_code?: number | null
    country_code?: number | null
    area_code?: InputJsonValue | null
  }

  export type stateCreateOrConnectWithoutaddressInput = {
    where: stateWhereUniqueInput
    create: stateCreateWithoutAddressInput
  }

  export type companyCreateWithoutAddressInput = {
    name: string
    works_with_drone: boolean
    works_with_plane: boolean
    works_with_tractor: boolean
    lat: number
    long: number
    quotation?: quotationCreateManyWithoutCompanyInput
  }

  export type companyCreateOrConnectWithoutaddressInput = {
    where: companyWhereUniqueInput
    create: companyCreateWithoutAddressInput
  }

  export type farmCreateWithoutAddressInput = {
    cnpj?: string | null
    social_name?: string | null
    fantasy_name: string
    lat?: number | null
    long?: number | null
    area?: areaCreateManyWithoutFarmInput
    imaging?: imagingCreateManyWithoutFarmInput
    many_user_has_many_farm?: many_user_has_many_farmCreateManyWithoutFarmInput
  }

  export type farmCreateOrConnectWithoutaddressInput = {
    where: farmWhereUniqueInput
    create: farmCreateWithoutAddressInput
  }

  export type stateUpdateWithoutAddressInput = {
    initials?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ibge_code?: NullableIntFieldUpdateOperationsInput | number | null
    country_code?: NullableIntFieldUpdateOperationsInput | number | null
    area_code?: InputJsonValue | null
  }

  export type stateUpsertWithoutAddressInput = {
    update: stateUpdateWithoutAddressInput
    create: stateCreateWithoutAddressInput
  }

  export type companyUpdateWithWhereUniqueWithoutAddressInput = {
    where: companyWhereUniqueInput
    data: companyUpdateWithoutAddressInput
  }

  export type companyUpdateManyWithWhereWithoutAddressInput = {
    where: companyScalarWhereInput
    data: companyUpdateManyMutationInput
  }

  export type companyScalarWhereInput = {
    AND?: Enumerable<companyScalarWhereInput>
    OR?: Enumerable<companyScalarWhereInput>
    NOT?: Enumerable<companyScalarWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    works_with_drone?: BoolFilter | boolean
    works_with_plane?: BoolFilter | boolean
    works_with_tractor?: BoolFilter | boolean
    lat?: FloatFilter | number
    long?: FloatFilter | number
    address_id?: IntFilter | number
  }

  export type companyUpsertWithWhereUniqueWithoutAddressInput = {
    where: companyWhereUniqueInput
    update: companyUpdateWithoutAddressInput
    create: companyCreateWithoutAddressInput
  }

  export type farmUpdateWithWhereUniqueWithoutAddressInput = {
    where: farmWhereUniqueInput
    data: farmUpdateWithoutAddressInput
  }

  export type farmUpdateManyWithWhereWithoutAddressInput = {
    where: farmScalarWhereInput
    data: farmUpdateManyMutationInput
  }

  export type farmScalarWhereInput = {
    AND?: Enumerable<farmScalarWhereInput>
    OR?: Enumerable<farmScalarWhereInput>
    NOT?: Enumerable<farmScalarWhereInput>
    id?: IntFilter | number
    cnpj?: StringNullableFilter | string | null
    social_name?: StringNullableFilter | string | null
    fantasy_name?: StringFilter | string
    lat?: FloatNullableFilter | number | null
    long?: FloatNullableFilter | number | null
    address_id?: IntFilter | number
  }

  export type farmUpsertWithWhereUniqueWithoutAddressInput = {
    where: farmWhereUniqueInput
    update: farmUpdateWithoutAddressInput
    create: farmCreateWithoutAddressInput
  }

  export type farmCreateWithoutAreaInput = {
    cnpj?: string | null
    social_name?: string | null
    fantasy_name: string
    lat?: number | null
    long?: number | null
    address: addressCreateOneWithoutFarmInput
    imaging?: imagingCreateManyWithoutFarmInput
    many_user_has_many_farm?: many_user_has_many_farmCreateManyWithoutFarmInput
  }

  export type farmCreateOrConnectWithoutareaInput = {
    where: farmWhereUniqueInput
    create: farmCreateWithoutAreaInput
  }

  export type fieldCreateWithoutAreaInput = {
    code: number
    area_ha: number
    lat: number
    long: number
    coordinates: InputJsonValue
    name: string
    image_uri?: string | null
    visiona_area_id?: number | null
    event?: string | null
    crop?: cropCreateManyWithoutFieldInput
    many_quotation_modal_package_has_many_field?: many_quotation_modal_package_has_many_fieldCreateManyWithoutFieldInput
  }

  export type fieldCreateOrConnectWithoutareaInput = {
    where: fieldWhereUniqueInput
    create: fieldCreateWithoutAreaInput
  }

  export type farmUpdateWithoutAreaInput = {
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    social_name?: NullableStringFieldUpdateOperationsInput | string | null
    fantasy_name?: StringFieldUpdateOperationsInput | string
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    long?: NullableFloatFieldUpdateOperationsInput | number | null
    address?: addressUpdateOneRequiredWithoutFarmInput
    imaging?: imagingUpdateManyWithoutFarmInput
    many_user_has_many_farm?: many_user_has_many_farmUpdateManyWithoutFarmInput
  }

  export type farmUpsertWithoutAreaInput = {
    update: farmUpdateWithoutAreaInput
    create: farmCreateWithoutAreaInput
  }

  export type fieldUpdateWithWhereUniqueWithoutAreaInput = {
    where: fieldWhereUniqueInput
    data: fieldUpdateWithoutAreaInput
  }

  export type fieldUpdateManyWithWhereWithoutAreaInput = {
    where: fieldScalarWhereInput
    data: fieldUpdateManyMutationInput
  }

  export type fieldScalarWhereInput = {
    AND?: Enumerable<fieldScalarWhereInput>
    OR?: Enumerable<fieldScalarWhereInput>
    NOT?: Enumerable<fieldScalarWhereInput>
    id?: IntFilter | number
    code?: IntFilter | number
    area_ha?: FloatFilter | number
    lat?: FloatFilter | number
    long?: FloatFilter | number
    coordinates?: JsonFilter
    name?: StringFilter | string
    image_uri?: StringNullableFilter | string | null
    area_id?: IntFilter | number
    visiona_area_id?: IntNullableFilter | number | null
    event?: StringNullableFilter | string | null
  }

  export type fieldUpsertWithWhereUniqueWithoutAreaInput = {
    where: fieldWhereUniqueInput
    update: fieldUpdateWithoutAreaInput
    create: fieldCreateWithoutAreaInput
  }

  export type addressCreateWithoutCompanyInput = {
    street: string
    city: string
    number?: number | null
    km?: number | null
    postal_code?: string | null
    complement?: string | null
    neighborhood?: string | null
    phone_number?: string | null
    contact_name?: string | null
    mobile_number?: string | null
    email?: string | null
    state: stateCreateOneWithoutAddressInput
    farm?: farmCreateManyWithoutAddressInput
  }

  export type addressCreateOrConnectWithoutcompanyInput = {
    where: addressWhereUniqueInput
    create: addressCreateWithoutCompanyInput
  }

  export type quotationCreateWithoutCompanyInput = {
    response_date?: Date | string | null
    expiration_date?: Date | string | null
    antecipated_price?: number | null
    cash_price?: number | null
    delayed_price?: number | null
    quotation_modal_package: quotation_modal_packageCreateOneWithoutQuotationInput
    quotation_checkout?: quotation_checkoutCreateOneWithoutQuotationInput
  }

  export type quotationCreateOrConnectWithoutcompanyInput = {
    where: quotationWhereUniqueInput
    create: quotationCreateWithoutCompanyInput
  }

  export type addressUpdateWithoutCompanyInput = {
    street?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    number?: NullableIntFieldUpdateOperationsInput | number | null
    km?: NullableIntFieldUpdateOperationsInput | number | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    contact_name?: NullableStringFieldUpdateOperationsInput | string | null
    mobile_number?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    state?: stateUpdateOneRequiredWithoutAddressInput
    farm?: farmUpdateManyWithoutAddressInput
  }

  export type addressUpsertWithoutCompanyInput = {
    update: addressUpdateWithoutCompanyInput
    create: addressCreateWithoutCompanyInput
  }

  export type quotationUpdateWithWhereUniqueWithoutCompanyInput = {
    where: quotationWhereUniqueInput
    data: quotationUpdateWithoutCompanyInput
  }

  export type quotationUpdateManyWithWhereWithoutCompanyInput = {
    where: quotationScalarWhereInput
    data: quotationUpdateManyMutationInput
  }

  export type quotationScalarWhereInput = {
    AND?: Enumerable<quotationScalarWhereInput>
    OR?: Enumerable<quotationScalarWhereInput>
    NOT?: Enumerable<quotationScalarWhereInput>
    id?: IntFilter | number
    response_date?: DateTimeNullableFilter | Date | string | null
    expiration_date?: DateTimeNullableFilter | Date | string | null
    antecipated_price?: IntNullableFilter | number | null
    cash_price?: IntNullableFilter | number | null
    delayed_price?: IntNullableFilter | number | null
    company_id?: IntFilter | number
    quotation_modal_package_id?: IntFilter | number
  }

  export type quotationUpsertWithWhereUniqueWithoutCompanyInput = {
    where: quotationWhereUniqueInput
    update: quotationUpdateWithoutCompanyInput
    create: quotationCreateWithoutCompanyInput
  }

  export type fieldCreateWithoutCropInput = {
    code: number
    area_ha: number
    lat: number
    long: number
    coordinates: InputJsonValue
    name: string
    image_uri?: string | null
    visiona_area_id?: number | null
    event?: string | null
    area: areaCreateOneWithoutFieldInput
    many_quotation_modal_package_has_many_field?: many_quotation_modal_package_has_many_fieldCreateManyWithoutFieldInput
  }

  export type fieldCreateOrConnectWithoutcropInput = {
    where: fieldWhereUniqueInput
    create: fieldCreateWithoutCropInput
  }

  export type diagnosisCreateWithoutCropInput = {
    report_date: Date | string
    affected_area_ha: number
    infestation?: infestationCreateManyWithoutDiagnosisInput
    prescription?: prescriptionCreateManyWithoutDiagnosisInput
  }

  export type diagnosisCreateOrConnectWithoutcropInput = {
    where: diagnosisWhereUniqueInput
    create: diagnosisCreateWithoutCropInput
  }

  export type fieldUpdateWithoutCropInput = {
    code?: IntFieldUpdateOperationsInput | number
    area_ha?: FloatFieldUpdateOperationsInput | number
    lat?: FloatFieldUpdateOperationsInput | number
    long?: FloatFieldUpdateOperationsInput | number
    coordinates?: InputJsonValue
    name?: StringFieldUpdateOperationsInput | string
    image_uri?: NullableStringFieldUpdateOperationsInput | string | null
    visiona_area_id?: NullableIntFieldUpdateOperationsInput | number | null
    event?: NullableStringFieldUpdateOperationsInput | string | null
    area?: areaUpdateOneRequiredWithoutFieldInput
    many_quotation_modal_package_has_many_field?: many_quotation_modal_package_has_many_fieldUpdateManyWithoutFieldInput
  }

  export type fieldUpsertWithoutCropInput = {
    update: fieldUpdateWithoutCropInput
    create: fieldCreateWithoutCropInput
  }

  export type diagnosisUpdateWithWhereUniqueWithoutCropInput = {
    where: diagnosisWhereUniqueInput
    data: diagnosisUpdateWithoutCropInput
  }

  export type diagnosisUpdateManyWithWhereWithoutCropInput = {
    where: diagnosisScalarWhereInput
    data: diagnosisUpdateManyMutationInput
  }

  export type diagnosisScalarWhereInput = {
    AND?: Enumerable<diagnosisScalarWhereInput>
    OR?: Enumerable<diagnosisScalarWhereInput>
    NOT?: Enumerable<diagnosisScalarWhereInput>
    id?: IntFilter | number
    report_date?: DateTimeFilter | Date | string
    affected_area_ha?: FloatFilter | number
    crop_id?: IntNullableFilter | number | null
  }

  export type diagnosisUpsertWithWhereUniqueWithoutCropInput = {
    where: diagnosisWhereUniqueInput
    update: diagnosisUpdateWithoutCropInput
    create: diagnosisCreateWithoutCropInput
  }

  export type cropCreateWithoutDiagnosisInput = {
    crop_type: string
    variety: string
    sowing_date: Date | string
    expected_harvest_date: Date | string
    number?: number
    is_diagnosis_hired?: boolean | null
    field: fieldCreateOneWithoutCropInput
  }

  export type cropCreateOrConnectWithoutdiagnosisInput = {
    where: cropWhereUniqueInput
    create: cropCreateWithoutDiagnosisInput
  }

  export type infestationCreateWithoutDiagnosisInput = {
    area_ha?: number
    points?: InputJsonValue | null
    plague: plagueCreateOneWithoutInfestationInput
  }

  export type infestationCreateOrConnectWithoutdiagnosisInput = {
    where: infestationWhereUniqueInput
    create: infestationCreateWithoutDiagnosisInput
  }

  export type prescriptionCreateWithoutDiagnosisInput = {
    date: Date | string
    content?: InputJsonValue
    pulverization_method: number
    author?: string | null
    phone_number?: string | null
  }

  export type prescriptionCreateOrConnectWithoutdiagnosisInput = {
    where: prescriptionWhereUniqueInput
    create: prescriptionCreateWithoutDiagnosisInput
  }

  export type cropUpdateWithoutDiagnosisInput = {
    crop_type?: StringFieldUpdateOperationsInput | string
    variety?: StringFieldUpdateOperationsInput | string
    sowing_date?: DateTimeFieldUpdateOperationsInput | Date | string
    expected_harvest_date?: DateTimeFieldUpdateOperationsInput | Date | string
    number?: IntFieldUpdateOperationsInput | number
    is_diagnosis_hired?: NullableBoolFieldUpdateOperationsInput | boolean | null
    field?: fieldUpdateOneRequiredWithoutCropInput
  }

  export type cropUpsertWithoutDiagnosisInput = {
    update: cropUpdateWithoutDiagnosisInput
    create: cropCreateWithoutDiagnosisInput
  }

  export type infestationUpdateWithWhereUniqueWithoutDiagnosisInput = {
    where: infestationWhereUniqueInput
    data: infestationUpdateWithoutDiagnosisInput
  }

  export type infestationUpdateManyWithWhereWithoutDiagnosisInput = {
    where: infestationScalarWhereInput
    data: infestationUpdateManyMutationInput
  }

  export type infestationScalarWhereInput = {
    AND?: Enumerable<infestationScalarWhereInput>
    OR?: Enumerable<infestationScalarWhereInput>
    NOT?: Enumerable<infestationScalarWhereInput>
    id?: IntFilter | number
    area_ha?: FloatFilter | number
    points?: JsonNullableFilter
    diagnosis_id?: IntFilter | number
    plague_id?: IntFilter | number
  }

  export type infestationUpsertWithWhereUniqueWithoutDiagnosisInput = {
    where: infestationWhereUniqueInput
    update: infestationUpdateWithoutDiagnosisInput
    create: infestationCreateWithoutDiagnosisInput
  }

  export type prescriptionUpdateWithWhereUniqueWithoutDiagnosisInput = {
    where: prescriptionWhereUniqueInput
    data: prescriptionUpdateWithoutDiagnosisInput
  }

  export type prescriptionUpdateManyWithWhereWithoutDiagnosisInput = {
    where: prescriptionScalarWhereInput
    data: prescriptionUpdateManyMutationInput
  }

  export type prescriptionScalarWhereInput = {
    AND?: Enumerable<prescriptionScalarWhereInput>
    OR?: Enumerable<prescriptionScalarWhereInput>
    NOT?: Enumerable<prescriptionScalarWhereInput>
    id?: IntFilter | number
    date?: DateTimeFilter | Date | string
    content?: JsonFilter
    pulverization_method?: IntFilter | number
    author?: StringNullableFilter | string | null
    phone_number?: StringNullableFilter | string | null
    diagnosis_id?: IntFilter | number
  }

  export type prescriptionUpsertWithWhereUniqueWithoutDiagnosisInput = {
    where: prescriptionWhereUniqueInput
    update: prescriptionUpdateWithoutDiagnosisInput
    create: prescriptionCreateWithoutDiagnosisInput
  }

  export type addressCreateWithoutFarmInput = {
    street: string
    city: string
    number?: number | null
    km?: number | null
    postal_code?: string | null
    complement?: string | null
    neighborhood?: string | null
    phone_number?: string | null
    contact_name?: string | null
    mobile_number?: string | null
    email?: string | null
    state: stateCreateOneWithoutAddressInput
    company?: companyCreateManyWithoutAddressInput
  }

  export type addressCreateOrConnectWithoutfarmInput = {
    where: addressWhereUniqueInput
    create: addressCreateWithoutFarmInput
  }

  export type areaCreateWithoutFarmInput = {
    code: number
    lat: number
    long: number
    coordinates?: InputJsonValue | null
    name: string
    zone?: string | null
    state_initials?: string | null
    city?: string | null
    demand?: string | null
    field?: fieldCreateManyWithoutAreaInput
  }

  export type areaCreateOrConnectWithoutfarmInput = {
    where: areaWhereUniqueInput
    create: areaCreateWithoutFarmInput
  }

  export type imagingCreateWithoutFarmInput = {
    directory: string
    processing_timestamp: Date | string
    imaging_date: Date | string
  }

  export type imagingCreateOrConnectWithoutfarmInput = {
    where: imagingWhereUniqueInput
    create: imagingCreateWithoutFarmInput
  }

  export type many_user_has_many_farmCreateWithoutFarmInput = {
    user: userCreateOneWithoutMany_user_has_many_farmInput
  }

  export type many_user_has_many_farmCreateOrConnectWithoutfarmInput = {
    where: many_user_has_many_farmWhereUniqueInput
    create: many_user_has_many_farmCreateWithoutFarmInput
  }

  export type addressUpdateWithoutFarmInput = {
    street?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    number?: NullableIntFieldUpdateOperationsInput | number | null
    km?: NullableIntFieldUpdateOperationsInput | number | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    contact_name?: NullableStringFieldUpdateOperationsInput | string | null
    mobile_number?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    state?: stateUpdateOneRequiredWithoutAddressInput
    company?: companyUpdateManyWithoutAddressInput
  }

  export type addressUpsertWithoutFarmInput = {
    update: addressUpdateWithoutFarmInput
    create: addressCreateWithoutFarmInput
  }

  export type areaUpdateWithWhereUniqueWithoutFarmInput = {
    where: areaWhereUniqueInput
    data: areaUpdateWithoutFarmInput
  }

  export type areaUpdateManyWithWhereWithoutFarmInput = {
    where: areaScalarWhereInput
    data: areaUpdateManyMutationInput
  }

  export type areaScalarWhereInput = {
    AND?: Enumerable<areaScalarWhereInput>
    OR?: Enumerable<areaScalarWhereInput>
    NOT?: Enumerable<areaScalarWhereInput>
    id?: IntFilter | number
    code?: IntFilter | number
    lat?: FloatFilter | number
    long?: FloatFilter | number
    coordinates?: JsonNullableFilter
    name?: StringFilter | string
    zone?: StringNullableFilter | string | null
    state_initials?: StringNullableFilter | string | null
    city?: StringNullableFilter | string | null
    farm_id?: IntFilter | number
    demand?: StringNullableFilter | string | null
  }

  export type areaUpsertWithWhereUniqueWithoutFarmInput = {
    where: areaWhereUniqueInput
    update: areaUpdateWithoutFarmInput
    create: areaCreateWithoutFarmInput
  }

  export type imagingUpdateWithWhereUniqueWithoutFarmInput = {
    where: imagingWhereUniqueInput
    data: imagingUpdateWithoutFarmInput
  }

  export type imagingUpdateManyWithWhereWithoutFarmInput = {
    where: imagingScalarWhereInput
    data: imagingUpdateManyMutationInput
  }

  export type imagingScalarWhereInput = {
    AND?: Enumerable<imagingScalarWhereInput>
    OR?: Enumerable<imagingScalarWhereInput>
    NOT?: Enumerable<imagingScalarWhereInput>
    id?: IntFilter | number
    directory?: StringFilter | string
    processing_timestamp?: DateTimeFilter | Date | string
    imaging_date?: DateTimeFilter | Date | string
    farm_id?: IntNullableFilter | number | null
  }

  export type imagingUpsertWithWhereUniqueWithoutFarmInput = {
    where: imagingWhereUniqueInput
    update: imagingUpdateWithoutFarmInput
    create: imagingCreateWithoutFarmInput
  }

  export type many_user_has_many_farmUpdateWithWhereUniqueWithoutFarmInput = {
    where: many_user_has_many_farmWhereUniqueInput
    data: many_user_has_many_farmUpdateWithoutFarmInput
  }

  export type many_user_has_many_farmUpdateManyWithWhereWithoutFarmInput = {
    where: many_user_has_many_farmScalarWhereInput
    data: many_user_has_many_farmUpdateManyMutationInput
  }

  export type many_user_has_many_farmScalarWhereInput = {
    AND?: Enumerable<many_user_has_many_farmScalarWhereInput>
    OR?: Enumerable<many_user_has_many_farmScalarWhereInput>
    NOT?: Enumerable<many_user_has_many_farmScalarWhereInput>
    user_id?: IntFilter | number
    farm_id?: IntFilter | number
  }

  export type many_user_has_many_farmUpsertWithWhereUniqueWithoutFarmInput = {
    where: many_user_has_many_farmWhereUniqueInput
    update: many_user_has_many_farmUpdateWithoutFarmInput
    create: many_user_has_many_farmCreateWithoutFarmInput
  }

  export type areaCreateWithoutFieldInput = {
    code: number
    lat: number
    long: number
    coordinates?: InputJsonValue | null
    name: string
    zone?: string | null
    state_initials?: string | null
    city?: string | null
    demand?: string | null
    farm: farmCreateOneWithoutAreaInput
  }

  export type areaCreateOrConnectWithoutfieldInput = {
    where: areaWhereUniqueInput
    create: areaCreateWithoutFieldInput
  }

  export type cropCreateWithoutFieldInput = {
    crop_type: string
    variety: string
    sowing_date: Date | string
    expected_harvest_date: Date | string
    number?: number
    is_diagnosis_hired?: boolean | null
    diagnosis?: diagnosisCreateManyWithoutCropInput
  }

  export type cropCreateOrConnectWithoutfieldInput = {
    where: cropWhereUniqueInput
    create: cropCreateWithoutFieldInput
  }

  export type many_quotation_modal_package_has_many_fieldCreateWithoutFieldInput = {
    quotation_modal_package: quotation_modal_packageCreateOneWithoutMany_quotation_modal_package_has_many_fieldInput
  }

  export type many_quotation_modal_package_has_many_fieldCreateOrConnectWithoutfieldInput = {
    where: many_quotation_modal_package_has_many_fieldWhereUniqueInput
    create: many_quotation_modal_package_has_many_fieldCreateWithoutFieldInput
  }

  export type areaUpdateWithoutFieldInput = {
    code?: IntFieldUpdateOperationsInput | number
    lat?: FloatFieldUpdateOperationsInput | number
    long?: FloatFieldUpdateOperationsInput | number
    coordinates?: InputJsonValue | null
    name?: StringFieldUpdateOperationsInput | string
    zone?: NullableStringFieldUpdateOperationsInput | string | null
    state_initials?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    demand?: NullableStringFieldUpdateOperationsInput | string | null
    farm?: farmUpdateOneRequiredWithoutAreaInput
  }

  export type areaUpsertWithoutFieldInput = {
    update: areaUpdateWithoutFieldInput
    create: areaCreateWithoutFieldInput
  }

  export type cropUpdateWithWhereUniqueWithoutFieldInput = {
    where: cropWhereUniqueInput
    data: cropUpdateWithoutFieldInput
  }

  export type cropUpdateManyWithWhereWithoutFieldInput = {
    where: cropScalarWhereInput
    data: cropUpdateManyMutationInput
  }

  export type cropScalarWhereInput = {
    AND?: Enumerable<cropScalarWhereInput>
    OR?: Enumerable<cropScalarWhereInput>
    NOT?: Enumerable<cropScalarWhereInput>
    id?: IntFilter | number
    crop_type?: StringFilter | string
    variety?: StringFilter | string
    sowing_date?: DateTimeFilter | Date | string
    expected_harvest_date?: DateTimeFilter | Date | string
    number?: IntFilter | number
    is_diagnosis_hired?: BoolNullableFilter | boolean | null
    field_id?: IntFilter | number
  }

  export type cropUpsertWithWhereUniqueWithoutFieldInput = {
    where: cropWhereUniqueInput
    update: cropUpdateWithoutFieldInput
    create: cropCreateWithoutFieldInput
  }

  export type many_quotation_modal_package_has_many_fieldUpdateWithWhereUniqueWithoutFieldInput = {
    where: many_quotation_modal_package_has_many_fieldWhereUniqueInput
    data: many_quotation_modal_package_has_many_fieldUpdateWithoutFieldInput
  }

  export type many_quotation_modal_package_has_many_fieldUpdateManyWithWhereWithoutFieldInput = {
    where: many_quotation_modal_package_has_many_fieldScalarWhereInput
    data: many_quotation_modal_package_has_many_fieldUpdateManyMutationInput
  }

  export type many_quotation_modal_package_has_many_fieldScalarWhereInput = {
    AND?: Enumerable<many_quotation_modal_package_has_many_fieldScalarWhereInput>
    OR?: Enumerable<many_quotation_modal_package_has_many_fieldScalarWhereInput>
    NOT?: Enumerable<many_quotation_modal_package_has_many_fieldScalarWhereInput>
    id_quotation_modal_package?: IntFilter | number
    id_field?: IntFilter | number
  }

  export type many_quotation_modal_package_has_many_fieldUpsertWithWhereUniqueWithoutFieldInput = {
    where: many_quotation_modal_package_has_many_fieldWhereUniqueInput
    update: many_quotation_modal_package_has_many_fieldUpdateWithoutFieldInput
    create: many_quotation_modal_package_has_many_fieldCreateWithoutFieldInput
  }

  export type farmCreateWithoutImagingInput = {
    cnpj?: string | null
    social_name?: string | null
    fantasy_name: string
    lat?: number | null
    long?: number | null
    address: addressCreateOneWithoutFarmInput
    area?: areaCreateManyWithoutFarmInput
    many_user_has_many_farm?: many_user_has_many_farmCreateManyWithoutFarmInput
  }

  export type farmCreateOrConnectWithoutimagingInput = {
    where: farmWhereUniqueInput
    create: farmCreateWithoutImagingInput
  }

  export type farmUpdateWithoutImagingInput = {
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    social_name?: NullableStringFieldUpdateOperationsInput | string | null
    fantasy_name?: StringFieldUpdateOperationsInput | string
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    long?: NullableFloatFieldUpdateOperationsInput | number | null
    address?: addressUpdateOneRequiredWithoutFarmInput
    area?: areaUpdateManyWithoutFarmInput
    many_user_has_many_farm?: many_user_has_many_farmUpdateManyWithoutFarmInput
  }

  export type farmUpsertWithoutImagingInput = {
    update: farmUpdateWithoutImagingInput
    create: farmCreateWithoutImagingInput
  }

  export type diagnosisCreateWithoutInfestationInput = {
    report_date: Date | string
    affected_area_ha: number
    crop?: cropCreateOneWithoutDiagnosisInput
    prescription?: prescriptionCreateManyWithoutDiagnosisInput
  }

  export type diagnosisCreateOrConnectWithoutinfestationInput = {
    where: diagnosisWhereUniqueInput
    create: diagnosisCreateWithoutInfestationInput
  }

  export type plagueCreateWithoutInfestationInput = {
    name: string
    display_name?: string | null
    color: string
    in_use?: boolean | null
    relevance_order?: number | null
  }

  export type plagueCreateOrConnectWithoutinfestationInput = {
    where: plagueWhereUniqueInput
    create: plagueCreateWithoutInfestationInput
  }

  export type diagnosisUpdateWithoutInfestationInput = {
    report_date?: DateTimeFieldUpdateOperationsInput | Date | string
    affected_area_ha?: FloatFieldUpdateOperationsInput | number
    crop?: cropUpdateOneWithoutDiagnosisInput
    prescription?: prescriptionUpdateManyWithoutDiagnosisInput
  }

  export type diagnosisUpsertWithoutInfestationInput = {
    update: diagnosisUpdateWithoutInfestationInput
    create: diagnosisCreateWithoutInfestationInput
  }

  export type plagueUpdateWithoutInfestationInput = {
    name?: StringFieldUpdateOperationsInput | string
    display_name?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    in_use?: NullableBoolFieldUpdateOperationsInput | boolean | null
    relevance_order?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type plagueUpsertWithoutInfestationInput = {
    update: plagueUpdateWithoutInfestationInput
    create: plagueCreateWithoutInfestationInput
  }

  export type fieldCreateWithoutMany_quotation_modal_package_has_many_fieldInput = {
    code: number
    area_ha: number
    lat: number
    long: number
    coordinates: InputJsonValue
    name: string
    image_uri?: string | null
    visiona_area_id?: number | null
    event?: string | null
    area: areaCreateOneWithoutFieldInput
    crop?: cropCreateManyWithoutFieldInput
  }

  export type fieldCreateOrConnectWithoutmany_quotation_modal_package_has_many_fieldInput = {
    where: fieldWhereUniqueInput
    create: fieldCreateWithoutMany_quotation_modal_package_has_many_fieldInput
  }

  export type quotation_modal_packageCreateWithoutMany_quotation_modal_package_has_many_fieldInput = {
    pulverization_method: number
    quotation_package: quotation_packageCreateOneWithoutQuotation_modal_packageInput
    quotation?: quotationCreateManyWithoutQuotation_modal_packageInput
  }

  export type quotation_modal_packageCreateOrConnectWithoutmany_quotation_modal_package_has_many_fieldInput = {
    where: quotation_modal_packageWhereUniqueInput
    create: quotation_modal_packageCreateWithoutMany_quotation_modal_package_has_many_fieldInput
  }

  export type fieldUpdateWithoutMany_quotation_modal_package_has_many_fieldInput = {
    code?: IntFieldUpdateOperationsInput | number
    area_ha?: FloatFieldUpdateOperationsInput | number
    lat?: FloatFieldUpdateOperationsInput | number
    long?: FloatFieldUpdateOperationsInput | number
    coordinates?: InputJsonValue
    name?: StringFieldUpdateOperationsInput | string
    image_uri?: NullableStringFieldUpdateOperationsInput | string | null
    visiona_area_id?: NullableIntFieldUpdateOperationsInput | number | null
    event?: NullableStringFieldUpdateOperationsInput | string | null
    area?: areaUpdateOneRequiredWithoutFieldInput
    crop?: cropUpdateManyWithoutFieldInput
  }

  export type fieldUpsertWithoutMany_quotation_modal_package_has_many_fieldInput = {
    update: fieldUpdateWithoutMany_quotation_modal_package_has_many_fieldInput
    create: fieldCreateWithoutMany_quotation_modal_package_has_many_fieldInput
  }

  export type quotation_modal_packageUpdateWithoutMany_quotation_modal_package_has_many_fieldInput = {
    pulverization_method?: IntFieldUpdateOperationsInput | number
    quotation_package?: quotation_packageUpdateOneRequiredWithoutQuotation_modal_packageInput
    quotation?: quotationUpdateManyWithoutQuotation_modal_packageInput
  }

  export type quotation_modal_packageUpsertWithoutMany_quotation_modal_package_has_many_fieldInput = {
    update: quotation_modal_packageUpdateWithoutMany_quotation_modal_package_has_many_fieldInput
    create: quotation_modal_packageCreateWithoutMany_quotation_modal_package_has_many_fieldInput
  }

  export type farmCreateWithoutMany_user_has_many_farmInput = {
    cnpj?: string | null
    social_name?: string | null
    fantasy_name: string
    lat?: number | null
    long?: number | null
    address: addressCreateOneWithoutFarmInput
    area?: areaCreateManyWithoutFarmInput
    imaging?: imagingCreateManyWithoutFarmInput
  }

  export type farmCreateOrConnectWithoutmany_user_has_many_farmInput = {
    where: farmWhereUniqueInput
    create: farmCreateWithoutMany_user_has_many_farmInput
  }

  export type userCreateWithoutMany_user_has_many_farmInput = {
    first_name: string
    last_name: string
    username: string
    password: string
    cpf?: string | null
    phone_number: string
    email?: string | null
    active: boolean
    creation_date: Date | string
    access_date: Date | string
    update_date: Date | string
    yellow_threshold?: number
    red_threshold?: number
    fcm_token?: string | null
    avatar?: string | null
    notification?: notificationCreateManyWithoutUserInput
    user_accepted_privacy_policy?: user_accepted_privacy_policyCreateManyWithoutUserInput
    user_accepted_terms?: user_accepted_termsCreateManyWithoutUserInput
    user_role?: user_roleCreateManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutmany_user_has_many_farmInput = {
    where: userWhereUniqueInput
    create: userCreateWithoutMany_user_has_many_farmInput
  }

  export type farmUpdateWithoutMany_user_has_many_farmInput = {
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    social_name?: NullableStringFieldUpdateOperationsInput | string | null
    fantasy_name?: StringFieldUpdateOperationsInput | string
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    long?: NullableFloatFieldUpdateOperationsInput | number | null
    address?: addressUpdateOneRequiredWithoutFarmInput
    area?: areaUpdateManyWithoutFarmInput
    imaging?: imagingUpdateManyWithoutFarmInput
  }

  export type farmUpsertWithoutMany_user_has_many_farmInput = {
    update: farmUpdateWithoutMany_user_has_many_farmInput
    create: farmCreateWithoutMany_user_has_many_farmInput
  }

  export type userUpdateWithoutMany_user_has_many_farmInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    creation_date?: DateTimeFieldUpdateOperationsInput | Date | string
    access_date?: DateTimeFieldUpdateOperationsInput | Date | string
    update_date?: DateTimeFieldUpdateOperationsInput | Date | string
    yellow_threshold?: FloatFieldUpdateOperationsInput | number
    red_threshold?: FloatFieldUpdateOperationsInput | number
    fcm_token?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    notification?: notificationUpdateManyWithoutUserInput
    user_accepted_privacy_policy?: user_accepted_privacy_policyUpdateManyWithoutUserInput
    user_accepted_terms?: user_accepted_termsUpdateManyWithoutUserInput
    user_role?: user_roleUpdateManyWithoutUserInput
  }

  export type userUpsertWithoutMany_user_has_many_farmInput = {
    update: userUpdateWithoutMany_user_has_many_farmInput
    create: userCreateWithoutMany_user_has_many_farmInput
  }

  export type userCreateWithoutNotificationInput = {
    first_name: string
    last_name: string
    username: string
    password: string
    cpf?: string | null
    phone_number: string
    email?: string | null
    active: boolean
    creation_date: Date | string
    access_date: Date | string
    update_date: Date | string
    yellow_threshold?: number
    red_threshold?: number
    fcm_token?: string | null
    avatar?: string | null
    many_user_has_many_farm?: many_user_has_many_farmCreateManyWithoutUserInput
    user_accepted_privacy_policy?: user_accepted_privacy_policyCreateManyWithoutUserInput
    user_accepted_terms?: user_accepted_termsCreateManyWithoutUserInput
    user_role?: user_roleCreateManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutnotificationInput = {
    where: userWhereUniqueInput
    create: userCreateWithoutNotificationInput
  }

  export type userUpdateWithoutNotificationInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    creation_date?: DateTimeFieldUpdateOperationsInput | Date | string
    access_date?: DateTimeFieldUpdateOperationsInput | Date | string
    update_date?: DateTimeFieldUpdateOperationsInput | Date | string
    yellow_threshold?: FloatFieldUpdateOperationsInput | number
    red_threshold?: FloatFieldUpdateOperationsInput | number
    fcm_token?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    many_user_has_many_farm?: many_user_has_many_farmUpdateManyWithoutUserInput
    user_accepted_privacy_policy?: user_accepted_privacy_policyUpdateManyWithoutUserInput
    user_accepted_terms?: user_accepted_termsUpdateManyWithoutUserInput
    user_role?: user_roleUpdateManyWithoutUserInput
  }

  export type userUpsertWithoutNotificationInput = {
    update: userUpdateWithoutNotificationInput
    create: userCreateWithoutNotificationInput
  }

  export type infestationCreateWithoutPlagueInput = {
    area_ha?: number
    points?: InputJsonValue | null
    diagnosis: diagnosisCreateOneWithoutInfestationInput
  }

  export type infestationCreateOrConnectWithoutplagueInput = {
    where: infestationWhereUniqueInput
    create: infestationCreateWithoutPlagueInput
  }

  export type infestationUpdateWithWhereUniqueWithoutPlagueInput = {
    where: infestationWhereUniqueInput
    data: infestationUpdateWithoutPlagueInput
  }

  export type infestationUpdateManyWithWhereWithoutPlagueInput = {
    where: infestationScalarWhereInput
    data: infestationUpdateManyMutationInput
  }

  export type infestationUpsertWithWhereUniqueWithoutPlagueInput = {
    where: infestationWhereUniqueInput
    update: infestationUpdateWithoutPlagueInput
    create: infestationCreateWithoutPlagueInput
  }

  export type diagnosisCreateWithoutPrescriptionInput = {
    report_date: Date | string
    affected_area_ha: number
    crop?: cropCreateOneWithoutDiagnosisInput
    infestation?: infestationCreateManyWithoutDiagnosisInput
  }

  export type diagnosisCreateOrConnectWithoutprescriptionInput = {
    where: diagnosisWhereUniqueInput
    create: diagnosisCreateWithoutPrescriptionInput
  }

  export type diagnosisUpdateWithoutPrescriptionInput = {
    report_date?: DateTimeFieldUpdateOperationsInput | Date | string
    affected_area_ha?: FloatFieldUpdateOperationsInput | number
    crop?: cropUpdateOneWithoutDiagnosisInput
    infestation?: infestationUpdateManyWithoutDiagnosisInput
  }

  export type diagnosisUpsertWithoutPrescriptionInput = {
    update: diagnosisUpdateWithoutPrescriptionInput
    create: diagnosisCreateWithoutPrescriptionInput
  }

  export type user_accepted_privacy_policyCreateWithoutPrivacy_policyInput = {
    accepted_date: Date | string
    user: userCreateOneWithoutUser_accepted_privacy_policyInput
  }

  export type user_accepted_privacy_policyCreateOrConnectWithoutprivacy_policyInput = {
    where: user_accepted_privacy_policyWhereUniqueInput
    create: user_accepted_privacy_policyCreateWithoutPrivacy_policyInput
  }

  export type user_accepted_privacy_policyUpdateWithWhereUniqueWithoutPrivacy_policyInput = {
    where: user_accepted_privacy_policyWhereUniqueInput
    data: user_accepted_privacy_policyUpdateWithoutPrivacy_policyInput
  }

  export type user_accepted_privacy_policyUpdateManyWithWhereWithoutPrivacy_policyInput = {
    where: user_accepted_privacy_policyScalarWhereInput
    data: user_accepted_privacy_policyUpdateManyMutationInput
  }

  export type user_accepted_privacy_policyScalarWhereInput = {
    AND?: Enumerable<user_accepted_privacy_policyScalarWhereInput>
    OR?: Enumerable<user_accepted_privacy_policyScalarWhereInput>
    NOT?: Enumerable<user_accepted_privacy_policyScalarWhereInput>
    id?: IntFilter | number
    accepted_date?: DateTimeFilter | Date | string
    id_privacy_policy?: IntFilter | number
    id_user?: IntFilter | number
  }

  export type user_accepted_privacy_policyUpsertWithWhereUniqueWithoutPrivacy_policyInput = {
    where: user_accepted_privacy_policyWhereUniqueInput
    update: user_accepted_privacy_policyUpdateWithoutPrivacy_policyInput
    create: user_accepted_privacy_policyCreateWithoutPrivacy_policyInput
  }

  export type companyCreateWithoutQuotationInput = {
    name: string
    works_with_drone: boolean
    works_with_plane: boolean
    works_with_tractor: boolean
    lat: number
    long: number
    address: addressCreateOneWithoutCompanyInput
  }

  export type companyCreateOrConnectWithoutquotationInput = {
    where: companyWhereUniqueInput
    create: companyCreateWithoutQuotationInput
  }

  export type quotation_modal_packageCreateWithoutQuotationInput = {
    pulverization_method: number
    quotation_package: quotation_packageCreateOneWithoutQuotation_modal_packageInput
    many_quotation_modal_package_has_many_field?: many_quotation_modal_package_has_many_fieldCreateManyWithoutQuotation_modal_packageInput
  }

  export type quotation_modal_packageCreateOrConnectWithoutquotationInput = {
    where: quotation_modal_packageWhereUniqueInput
    create: quotation_modal_packageCreateWithoutQuotationInput
  }

  export type quotation_checkoutCreateWithoutQuotationInput = {
    checkout_date: Date | string
    selected_price: number
  }

  export type quotation_checkoutCreateOrConnectWithoutquotationInput = {
    where: quotation_checkoutWhereUniqueInput
    create: quotation_checkoutCreateWithoutQuotationInput
  }

  export type companyUpdateWithoutQuotationInput = {
    name?: StringFieldUpdateOperationsInput | string
    works_with_drone?: BoolFieldUpdateOperationsInput | boolean
    works_with_plane?: BoolFieldUpdateOperationsInput | boolean
    works_with_tractor?: BoolFieldUpdateOperationsInput | boolean
    lat?: FloatFieldUpdateOperationsInput | number
    long?: FloatFieldUpdateOperationsInput | number
    address?: addressUpdateOneRequiredWithoutCompanyInput
  }

  export type companyUpsertWithoutQuotationInput = {
    update: companyUpdateWithoutQuotationInput
    create: companyCreateWithoutQuotationInput
  }

  export type quotation_modal_packageUpdateWithoutQuotationInput = {
    pulverization_method?: IntFieldUpdateOperationsInput | number
    quotation_package?: quotation_packageUpdateOneRequiredWithoutQuotation_modal_packageInput
    many_quotation_modal_package_has_many_field?: many_quotation_modal_package_has_many_fieldUpdateManyWithoutQuotation_modal_packageInput
  }

  export type quotation_modal_packageUpsertWithoutQuotationInput = {
    update: quotation_modal_packageUpdateWithoutQuotationInput
    create: quotation_modal_packageCreateWithoutQuotationInput
  }

  export type quotation_checkoutUpdateWithoutQuotationInput = {
    checkout_date?: DateTimeFieldUpdateOperationsInput | Date | string
    selected_price?: IntFieldUpdateOperationsInput | number
  }

  export type quotation_checkoutUpsertWithoutQuotationInput = {
    update: quotation_checkoutUpdateWithoutQuotationInput
    create: quotation_checkoutCreateWithoutQuotationInput
  }

  export type quotationCreateWithoutQuotation_checkoutInput = {
    response_date?: Date | string | null
    expiration_date?: Date | string | null
    antecipated_price?: number | null
    cash_price?: number | null
    delayed_price?: number | null
    company: companyCreateOneWithoutQuotationInput
    quotation_modal_package: quotation_modal_packageCreateOneWithoutQuotationInput
  }

  export type quotationCreateOrConnectWithoutquotation_checkoutInput = {
    where: quotationWhereUniqueInput
    create: quotationCreateWithoutQuotation_checkoutInput
  }

  export type quotationUpdateWithoutQuotation_checkoutInput = {
    response_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiration_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    antecipated_price?: NullableIntFieldUpdateOperationsInput | number | null
    cash_price?: NullableIntFieldUpdateOperationsInput | number | null
    delayed_price?: NullableIntFieldUpdateOperationsInput | number | null
    company?: companyUpdateOneRequiredWithoutQuotationInput
    quotation_modal_package?: quotation_modal_packageUpdateOneRequiredWithoutQuotationInput
  }

  export type quotationUpsertWithoutQuotation_checkoutInput = {
    update: quotationUpdateWithoutQuotation_checkoutInput
    create: quotationCreateWithoutQuotation_checkoutInput
  }

  export type quotation_packageCreateWithoutQuotation_modal_packageInput = {
    code: number
    request_date: Date | string
    pulverization_start_date: Date | string
    pulverization_end_date: Date | string
  }

  export type quotation_packageCreateOrConnectWithoutquotation_modal_packageInput = {
    where: quotation_packageWhereUniqueInput
    create: quotation_packageCreateWithoutQuotation_modal_packageInput
  }

  export type many_quotation_modal_package_has_many_fieldCreateWithoutQuotation_modal_packageInput = {
    field: fieldCreateOneWithoutMany_quotation_modal_package_has_many_fieldInput
  }

  export type many_quotation_modal_package_has_many_fieldCreateOrConnectWithoutquotation_modal_packageInput = {
    where: many_quotation_modal_package_has_many_fieldWhereUniqueInput
    create: many_quotation_modal_package_has_many_fieldCreateWithoutQuotation_modal_packageInput
  }

  export type quotationCreateWithoutQuotation_modal_packageInput = {
    response_date?: Date | string | null
    expiration_date?: Date | string | null
    antecipated_price?: number | null
    cash_price?: number | null
    delayed_price?: number | null
    company: companyCreateOneWithoutQuotationInput
    quotation_checkout?: quotation_checkoutCreateOneWithoutQuotationInput
  }

  export type quotationCreateOrConnectWithoutquotation_modal_packageInput = {
    where: quotationWhereUniqueInput
    create: quotationCreateWithoutQuotation_modal_packageInput
  }

  export type quotation_packageUpdateWithoutQuotation_modal_packageInput = {
    code?: IntFieldUpdateOperationsInput | number
    request_date?: DateTimeFieldUpdateOperationsInput | Date | string
    pulverization_start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    pulverization_end_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type quotation_packageUpsertWithoutQuotation_modal_packageInput = {
    update: quotation_packageUpdateWithoutQuotation_modal_packageInput
    create: quotation_packageCreateWithoutQuotation_modal_packageInput
  }

  export type many_quotation_modal_package_has_many_fieldUpdateWithWhereUniqueWithoutQuotation_modal_packageInput = {
    where: many_quotation_modal_package_has_many_fieldWhereUniqueInput
    data: many_quotation_modal_package_has_many_fieldUpdateWithoutQuotation_modal_packageInput
  }

  export type many_quotation_modal_package_has_many_fieldUpdateManyWithWhereWithoutQuotation_modal_packageInput = {
    where: many_quotation_modal_package_has_many_fieldScalarWhereInput
    data: many_quotation_modal_package_has_many_fieldUpdateManyMutationInput
  }

  export type many_quotation_modal_package_has_many_fieldUpsertWithWhereUniqueWithoutQuotation_modal_packageInput = {
    where: many_quotation_modal_package_has_many_fieldWhereUniqueInput
    update: many_quotation_modal_package_has_many_fieldUpdateWithoutQuotation_modal_packageInput
    create: many_quotation_modal_package_has_many_fieldCreateWithoutQuotation_modal_packageInput
  }

  export type quotationUpdateWithWhereUniqueWithoutQuotation_modal_packageInput = {
    where: quotationWhereUniqueInput
    data: quotationUpdateWithoutQuotation_modal_packageInput
  }

  export type quotationUpdateManyWithWhereWithoutQuotation_modal_packageInput = {
    where: quotationScalarWhereInput
    data: quotationUpdateManyMutationInput
  }

  export type quotationUpsertWithWhereUniqueWithoutQuotation_modal_packageInput = {
    where: quotationWhereUniqueInput
    update: quotationUpdateWithoutQuotation_modal_packageInput
    create: quotationCreateWithoutQuotation_modal_packageInput
  }

  export type quotation_modal_packageCreateWithoutQuotation_packageInput = {
    pulverization_method: number
    many_quotation_modal_package_has_many_field?: many_quotation_modal_package_has_many_fieldCreateManyWithoutQuotation_modal_packageInput
    quotation?: quotationCreateManyWithoutQuotation_modal_packageInput
  }

  export type quotation_modal_packageCreateOrConnectWithoutquotation_packageInput = {
    where: quotation_modal_packageWhereUniqueInput
    create: quotation_modal_packageCreateWithoutQuotation_packageInput
  }

  export type quotation_modal_packageUpdateWithWhereUniqueWithoutQuotation_packageInput = {
    where: quotation_modal_packageWhereUniqueInput
    data: quotation_modal_packageUpdateWithoutQuotation_packageInput
  }

  export type quotation_modal_packageUpdateManyWithWhereWithoutQuotation_packageInput = {
    where: quotation_modal_packageScalarWhereInput
    data: quotation_modal_packageUpdateManyMutationInput
  }

  export type quotation_modal_packageScalarWhereInput = {
    AND?: Enumerable<quotation_modal_packageScalarWhereInput>
    OR?: Enumerable<quotation_modal_packageScalarWhereInput>
    NOT?: Enumerable<quotation_modal_packageScalarWhereInput>
    id?: IntFilter | number
    pulverization_method?: IntFilter | number
    quotation_package_id?: IntFilter | number
  }

  export type quotation_modal_packageUpsertWithWhereUniqueWithoutQuotation_packageInput = {
    where: quotation_modal_packageWhereUniqueInput
    update: quotation_modal_packageUpdateWithoutQuotation_packageInput
    create: quotation_modal_packageCreateWithoutQuotation_packageInput
  }

  export type user_roleCreateWithoutRoleInput = {
    user: userCreateOneWithoutUser_roleInput
  }

  export type user_roleCreateOrConnectWithoutroleInput = {
    where: user_roleWhereUniqueInput
    create: user_roleCreateWithoutRoleInput
  }

  export type user_roleUpdateWithWhereUniqueWithoutRoleInput = {
    where: user_roleWhereUniqueInput
    data: user_roleUpdateWithoutRoleInput
  }

  export type user_roleUpdateManyWithWhereWithoutRoleInput = {
    where: user_roleScalarWhereInput
    data: user_roleUpdateManyMutationInput
  }

  export type user_roleScalarWhereInput = {
    AND?: Enumerable<user_roleScalarWhereInput>
    OR?: Enumerable<user_roleScalarWhereInput>
    NOT?: Enumerable<user_roleScalarWhereInput>
    id?: IntFilter | number
    user_id?: IntFilter | number
    role_id?: IntFilter | number
  }

  export type user_roleUpsertWithWhereUniqueWithoutRoleInput = {
    where: user_roleWhereUniqueInput
    update: user_roleUpdateWithoutRoleInput
    create: user_roleCreateWithoutRoleInput
  }

  export type addressCreateWithoutStateInput = {
    street: string
    city: string
    number?: number | null
    km?: number | null
    postal_code?: string | null
    complement?: string | null
    neighborhood?: string | null
    phone_number?: string | null
    contact_name?: string | null
    mobile_number?: string | null
    email?: string | null
    company?: companyCreateManyWithoutAddressInput
    farm?: farmCreateManyWithoutAddressInput
  }

  export type addressCreateOrConnectWithoutstateInput = {
    where: addressWhereUniqueInput
    create: addressCreateWithoutStateInput
  }

  export type addressUpdateWithWhereUniqueWithoutStateInput = {
    where: addressWhereUniqueInput
    data: addressUpdateWithoutStateInput
  }

  export type addressUpdateManyWithWhereWithoutStateInput = {
    where: addressScalarWhereInput
    data: addressUpdateManyMutationInput
  }

  export type addressScalarWhereInput = {
    AND?: Enumerable<addressScalarWhereInput>
    OR?: Enumerable<addressScalarWhereInput>
    NOT?: Enumerable<addressScalarWhereInput>
    id?: IntFilter | number
    street?: StringFilter | string
    city?: StringFilter | string
    number?: IntNullableFilter | number | null
    km?: IntNullableFilter | number | null
    postal_code?: StringNullableFilter | string | null
    complement?: StringNullableFilter | string | null
    neighborhood?: StringNullableFilter | string | null
    phone_number?: StringNullableFilter | string | null
    contact_name?: StringNullableFilter | string | null
    state_id?: IntFilter | number
    mobile_number?: StringNullableFilter | string | null
    email?: StringNullableFilter | string | null
  }

  export type addressUpsertWithWhereUniqueWithoutStateInput = {
    where: addressWhereUniqueInput
    update: addressUpdateWithoutStateInput
    create: addressCreateWithoutStateInput
  }

  export type user_accepted_termsCreateWithoutTerms_and_conditionsInput = {
    accepted_date: Date | string
    user: userCreateOneWithoutUser_accepted_termsInput
  }

  export type user_accepted_termsCreateOrConnectWithoutterms_and_conditionsInput = {
    where: user_accepted_termsWhereUniqueInput
    create: user_accepted_termsCreateWithoutTerms_and_conditionsInput
  }

  export type user_accepted_termsUpdateWithWhereUniqueWithoutTerms_and_conditionsInput = {
    where: user_accepted_termsWhereUniqueInput
    data: user_accepted_termsUpdateWithoutTerms_and_conditionsInput
  }

  export type user_accepted_termsUpdateManyWithWhereWithoutTerms_and_conditionsInput = {
    where: user_accepted_termsScalarWhereInput
    data: user_accepted_termsUpdateManyMutationInput
  }

  export type user_accepted_termsScalarWhereInput = {
    AND?: Enumerable<user_accepted_termsScalarWhereInput>
    OR?: Enumerable<user_accepted_termsScalarWhereInput>
    NOT?: Enumerable<user_accepted_termsScalarWhereInput>
    id?: IntFilter | number
    accepted_date?: DateTimeFilter | Date | string
    id_user?: IntFilter | number
    id_terms_and_conditions?: IntFilter | number
  }

  export type user_accepted_termsUpsertWithWhereUniqueWithoutTerms_and_conditionsInput = {
    where: user_accepted_termsWhereUniqueInput
    update: user_accepted_termsUpdateWithoutTerms_and_conditionsInput
    create: user_accepted_termsCreateWithoutTerms_and_conditionsInput
  }

  export type many_user_has_many_farmCreateWithoutUserInput = {
    farm: farmCreateOneWithoutMany_user_has_many_farmInput
  }

  export type many_user_has_many_farmCreateOrConnectWithoutuserInput = {
    where: many_user_has_many_farmWhereUniqueInput
    create: many_user_has_many_farmCreateWithoutUserInput
  }

  export type notificationCreateWithoutUserInput = {
    type: number
    body: InputJsonValue
    sent_date: Date | string
    read_date?: Date | string | null
    delivered_date?: Date | string | null
  }

  export type notificationCreateOrConnectWithoutuserInput = {
    where: notificationWhereUniqueInput
    create: notificationCreateWithoutUserInput
  }

  export type user_accepted_privacy_policyCreateWithoutUserInput = {
    accepted_date: Date | string
    privacy_policy: privacy_policyCreateOneWithoutUser_accepted_privacy_policyInput
  }

  export type user_accepted_privacy_policyCreateOrConnectWithoutuserInput = {
    where: user_accepted_privacy_policyWhereUniqueInput
    create: user_accepted_privacy_policyCreateWithoutUserInput
  }

  export type user_accepted_termsCreateWithoutUserInput = {
    accepted_date: Date | string
    terms_and_conditions: terms_and_conditionsCreateOneWithoutUser_accepted_termsInput
  }

  export type user_accepted_termsCreateOrConnectWithoutuserInput = {
    where: user_accepted_termsWhereUniqueInput
    create: user_accepted_termsCreateWithoutUserInput
  }

  export type user_roleCreateWithoutUserInput = {
    role: roleCreateOneWithoutUser_roleInput
  }

  export type user_roleCreateOrConnectWithoutuserInput = {
    where: user_roleWhereUniqueInput
    create: user_roleCreateWithoutUserInput
  }

  export type many_user_has_many_farmUpdateWithWhereUniqueWithoutUserInput = {
    where: many_user_has_many_farmWhereUniqueInput
    data: many_user_has_many_farmUpdateWithoutUserInput
  }

  export type many_user_has_many_farmUpdateManyWithWhereWithoutUserInput = {
    where: many_user_has_many_farmScalarWhereInput
    data: many_user_has_many_farmUpdateManyMutationInput
  }

  export type many_user_has_many_farmUpsertWithWhereUniqueWithoutUserInput = {
    where: many_user_has_many_farmWhereUniqueInput
    update: many_user_has_many_farmUpdateWithoutUserInput
    create: many_user_has_many_farmCreateWithoutUserInput
  }

  export type notificationUpdateWithWhereUniqueWithoutUserInput = {
    where: notificationWhereUniqueInput
    data: notificationUpdateWithoutUserInput
  }

  export type notificationUpdateManyWithWhereWithoutUserInput = {
    where: notificationScalarWhereInput
    data: notificationUpdateManyMutationInput
  }

  export type notificationScalarWhereInput = {
    AND?: Enumerable<notificationScalarWhereInput>
    OR?: Enumerable<notificationScalarWhereInput>
    NOT?: Enumerable<notificationScalarWhereInput>
    id?: IntFilter | number
    type?: IntFilter | number
    body?: JsonFilter
    sent_date?: DateTimeFilter | Date | string
    read_date?: DateTimeNullableFilter | Date | string | null
    delivered_date?: DateTimeNullableFilter | Date | string | null
    user_id?: IntFilter | number
  }

  export type notificationUpsertWithWhereUniqueWithoutUserInput = {
    where: notificationWhereUniqueInput
    update: notificationUpdateWithoutUserInput
    create: notificationCreateWithoutUserInput
  }

  export type user_accepted_privacy_policyUpdateWithWhereUniqueWithoutUserInput = {
    where: user_accepted_privacy_policyWhereUniqueInput
    data: user_accepted_privacy_policyUpdateWithoutUserInput
  }

  export type user_accepted_privacy_policyUpdateManyWithWhereWithoutUserInput = {
    where: user_accepted_privacy_policyScalarWhereInput
    data: user_accepted_privacy_policyUpdateManyMutationInput
  }

  export type user_accepted_privacy_policyUpsertWithWhereUniqueWithoutUserInput = {
    where: user_accepted_privacy_policyWhereUniqueInput
    update: user_accepted_privacy_policyUpdateWithoutUserInput
    create: user_accepted_privacy_policyCreateWithoutUserInput
  }

  export type user_accepted_termsUpdateWithWhereUniqueWithoutUserInput = {
    where: user_accepted_termsWhereUniqueInput
    data: user_accepted_termsUpdateWithoutUserInput
  }

  export type user_accepted_termsUpdateManyWithWhereWithoutUserInput = {
    where: user_accepted_termsScalarWhereInput
    data: user_accepted_termsUpdateManyMutationInput
  }

  export type user_accepted_termsUpsertWithWhereUniqueWithoutUserInput = {
    where: user_accepted_termsWhereUniqueInput
    update: user_accepted_termsUpdateWithoutUserInput
    create: user_accepted_termsCreateWithoutUserInput
  }

  export type user_roleUpdateWithWhereUniqueWithoutUserInput = {
    where: user_roleWhereUniqueInput
    data: user_roleUpdateWithoutUserInput
  }

  export type user_roleUpdateManyWithWhereWithoutUserInput = {
    where: user_roleScalarWhereInput
    data: user_roleUpdateManyMutationInput
  }

  export type user_roleUpsertWithWhereUniqueWithoutUserInput = {
    where: user_roleWhereUniqueInput
    update: user_roleUpdateWithoutUserInput
    create: user_roleCreateWithoutUserInput
  }

  export type privacy_policyCreateWithoutUser_accepted_privacy_policyInput = {
    content: string
    publish_date: Date | string
  }

  export type privacy_policyCreateOrConnectWithoutuser_accepted_privacy_policyInput = {
    where: privacy_policyWhereUniqueInput
    create: privacy_policyCreateWithoutUser_accepted_privacy_policyInput
  }

  export type userCreateWithoutUser_accepted_privacy_policyInput = {
    first_name: string
    last_name: string
    username: string
    password: string
    cpf?: string | null
    phone_number: string
    email?: string | null
    active: boolean
    creation_date: Date | string
    access_date: Date | string
    update_date: Date | string
    yellow_threshold?: number
    red_threshold?: number
    fcm_token?: string | null
    avatar?: string | null
    many_user_has_many_farm?: many_user_has_many_farmCreateManyWithoutUserInput
    notification?: notificationCreateManyWithoutUserInput
    user_accepted_terms?: user_accepted_termsCreateManyWithoutUserInput
    user_role?: user_roleCreateManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutuser_accepted_privacy_policyInput = {
    where: userWhereUniqueInput
    create: userCreateWithoutUser_accepted_privacy_policyInput
  }

  export type privacy_policyUpdateWithoutUser_accepted_privacy_policyInput = {
    content?: StringFieldUpdateOperationsInput | string
    publish_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type privacy_policyUpsertWithoutUser_accepted_privacy_policyInput = {
    update: privacy_policyUpdateWithoutUser_accepted_privacy_policyInput
    create: privacy_policyCreateWithoutUser_accepted_privacy_policyInput
  }

  export type userUpdateWithoutUser_accepted_privacy_policyInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    creation_date?: DateTimeFieldUpdateOperationsInput | Date | string
    access_date?: DateTimeFieldUpdateOperationsInput | Date | string
    update_date?: DateTimeFieldUpdateOperationsInput | Date | string
    yellow_threshold?: FloatFieldUpdateOperationsInput | number
    red_threshold?: FloatFieldUpdateOperationsInput | number
    fcm_token?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    many_user_has_many_farm?: many_user_has_many_farmUpdateManyWithoutUserInput
    notification?: notificationUpdateManyWithoutUserInput
    user_accepted_terms?: user_accepted_termsUpdateManyWithoutUserInput
    user_role?: user_roleUpdateManyWithoutUserInput
  }

  export type userUpsertWithoutUser_accepted_privacy_policyInput = {
    update: userUpdateWithoutUser_accepted_privacy_policyInput
    create: userCreateWithoutUser_accepted_privacy_policyInput
  }

  export type terms_and_conditionsCreateWithoutUser_accepted_termsInput = {
    content: string
    publish_date: Date | string
  }

  export type terms_and_conditionsCreateOrConnectWithoutuser_accepted_termsInput = {
    where: terms_and_conditionsWhereUniqueInput
    create: terms_and_conditionsCreateWithoutUser_accepted_termsInput
  }

  export type userCreateWithoutUser_accepted_termsInput = {
    first_name: string
    last_name: string
    username: string
    password: string
    cpf?: string | null
    phone_number: string
    email?: string | null
    active: boolean
    creation_date: Date | string
    access_date: Date | string
    update_date: Date | string
    yellow_threshold?: number
    red_threshold?: number
    fcm_token?: string | null
    avatar?: string | null
    many_user_has_many_farm?: many_user_has_many_farmCreateManyWithoutUserInput
    notification?: notificationCreateManyWithoutUserInput
    user_accepted_privacy_policy?: user_accepted_privacy_policyCreateManyWithoutUserInput
    user_role?: user_roleCreateManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutuser_accepted_termsInput = {
    where: userWhereUniqueInput
    create: userCreateWithoutUser_accepted_termsInput
  }

  export type terms_and_conditionsUpdateWithoutUser_accepted_termsInput = {
    content?: StringFieldUpdateOperationsInput | string
    publish_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type terms_and_conditionsUpsertWithoutUser_accepted_termsInput = {
    update: terms_and_conditionsUpdateWithoutUser_accepted_termsInput
    create: terms_and_conditionsCreateWithoutUser_accepted_termsInput
  }

  export type userUpdateWithoutUser_accepted_termsInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    creation_date?: DateTimeFieldUpdateOperationsInput | Date | string
    access_date?: DateTimeFieldUpdateOperationsInput | Date | string
    update_date?: DateTimeFieldUpdateOperationsInput | Date | string
    yellow_threshold?: FloatFieldUpdateOperationsInput | number
    red_threshold?: FloatFieldUpdateOperationsInput | number
    fcm_token?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    many_user_has_many_farm?: many_user_has_many_farmUpdateManyWithoutUserInput
    notification?: notificationUpdateManyWithoutUserInput
    user_accepted_privacy_policy?: user_accepted_privacy_policyUpdateManyWithoutUserInput
    user_role?: user_roleUpdateManyWithoutUserInput
  }

  export type userUpsertWithoutUser_accepted_termsInput = {
    update: userUpdateWithoutUser_accepted_termsInput
    create: userCreateWithoutUser_accepted_termsInput
  }

  export type roleCreateWithoutUser_roleInput = {
    name?: string | null
  }

  export type roleCreateOrConnectWithoutuser_roleInput = {
    where: roleWhereUniqueInput
    create: roleCreateWithoutUser_roleInput
  }

  export type userCreateWithoutUser_roleInput = {
    first_name: string
    last_name: string
    username: string
    password: string
    cpf?: string | null
    phone_number: string
    email?: string | null
    active: boolean
    creation_date: Date | string
    access_date: Date | string
    update_date: Date | string
    yellow_threshold?: number
    red_threshold?: number
    fcm_token?: string | null
    avatar?: string | null
    many_user_has_many_farm?: many_user_has_many_farmCreateManyWithoutUserInput
    notification?: notificationCreateManyWithoutUserInput
    user_accepted_privacy_policy?: user_accepted_privacy_policyCreateManyWithoutUserInput
    user_accepted_terms?: user_accepted_termsCreateManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutuser_roleInput = {
    where: userWhereUniqueInput
    create: userCreateWithoutUser_roleInput
  }

  export type roleUpdateWithoutUser_roleInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type roleUpsertWithoutUser_roleInput = {
    update: roleUpdateWithoutUser_roleInput
    create: roleCreateWithoutUser_roleInput
  }

  export type userUpdateWithoutUser_roleInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    creation_date?: DateTimeFieldUpdateOperationsInput | Date | string
    access_date?: DateTimeFieldUpdateOperationsInput | Date | string
    update_date?: DateTimeFieldUpdateOperationsInput | Date | string
    yellow_threshold?: FloatFieldUpdateOperationsInput | number
    red_threshold?: FloatFieldUpdateOperationsInput | number
    fcm_token?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    many_user_has_many_farm?: many_user_has_many_farmUpdateManyWithoutUserInput
    notification?: notificationUpdateManyWithoutUserInput
    user_accepted_privacy_policy?: user_accepted_privacy_policyUpdateManyWithoutUserInput
    user_accepted_terms?: user_accepted_termsUpdateManyWithoutUserInput
  }

  export type userUpsertWithoutUser_roleInput = {
    update: userUpdateWithoutUser_roleInput
    create: userCreateWithoutUser_roleInput
  }

  export type companyUpdateWithoutAddressInput = {
    name?: StringFieldUpdateOperationsInput | string
    works_with_drone?: BoolFieldUpdateOperationsInput | boolean
    works_with_plane?: BoolFieldUpdateOperationsInput | boolean
    works_with_tractor?: BoolFieldUpdateOperationsInput | boolean
    lat?: FloatFieldUpdateOperationsInput | number
    long?: FloatFieldUpdateOperationsInput | number
    quotation?: quotationUpdateManyWithoutCompanyInput
  }

  export type farmUpdateWithoutAddressInput = {
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    social_name?: NullableStringFieldUpdateOperationsInput | string | null
    fantasy_name?: StringFieldUpdateOperationsInput | string
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    long?: NullableFloatFieldUpdateOperationsInput | number | null
    area?: areaUpdateManyWithoutFarmInput
    imaging?: imagingUpdateManyWithoutFarmInput
    many_user_has_many_farm?: many_user_has_many_farmUpdateManyWithoutFarmInput
  }

  export type fieldUpdateWithoutAreaInput = {
    code?: IntFieldUpdateOperationsInput | number
    area_ha?: FloatFieldUpdateOperationsInput | number
    lat?: FloatFieldUpdateOperationsInput | number
    long?: FloatFieldUpdateOperationsInput | number
    coordinates?: InputJsonValue
    name?: StringFieldUpdateOperationsInput | string
    image_uri?: NullableStringFieldUpdateOperationsInput | string | null
    visiona_area_id?: NullableIntFieldUpdateOperationsInput | number | null
    event?: NullableStringFieldUpdateOperationsInput | string | null
    crop?: cropUpdateManyWithoutFieldInput
    many_quotation_modal_package_has_many_field?: many_quotation_modal_package_has_many_fieldUpdateManyWithoutFieldInput
  }

  export type quotationUpdateWithoutCompanyInput = {
    response_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiration_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    antecipated_price?: NullableIntFieldUpdateOperationsInput | number | null
    cash_price?: NullableIntFieldUpdateOperationsInput | number | null
    delayed_price?: NullableIntFieldUpdateOperationsInput | number | null
    quotation_modal_package?: quotation_modal_packageUpdateOneRequiredWithoutQuotationInput
    quotation_checkout?: quotation_checkoutUpdateOneWithoutQuotationInput
  }

  export type diagnosisUpdateWithoutCropInput = {
    report_date?: DateTimeFieldUpdateOperationsInput | Date | string
    affected_area_ha?: FloatFieldUpdateOperationsInput | number
    infestation?: infestationUpdateManyWithoutDiagnosisInput
    prescription?: prescriptionUpdateManyWithoutDiagnosisInput
  }

  export type infestationUpdateWithoutDiagnosisInput = {
    area_ha?: FloatFieldUpdateOperationsInput | number
    points?: InputJsonValue | null
    plague?: plagueUpdateOneRequiredWithoutInfestationInput
  }

  export type prescriptionUpdateWithoutDiagnosisInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: InputJsonValue
    pulverization_method?: IntFieldUpdateOperationsInput | number
    author?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type areaUpdateWithoutFarmInput = {
    code?: IntFieldUpdateOperationsInput | number
    lat?: FloatFieldUpdateOperationsInput | number
    long?: FloatFieldUpdateOperationsInput | number
    coordinates?: InputJsonValue | null
    name?: StringFieldUpdateOperationsInput | string
    zone?: NullableStringFieldUpdateOperationsInput | string | null
    state_initials?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    demand?: NullableStringFieldUpdateOperationsInput | string | null
    field?: fieldUpdateManyWithoutAreaInput
  }

  export type imagingUpdateWithoutFarmInput = {
    directory?: StringFieldUpdateOperationsInput | string
    processing_timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    imaging_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type many_user_has_many_farmUpdateWithoutFarmInput = {
    user?: userUpdateOneRequiredWithoutMany_user_has_many_farmInput
  }

  export type cropUpdateWithoutFieldInput = {
    crop_type?: StringFieldUpdateOperationsInput | string
    variety?: StringFieldUpdateOperationsInput | string
    sowing_date?: DateTimeFieldUpdateOperationsInput | Date | string
    expected_harvest_date?: DateTimeFieldUpdateOperationsInput | Date | string
    number?: IntFieldUpdateOperationsInput | number
    is_diagnosis_hired?: NullableBoolFieldUpdateOperationsInput | boolean | null
    diagnosis?: diagnosisUpdateManyWithoutCropInput
  }

  export type many_quotation_modal_package_has_many_fieldUpdateWithoutFieldInput = {
    quotation_modal_package?: quotation_modal_packageUpdateOneRequiredWithoutMany_quotation_modal_package_has_many_fieldInput
  }

  export type infestationUpdateWithoutPlagueInput = {
    area_ha?: FloatFieldUpdateOperationsInput | number
    points?: InputJsonValue | null
    diagnosis?: diagnosisUpdateOneRequiredWithoutInfestationInput
  }

  export type user_accepted_privacy_policyUpdateWithoutPrivacy_policyInput = {
    accepted_date?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneRequiredWithoutUser_accepted_privacy_policyInput
  }

  export type many_quotation_modal_package_has_many_fieldUpdateWithoutQuotation_modal_packageInput = {
    field?: fieldUpdateOneRequiredWithoutMany_quotation_modal_package_has_many_fieldInput
  }

  export type quotationUpdateWithoutQuotation_modal_packageInput = {
    response_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiration_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    antecipated_price?: NullableIntFieldUpdateOperationsInput | number | null
    cash_price?: NullableIntFieldUpdateOperationsInput | number | null
    delayed_price?: NullableIntFieldUpdateOperationsInput | number | null
    company?: companyUpdateOneRequiredWithoutQuotationInput
    quotation_checkout?: quotation_checkoutUpdateOneWithoutQuotationInput
  }

  export type quotation_modal_packageUpdateWithoutQuotation_packageInput = {
    pulverization_method?: IntFieldUpdateOperationsInput | number
    many_quotation_modal_package_has_many_field?: many_quotation_modal_package_has_many_fieldUpdateManyWithoutQuotation_modal_packageInput
    quotation?: quotationUpdateManyWithoutQuotation_modal_packageInput
  }

  export type user_roleUpdateWithoutRoleInput = {
    user?: userUpdateOneRequiredWithoutUser_roleInput
  }

  export type addressUpdateWithoutStateInput = {
    street?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    number?: NullableIntFieldUpdateOperationsInput | number | null
    km?: NullableIntFieldUpdateOperationsInput | number | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    contact_name?: NullableStringFieldUpdateOperationsInput | string | null
    mobile_number?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    company?: companyUpdateManyWithoutAddressInput
    farm?: farmUpdateManyWithoutAddressInput
  }

  export type user_accepted_termsUpdateWithoutTerms_and_conditionsInput = {
    accepted_date?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneRequiredWithoutUser_accepted_termsInput
  }

  export type many_user_has_many_farmUpdateWithoutUserInput = {
    farm?: farmUpdateOneRequiredWithoutMany_user_has_many_farmInput
  }

  export type notificationUpdateWithoutUserInput = {
    type?: IntFieldUpdateOperationsInput | number
    body?: InputJsonValue
    sent_date?: DateTimeFieldUpdateOperationsInput | Date | string
    read_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    delivered_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type user_accepted_privacy_policyUpdateWithoutUserInput = {
    accepted_date?: DateTimeFieldUpdateOperationsInput | Date | string
    privacy_policy?: privacy_policyUpdateOneRequiredWithoutUser_accepted_privacy_policyInput
  }

  export type user_accepted_termsUpdateWithoutUserInput = {
    accepted_date?: DateTimeFieldUpdateOperationsInput | Date | string
    terms_and_conditions?: terms_and_conditionsUpdateOneRequiredWithoutUser_accepted_termsInput
  }

  export type user_roleUpdateWithoutUserInput = {
    role?: roleUpdateOneRequiredWithoutUser_roleInput
  }



  /**
   * Batch Payload for updateMany & deleteMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.DMMF.Document;
}

/*
* Exports for compatibility introduced in 2.12.0
* Please import from the Prisma namespace instead
*/

/**
 * @deprecated Renamed to `Prisma.AddressScalarFieldEnum`
 */
export type AddressScalarFieldEnum = Prisma.AddressScalarFieldEnum

/**
 * @deprecated Renamed to `Prisma.AreaScalarFieldEnum`
 */
export type AreaScalarFieldEnum = Prisma.AreaScalarFieldEnum

/**
 * @deprecated Renamed to `Prisma.CompanyScalarFieldEnum`
 */
export type CompanyScalarFieldEnum = Prisma.CompanyScalarFieldEnum

/**
 * @deprecated Renamed to `Prisma.CropScalarFieldEnum`
 */
export type CropScalarFieldEnum = Prisma.CropScalarFieldEnum

/**
 * @deprecated Renamed to `Prisma.DiagnosisScalarFieldEnum`
 */
export type DiagnosisScalarFieldEnum = Prisma.DiagnosisScalarFieldEnum

/**
 * @deprecated Renamed to `Prisma.EmailScalarFieldEnum`
 */
export type EmailScalarFieldEnum = Prisma.EmailScalarFieldEnum

/**
 * @deprecated Renamed to `Prisma.FarmScalarFieldEnum`
 */
export type FarmScalarFieldEnum = Prisma.FarmScalarFieldEnum

/**
 * @deprecated Renamed to `Prisma.FieldScalarFieldEnum`
 */
export type FieldScalarFieldEnum = Prisma.FieldScalarFieldEnum

/**
 * @deprecated Renamed to `Prisma.ImagingScalarFieldEnum`
 */
export type ImagingScalarFieldEnum = Prisma.ImagingScalarFieldEnum

/**
 * @deprecated Renamed to `Prisma.InfestationScalarFieldEnum`
 */
export type InfestationScalarFieldEnum = Prisma.InfestationScalarFieldEnum

/**
 * @deprecated Renamed to `Prisma.Many_quotation_modal_package_has_many_fieldScalarFieldEnum`
 */
export type Many_quotation_modal_package_has_many_fieldScalarFieldEnum = Prisma.Many_quotation_modal_package_has_many_fieldScalarFieldEnum

/**
 * @deprecated Renamed to `Prisma.Many_user_has_many_farmScalarFieldEnum`
 */
export type Many_user_has_many_farmScalarFieldEnum = Prisma.Many_user_has_many_farmScalarFieldEnum

/**
 * @deprecated Renamed to `Prisma.NotificationScalarFieldEnum`
 */
export type NotificationScalarFieldEnum = Prisma.NotificationScalarFieldEnum

/**
 * @deprecated Renamed to `Prisma.PlagueScalarFieldEnum`
 */
export type PlagueScalarFieldEnum = Prisma.PlagueScalarFieldEnum

/**
 * @deprecated Renamed to `Prisma.PrescriptionScalarFieldEnum`
 */
export type PrescriptionScalarFieldEnum = Prisma.PrescriptionScalarFieldEnum

/**
 * @deprecated Renamed to `Prisma.Privacy_policyScalarFieldEnum`
 */
export type Privacy_policyScalarFieldEnum = Prisma.Privacy_policyScalarFieldEnum

/**
 * @deprecated Renamed to `Prisma.QuotationScalarFieldEnum`
 */
export type QuotationScalarFieldEnum = Prisma.QuotationScalarFieldEnum

/**
 * @deprecated Renamed to `Prisma.Quotation_checkoutScalarFieldEnum`
 */
export type Quotation_checkoutScalarFieldEnum = Prisma.Quotation_checkoutScalarFieldEnum

/**
 * @deprecated Renamed to `Prisma.Quotation_modal_packageScalarFieldEnum`
 */
export type Quotation_modal_packageScalarFieldEnum = Prisma.Quotation_modal_packageScalarFieldEnum

/**
 * @deprecated Renamed to `Prisma.Quotation_packageScalarFieldEnum`
 */
export type Quotation_packageScalarFieldEnum = Prisma.Quotation_packageScalarFieldEnum

/**
 * @deprecated Renamed to `Prisma.RoleScalarFieldEnum`
 */
export type RoleScalarFieldEnum = Prisma.RoleScalarFieldEnum

/**
 * @deprecated Renamed to `Prisma.Seed_revisionScalarFieldEnum`
 */
export type Seed_revisionScalarFieldEnum = Prisma.Seed_revisionScalarFieldEnum

/**
 * @deprecated Renamed to `Prisma.StateScalarFieldEnum`
 */
export type StateScalarFieldEnum = Prisma.StateScalarFieldEnum

/**
 * @deprecated Renamed to `Prisma.Terms_and_conditionsScalarFieldEnum`
 */
export type Terms_and_conditionsScalarFieldEnum = Prisma.Terms_and_conditionsScalarFieldEnum

/**
 * @deprecated Renamed to `Prisma.UserScalarFieldEnum`
 */
export type UserScalarFieldEnum = Prisma.UserScalarFieldEnum

/**
 * @deprecated Renamed to `Prisma.User_accepted_privacy_policyScalarFieldEnum`
 */
export type User_accepted_privacy_policyScalarFieldEnum = Prisma.User_accepted_privacy_policyScalarFieldEnum

/**
 * @deprecated Renamed to `Prisma.User_accepted_termsScalarFieldEnum`
 */
export type User_accepted_termsScalarFieldEnum = Prisma.User_accepted_termsScalarFieldEnum

/**
 * @deprecated Renamed to `Prisma.User_roleScalarFieldEnum`
 */
export type User_roleScalarFieldEnum = Prisma.User_roleScalarFieldEnum

/**
 * @deprecated Renamed to `Prisma.SortOrder`
 */
export type SortOrder = Prisma.SortOrder

/**
 * @deprecated Renamed to `Prisma.QueryMode`
 */
export type QueryMode = Prisma.QueryMode

/**
 * @deprecated Renamed to `Prisma.ModelName`
 */
export type ModelName = Prisma.ModelName

/**
 * @deprecated Renamed to `Prisma.AggregateAddress`
 */
export type AggregateAddress = Prisma.AggregateAddress

/**
 * @deprecated Renamed to `Prisma.AddressAvgAggregateOutputType`
 */
export type AddressAvgAggregateOutputType = Prisma.AddressAvgAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.AddressSumAggregateOutputType`
 */
export type AddressSumAggregateOutputType = Prisma.AddressSumAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.AddressMinAggregateOutputType`
 */
export type AddressMinAggregateOutputType = Prisma.AddressMinAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.AddressMaxAggregateOutputType`
 */
export type AddressMaxAggregateOutputType = Prisma.AddressMaxAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.AddressCountAggregateOutputType`
 */
export type AddressCountAggregateOutputType = Prisma.AddressCountAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.AggregateAddressArgs`
 */
export type AggregateAddressArgs = Prisma.AggregateAddressArgs

/**
 * @deprecated Renamed to `Prisma.AddressAvgAggregateInputType`
 */
export type AddressAvgAggregateInputType = Prisma.AddressAvgAggregateInputType

/**
 * @deprecated Renamed to `Prisma.AddressSumAggregateInputType`
 */
export type AddressSumAggregateInputType = Prisma.AddressSumAggregateInputType

/**
 * @deprecated Renamed to `Prisma.AddressMinAggregateInputType`
 */
export type AddressMinAggregateInputType = Prisma.AddressMinAggregateInputType

/**
 * @deprecated Renamed to `Prisma.AddressMaxAggregateInputType`
 */
export type AddressMaxAggregateInputType = Prisma.AddressMaxAggregateInputType

/**
 * @deprecated Renamed to `Prisma.AddressCountAggregateInputType`
 */
export type AddressCountAggregateInputType = Prisma.AddressCountAggregateInputType

/**
 * @deprecated Renamed to `Prisma.addressSelect`
 */
export type addressSelect = Prisma.addressSelect

/**
 * @deprecated Renamed to `Prisma.addressInclude`
 */
export type addressInclude = Prisma.addressInclude

/**
 * @deprecated Renamed to `Prisma.FindUniqueaddressArgs`
 */
export type FindUniqueaddressArgs = Prisma.FindUniqueaddressArgs

/**
 * @deprecated Renamed to `Prisma.FindFirstaddressArgs`
 */
export type FindFirstaddressArgs = Prisma.FindFirstaddressArgs

/**
 * @deprecated Renamed to `Prisma.FindManyaddressArgs`
 */
export type FindManyaddressArgs = Prisma.FindManyaddressArgs

/**
 * @deprecated Renamed to `Prisma.addressCreateArgs`
 */
export type addressCreateArgs = Prisma.addressCreateArgs

/**
 * @deprecated Renamed to `Prisma.addressUpdateArgs`
 */
export type addressUpdateArgs = Prisma.addressUpdateArgs

/**
 * @deprecated Renamed to `Prisma.addressUpdateManyArgs`
 */
export type addressUpdateManyArgs = Prisma.addressUpdateManyArgs

/**
 * @deprecated Renamed to `Prisma.addressUpsertArgs`
 */
export type addressUpsertArgs = Prisma.addressUpsertArgs

/**
 * @deprecated Renamed to `Prisma.addressDeleteArgs`
 */
export type addressDeleteArgs = Prisma.addressDeleteArgs

/**
 * @deprecated Renamed to `Prisma.addressDeleteManyArgs`
 */
export type addressDeleteManyArgs = Prisma.addressDeleteManyArgs

/**
 * @deprecated Renamed to `Prisma.AggregateArea`
 */
export type AggregateArea = Prisma.AggregateArea

/**
 * @deprecated Renamed to `Prisma.AreaAvgAggregateOutputType`
 */
export type AreaAvgAggregateOutputType = Prisma.AreaAvgAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.AreaSumAggregateOutputType`
 */
export type AreaSumAggregateOutputType = Prisma.AreaSumAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.AreaMinAggregateOutputType`
 */
export type AreaMinAggregateOutputType = Prisma.AreaMinAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.AreaMaxAggregateOutputType`
 */
export type AreaMaxAggregateOutputType = Prisma.AreaMaxAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.AreaCountAggregateOutputType`
 */
export type AreaCountAggregateOutputType = Prisma.AreaCountAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.AggregateAreaArgs`
 */
export type AggregateAreaArgs = Prisma.AggregateAreaArgs

/**
 * @deprecated Renamed to `Prisma.AreaAvgAggregateInputType`
 */
export type AreaAvgAggregateInputType = Prisma.AreaAvgAggregateInputType

/**
 * @deprecated Renamed to `Prisma.AreaSumAggregateInputType`
 */
export type AreaSumAggregateInputType = Prisma.AreaSumAggregateInputType

/**
 * @deprecated Renamed to `Prisma.AreaMinAggregateInputType`
 */
export type AreaMinAggregateInputType = Prisma.AreaMinAggregateInputType

/**
 * @deprecated Renamed to `Prisma.AreaMaxAggregateInputType`
 */
export type AreaMaxAggregateInputType = Prisma.AreaMaxAggregateInputType

/**
 * @deprecated Renamed to `Prisma.AreaCountAggregateInputType`
 */
export type AreaCountAggregateInputType = Prisma.AreaCountAggregateInputType

/**
 * @deprecated Renamed to `Prisma.areaSelect`
 */
export type areaSelect = Prisma.areaSelect

/**
 * @deprecated Renamed to `Prisma.areaInclude`
 */
export type areaInclude = Prisma.areaInclude

/**
 * @deprecated Renamed to `Prisma.FindUniqueareaArgs`
 */
export type FindUniqueareaArgs = Prisma.FindUniqueareaArgs

/**
 * @deprecated Renamed to `Prisma.FindFirstareaArgs`
 */
export type FindFirstareaArgs = Prisma.FindFirstareaArgs

/**
 * @deprecated Renamed to `Prisma.FindManyareaArgs`
 */
export type FindManyareaArgs = Prisma.FindManyareaArgs

/**
 * @deprecated Renamed to `Prisma.areaCreateArgs`
 */
export type areaCreateArgs = Prisma.areaCreateArgs

/**
 * @deprecated Renamed to `Prisma.areaUpdateArgs`
 */
export type areaUpdateArgs = Prisma.areaUpdateArgs

/**
 * @deprecated Renamed to `Prisma.areaUpdateManyArgs`
 */
export type areaUpdateManyArgs = Prisma.areaUpdateManyArgs

/**
 * @deprecated Renamed to `Prisma.areaUpsertArgs`
 */
export type areaUpsertArgs = Prisma.areaUpsertArgs

/**
 * @deprecated Renamed to `Prisma.areaDeleteArgs`
 */
export type areaDeleteArgs = Prisma.areaDeleteArgs

/**
 * @deprecated Renamed to `Prisma.areaDeleteManyArgs`
 */
export type areaDeleteManyArgs = Prisma.areaDeleteManyArgs

/**
 * @deprecated Renamed to `Prisma.AggregateCompany`
 */
export type AggregateCompany = Prisma.AggregateCompany

/**
 * @deprecated Renamed to `Prisma.CompanyAvgAggregateOutputType`
 */
export type CompanyAvgAggregateOutputType = Prisma.CompanyAvgAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.CompanySumAggregateOutputType`
 */
export type CompanySumAggregateOutputType = Prisma.CompanySumAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.CompanyMinAggregateOutputType`
 */
export type CompanyMinAggregateOutputType = Prisma.CompanyMinAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.CompanyMaxAggregateOutputType`
 */
export type CompanyMaxAggregateOutputType = Prisma.CompanyMaxAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.CompanyCountAggregateOutputType`
 */
export type CompanyCountAggregateOutputType = Prisma.CompanyCountAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.AggregateCompanyArgs`
 */
export type AggregateCompanyArgs = Prisma.AggregateCompanyArgs

/**
 * @deprecated Renamed to `Prisma.CompanyAvgAggregateInputType`
 */
export type CompanyAvgAggregateInputType = Prisma.CompanyAvgAggregateInputType

/**
 * @deprecated Renamed to `Prisma.CompanySumAggregateInputType`
 */
export type CompanySumAggregateInputType = Prisma.CompanySumAggregateInputType

/**
 * @deprecated Renamed to `Prisma.CompanyMinAggregateInputType`
 */
export type CompanyMinAggregateInputType = Prisma.CompanyMinAggregateInputType

/**
 * @deprecated Renamed to `Prisma.CompanyMaxAggregateInputType`
 */
export type CompanyMaxAggregateInputType = Prisma.CompanyMaxAggregateInputType

/**
 * @deprecated Renamed to `Prisma.CompanyCountAggregateInputType`
 */
export type CompanyCountAggregateInputType = Prisma.CompanyCountAggregateInputType

/**
 * @deprecated Renamed to `Prisma.companySelect`
 */
export type companySelect = Prisma.companySelect

/**
 * @deprecated Renamed to `Prisma.companyInclude`
 */
export type companyInclude = Prisma.companyInclude

/**
 * @deprecated Renamed to `Prisma.FindUniquecompanyArgs`
 */
export type FindUniquecompanyArgs = Prisma.FindUniquecompanyArgs

/**
 * @deprecated Renamed to `Prisma.FindFirstcompanyArgs`
 */
export type FindFirstcompanyArgs = Prisma.FindFirstcompanyArgs

/**
 * @deprecated Renamed to `Prisma.FindManycompanyArgs`
 */
export type FindManycompanyArgs = Prisma.FindManycompanyArgs

/**
 * @deprecated Renamed to `Prisma.companyCreateArgs`
 */
export type companyCreateArgs = Prisma.companyCreateArgs

/**
 * @deprecated Renamed to `Prisma.companyUpdateArgs`
 */
export type companyUpdateArgs = Prisma.companyUpdateArgs

/**
 * @deprecated Renamed to `Prisma.companyUpdateManyArgs`
 */
export type companyUpdateManyArgs = Prisma.companyUpdateManyArgs

/**
 * @deprecated Renamed to `Prisma.companyUpsertArgs`
 */
export type companyUpsertArgs = Prisma.companyUpsertArgs

/**
 * @deprecated Renamed to `Prisma.companyDeleteArgs`
 */
export type companyDeleteArgs = Prisma.companyDeleteArgs

/**
 * @deprecated Renamed to `Prisma.companyDeleteManyArgs`
 */
export type companyDeleteManyArgs = Prisma.companyDeleteManyArgs

/**
 * @deprecated Renamed to `Prisma.AggregateCrop`
 */
export type AggregateCrop = Prisma.AggregateCrop

/**
 * @deprecated Renamed to `Prisma.CropAvgAggregateOutputType`
 */
export type CropAvgAggregateOutputType = Prisma.CropAvgAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.CropSumAggregateOutputType`
 */
export type CropSumAggregateOutputType = Prisma.CropSumAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.CropMinAggregateOutputType`
 */
export type CropMinAggregateOutputType = Prisma.CropMinAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.CropMaxAggregateOutputType`
 */
export type CropMaxAggregateOutputType = Prisma.CropMaxAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.CropCountAggregateOutputType`
 */
export type CropCountAggregateOutputType = Prisma.CropCountAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.AggregateCropArgs`
 */
export type AggregateCropArgs = Prisma.AggregateCropArgs

/**
 * @deprecated Renamed to `Prisma.CropAvgAggregateInputType`
 */
export type CropAvgAggregateInputType = Prisma.CropAvgAggregateInputType

/**
 * @deprecated Renamed to `Prisma.CropSumAggregateInputType`
 */
export type CropSumAggregateInputType = Prisma.CropSumAggregateInputType

/**
 * @deprecated Renamed to `Prisma.CropMinAggregateInputType`
 */
export type CropMinAggregateInputType = Prisma.CropMinAggregateInputType

/**
 * @deprecated Renamed to `Prisma.CropMaxAggregateInputType`
 */
export type CropMaxAggregateInputType = Prisma.CropMaxAggregateInputType

/**
 * @deprecated Renamed to `Prisma.CropCountAggregateInputType`
 */
export type CropCountAggregateInputType = Prisma.CropCountAggregateInputType

/**
 * @deprecated Renamed to `Prisma.cropSelect`
 */
export type cropSelect = Prisma.cropSelect

/**
 * @deprecated Renamed to `Prisma.cropInclude`
 */
export type cropInclude = Prisma.cropInclude

/**
 * @deprecated Renamed to `Prisma.FindUniquecropArgs`
 */
export type FindUniquecropArgs = Prisma.FindUniquecropArgs

/**
 * @deprecated Renamed to `Prisma.FindFirstcropArgs`
 */
export type FindFirstcropArgs = Prisma.FindFirstcropArgs

/**
 * @deprecated Renamed to `Prisma.FindManycropArgs`
 */
export type FindManycropArgs = Prisma.FindManycropArgs

/**
 * @deprecated Renamed to `Prisma.cropCreateArgs`
 */
export type cropCreateArgs = Prisma.cropCreateArgs

/**
 * @deprecated Renamed to `Prisma.cropUpdateArgs`
 */
export type cropUpdateArgs = Prisma.cropUpdateArgs

/**
 * @deprecated Renamed to `Prisma.cropUpdateManyArgs`
 */
export type cropUpdateManyArgs = Prisma.cropUpdateManyArgs

/**
 * @deprecated Renamed to `Prisma.cropUpsertArgs`
 */
export type cropUpsertArgs = Prisma.cropUpsertArgs

/**
 * @deprecated Renamed to `Prisma.cropDeleteArgs`
 */
export type cropDeleteArgs = Prisma.cropDeleteArgs

/**
 * @deprecated Renamed to `Prisma.cropDeleteManyArgs`
 */
export type cropDeleteManyArgs = Prisma.cropDeleteManyArgs

/**
 * @deprecated Renamed to `Prisma.AggregateDiagnosis`
 */
export type AggregateDiagnosis = Prisma.AggregateDiagnosis

/**
 * @deprecated Renamed to `Prisma.DiagnosisAvgAggregateOutputType`
 */
export type DiagnosisAvgAggregateOutputType = Prisma.DiagnosisAvgAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.DiagnosisSumAggregateOutputType`
 */
export type DiagnosisSumAggregateOutputType = Prisma.DiagnosisSumAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.DiagnosisMinAggregateOutputType`
 */
export type DiagnosisMinAggregateOutputType = Prisma.DiagnosisMinAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.DiagnosisMaxAggregateOutputType`
 */
export type DiagnosisMaxAggregateOutputType = Prisma.DiagnosisMaxAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.DiagnosisCountAggregateOutputType`
 */
export type DiagnosisCountAggregateOutputType = Prisma.DiagnosisCountAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.AggregateDiagnosisArgs`
 */
export type AggregateDiagnosisArgs = Prisma.AggregateDiagnosisArgs

/**
 * @deprecated Renamed to `Prisma.DiagnosisAvgAggregateInputType`
 */
export type DiagnosisAvgAggregateInputType = Prisma.DiagnosisAvgAggregateInputType

/**
 * @deprecated Renamed to `Prisma.DiagnosisSumAggregateInputType`
 */
export type DiagnosisSumAggregateInputType = Prisma.DiagnosisSumAggregateInputType

/**
 * @deprecated Renamed to `Prisma.DiagnosisMinAggregateInputType`
 */
export type DiagnosisMinAggregateInputType = Prisma.DiagnosisMinAggregateInputType

/**
 * @deprecated Renamed to `Prisma.DiagnosisMaxAggregateInputType`
 */
export type DiagnosisMaxAggregateInputType = Prisma.DiagnosisMaxAggregateInputType

/**
 * @deprecated Renamed to `Prisma.DiagnosisCountAggregateInputType`
 */
export type DiagnosisCountAggregateInputType = Prisma.DiagnosisCountAggregateInputType

/**
 * @deprecated Renamed to `Prisma.diagnosisSelect`
 */
export type diagnosisSelect = Prisma.diagnosisSelect

/**
 * @deprecated Renamed to `Prisma.diagnosisInclude`
 */
export type diagnosisInclude = Prisma.diagnosisInclude

/**
 * @deprecated Renamed to `Prisma.FindUniquediagnosisArgs`
 */
export type FindUniquediagnosisArgs = Prisma.FindUniquediagnosisArgs

/**
 * @deprecated Renamed to `Prisma.FindFirstdiagnosisArgs`
 */
export type FindFirstdiagnosisArgs = Prisma.FindFirstdiagnosisArgs

/**
 * @deprecated Renamed to `Prisma.FindManydiagnosisArgs`
 */
export type FindManydiagnosisArgs = Prisma.FindManydiagnosisArgs

/**
 * @deprecated Renamed to `Prisma.diagnosisCreateArgs`
 */
export type diagnosisCreateArgs = Prisma.diagnosisCreateArgs

/**
 * @deprecated Renamed to `Prisma.diagnosisUpdateArgs`
 */
export type diagnosisUpdateArgs = Prisma.diagnosisUpdateArgs

/**
 * @deprecated Renamed to `Prisma.diagnosisUpdateManyArgs`
 */
export type diagnosisUpdateManyArgs = Prisma.diagnosisUpdateManyArgs

/**
 * @deprecated Renamed to `Prisma.diagnosisUpsertArgs`
 */
export type diagnosisUpsertArgs = Prisma.diagnosisUpsertArgs

/**
 * @deprecated Renamed to `Prisma.diagnosisDeleteArgs`
 */
export type diagnosisDeleteArgs = Prisma.diagnosisDeleteArgs

/**
 * @deprecated Renamed to `Prisma.diagnosisDeleteManyArgs`
 */
export type diagnosisDeleteManyArgs = Prisma.diagnosisDeleteManyArgs

/**
 * @deprecated Renamed to `Prisma.AggregateEmail`
 */
export type AggregateEmail = Prisma.AggregateEmail

/**
 * @deprecated Renamed to `Prisma.EmailAvgAggregateOutputType`
 */
export type EmailAvgAggregateOutputType = Prisma.EmailAvgAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.EmailSumAggregateOutputType`
 */
export type EmailSumAggregateOutputType = Prisma.EmailSumAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.EmailMinAggregateOutputType`
 */
export type EmailMinAggregateOutputType = Prisma.EmailMinAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.EmailMaxAggregateOutputType`
 */
export type EmailMaxAggregateOutputType = Prisma.EmailMaxAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.EmailCountAggregateOutputType`
 */
export type EmailCountAggregateOutputType = Prisma.EmailCountAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.AggregateEmailArgs`
 */
export type AggregateEmailArgs = Prisma.AggregateEmailArgs

/**
 * @deprecated Renamed to `Prisma.EmailAvgAggregateInputType`
 */
export type EmailAvgAggregateInputType = Prisma.EmailAvgAggregateInputType

/**
 * @deprecated Renamed to `Prisma.EmailSumAggregateInputType`
 */
export type EmailSumAggregateInputType = Prisma.EmailSumAggregateInputType

/**
 * @deprecated Renamed to `Prisma.EmailMinAggregateInputType`
 */
export type EmailMinAggregateInputType = Prisma.EmailMinAggregateInputType

/**
 * @deprecated Renamed to `Prisma.EmailMaxAggregateInputType`
 */
export type EmailMaxAggregateInputType = Prisma.EmailMaxAggregateInputType

/**
 * @deprecated Renamed to `Prisma.EmailCountAggregateInputType`
 */
export type EmailCountAggregateInputType = Prisma.EmailCountAggregateInputType

/**
 * @deprecated Renamed to `Prisma.emailSelect`
 */
export type emailSelect = Prisma.emailSelect

/**
 * @deprecated Renamed to `Prisma.FindUniqueemailArgs`
 */
export type FindUniqueemailArgs = Prisma.FindUniqueemailArgs

/**
 * @deprecated Renamed to `Prisma.FindFirstemailArgs`
 */
export type FindFirstemailArgs = Prisma.FindFirstemailArgs

/**
 * @deprecated Renamed to `Prisma.FindManyemailArgs`
 */
export type FindManyemailArgs = Prisma.FindManyemailArgs

/**
 * @deprecated Renamed to `Prisma.emailCreateArgs`
 */
export type emailCreateArgs = Prisma.emailCreateArgs

/**
 * @deprecated Renamed to `Prisma.emailUpdateArgs`
 */
export type emailUpdateArgs = Prisma.emailUpdateArgs

/**
 * @deprecated Renamed to `Prisma.emailUpdateManyArgs`
 */
export type emailUpdateManyArgs = Prisma.emailUpdateManyArgs

/**
 * @deprecated Renamed to `Prisma.emailUpsertArgs`
 */
export type emailUpsertArgs = Prisma.emailUpsertArgs

/**
 * @deprecated Renamed to `Prisma.emailDeleteArgs`
 */
export type emailDeleteArgs = Prisma.emailDeleteArgs

/**
 * @deprecated Renamed to `Prisma.emailDeleteManyArgs`
 */
export type emailDeleteManyArgs = Prisma.emailDeleteManyArgs

/**
 * @deprecated Renamed to `Prisma.AggregateFarm`
 */
export type AggregateFarm = Prisma.AggregateFarm

/**
 * @deprecated Renamed to `Prisma.FarmAvgAggregateOutputType`
 */
export type FarmAvgAggregateOutputType = Prisma.FarmAvgAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.FarmSumAggregateOutputType`
 */
export type FarmSumAggregateOutputType = Prisma.FarmSumAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.FarmMinAggregateOutputType`
 */
export type FarmMinAggregateOutputType = Prisma.FarmMinAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.FarmMaxAggregateOutputType`
 */
export type FarmMaxAggregateOutputType = Prisma.FarmMaxAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.FarmCountAggregateOutputType`
 */
export type FarmCountAggregateOutputType = Prisma.FarmCountAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.AggregateFarmArgs`
 */
export type AggregateFarmArgs = Prisma.AggregateFarmArgs

/**
 * @deprecated Renamed to `Prisma.FarmAvgAggregateInputType`
 */
export type FarmAvgAggregateInputType = Prisma.FarmAvgAggregateInputType

/**
 * @deprecated Renamed to `Prisma.FarmSumAggregateInputType`
 */
export type FarmSumAggregateInputType = Prisma.FarmSumAggregateInputType

/**
 * @deprecated Renamed to `Prisma.FarmMinAggregateInputType`
 */
export type FarmMinAggregateInputType = Prisma.FarmMinAggregateInputType

/**
 * @deprecated Renamed to `Prisma.FarmMaxAggregateInputType`
 */
export type FarmMaxAggregateInputType = Prisma.FarmMaxAggregateInputType

/**
 * @deprecated Renamed to `Prisma.FarmCountAggregateInputType`
 */
export type FarmCountAggregateInputType = Prisma.FarmCountAggregateInputType

/**
 * @deprecated Renamed to `Prisma.farmSelect`
 */
export type farmSelect = Prisma.farmSelect

/**
 * @deprecated Renamed to `Prisma.farmInclude`
 */
export type farmInclude = Prisma.farmInclude

/**
 * @deprecated Renamed to `Prisma.FindUniquefarmArgs`
 */
export type FindUniquefarmArgs = Prisma.FindUniquefarmArgs

/**
 * @deprecated Renamed to `Prisma.FindFirstfarmArgs`
 */
export type FindFirstfarmArgs = Prisma.FindFirstfarmArgs

/**
 * @deprecated Renamed to `Prisma.FindManyfarmArgs`
 */
export type FindManyfarmArgs = Prisma.FindManyfarmArgs

/**
 * @deprecated Renamed to `Prisma.farmCreateArgs`
 */
export type farmCreateArgs = Prisma.farmCreateArgs

/**
 * @deprecated Renamed to `Prisma.farmUpdateArgs`
 */
export type farmUpdateArgs = Prisma.farmUpdateArgs

/**
 * @deprecated Renamed to `Prisma.farmUpdateManyArgs`
 */
export type farmUpdateManyArgs = Prisma.farmUpdateManyArgs

/**
 * @deprecated Renamed to `Prisma.farmUpsertArgs`
 */
export type farmUpsertArgs = Prisma.farmUpsertArgs

/**
 * @deprecated Renamed to `Prisma.farmDeleteArgs`
 */
export type farmDeleteArgs = Prisma.farmDeleteArgs

/**
 * @deprecated Renamed to `Prisma.farmDeleteManyArgs`
 */
export type farmDeleteManyArgs = Prisma.farmDeleteManyArgs

/**
 * @deprecated Renamed to `Prisma.AggregateField`
 */
export type AggregateField = Prisma.AggregateField

/**
 * @deprecated Renamed to `Prisma.FieldAvgAggregateOutputType`
 */
export type FieldAvgAggregateOutputType = Prisma.FieldAvgAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.FieldSumAggregateOutputType`
 */
export type FieldSumAggregateOutputType = Prisma.FieldSumAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.FieldMinAggregateOutputType`
 */
export type FieldMinAggregateOutputType = Prisma.FieldMinAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.FieldMaxAggregateOutputType`
 */
export type FieldMaxAggregateOutputType = Prisma.FieldMaxAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.FieldCountAggregateOutputType`
 */
export type FieldCountAggregateOutputType = Prisma.FieldCountAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.AggregateFieldArgs`
 */
export type AggregateFieldArgs = Prisma.AggregateFieldArgs

/**
 * @deprecated Renamed to `Prisma.FieldAvgAggregateInputType`
 */
export type FieldAvgAggregateInputType = Prisma.FieldAvgAggregateInputType

/**
 * @deprecated Renamed to `Prisma.FieldSumAggregateInputType`
 */
export type FieldSumAggregateInputType = Prisma.FieldSumAggregateInputType

/**
 * @deprecated Renamed to `Prisma.FieldMinAggregateInputType`
 */
export type FieldMinAggregateInputType = Prisma.FieldMinAggregateInputType

/**
 * @deprecated Renamed to `Prisma.FieldMaxAggregateInputType`
 */
export type FieldMaxAggregateInputType = Prisma.FieldMaxAggregateInputType

/**
 * @deprecated Renamed to `Prisma.FieldCountAggregateInputType`
 */
export type FieldCountAggregateInputType = Prisma.FieldCountAggregateInputType

/**
 * @deprecated Renamed to `Prisma.fieldSelect`
 */
export type fieldSelect = Prisma.fieldSelect

/**
 * @deprecated Renamed to `Prisma.fieldInclude`
 */
export type fieldInclude = Prisma.fieldInclude

/**
 * @deprecated Renamed to `Prisma.FindUniquefieldArgs`
 */
export type FindUniquefieldArgs = Prisma.FindUniquefieldArgs

/**
 * @deprecated Renamed to `Prisma.FindFirstfieldArgs`
 */
export type FindFirstfieldArgs = Prisma.FindFirstfieldArgs

/**
 * @deprecated Renamed to `Prisma.FindManyfieldArgs`
 */
export type FindManyfieldArgs = Prisma.FindManyfieldArgs

/**
 * @deprecated Renamed to `Prisma.fieldCreateArgs`
 */
export type fieldCreateArgs = Prisma.fieldCreateArgs

/**
 * @deprecated Renamed to `Prisma.fieldUpdateArgs`
 */
export type fieldUpdateArgs = Prisma.fieldUpdateArgs

/**
 * @deprecated Renamed to `Prisma.fieldUpdateManyArgs`
 */
export type fieldUpdateManyArgs = Prisma.fieldUpdateManyArgs

/**
 * @deprecated Renamed to `Prisma.fieldUpsertArgs`
 */
export type fieldUpsertArgs = Prisma.fieldUpsertArgs

/**
 * @deprecated Renamed to `Prisma.fieldDeleteArgs`
 */
export type fieldDeleteArgs = Prisma.fieldDeleteArgs

/**
 * @deprecated Renamed to `Prisma.fieldDeleteManyArgs`
 */
export type fieldDeleteManyArgs = Prisma.fieldDeleteManyArgs

/**
 * @deprecated Renamed to `Prisma.AggregateImaging`
 */
export type AggregateImaging = Prisma.AggregateImaging

/**
 * @deprecated Renamed to `Prisma.ImagingAvgAggregateOutputType`
 */
export type ImagingAvgAggregateOutputType = Prisma.ImagingAvgAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.ImagingSumAggregateOutputType`
 */
export type ImagingSumAggregateOutputType = Prisma.ImagingSumAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.ImagingMinAggregateOutputType`
 */
export type ImagingMinAggregateOutputType = Prisma.ImagingMinAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.ImagingMaxAggregateOutputType`
 */
export type ImagingMaxAggregateOutputType = Prisma.ImagingMaxAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.ImagingCountAggregateOutputType`
 */
export type ImagingCountAggregateOutputType = Prisma.ImagingCountAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.AggregateImagingArgs`
 */
export type AggregateImagingArgs = Prisma.AggregateImagingArgs

/**
 * @deprecated Renamed to `Prisma.ImagingAvgAggregateInputType`
 */
export type ImagingAvgAggregateInputType = Prisma.ImagingAvgAggregateInputType

/**
 * @deprecated Renamed to `Prisma.ImagingSumAggregateInputType`
 */
export type ImagingSumAggregateInputType = Prisma.ImagingSumAggregateInputType

/**
 * @deprecated Renamed to `Prisma.ImagingMinAggregateInputType`
 */
export type ImagingMinAggregateInputType = Prisma.ImagingMinAggregateInputType

/**
 * @deprecated Renamed to `Prisma.ImagingMaxAggregateInputType`
 */
export type ImagingMaxAggregateInputType = Prisma.ImagingMaxAggregateInputType

/**
 * @deprecated Renamed to `Prisma.ImagingCountAggregateInputType`
 */
export type ImagingCountAggregateInputType = Prisma.ImagingCountAggregateInputType

/**
 * @deprecated Renamed to `Prisma.imagingSelect`
 */
export type imagingSelect = Prisma.imagingSelect

/**
 * @deprecated Renamed to `Prisma.imagingInclude`
 */
export type imagingInclude = Prisma.imagingInclude

/**
 * @deprecated Renamed to `Prisma.FindUniqueimagingArgs`
 */
export type FindUniqueimagingArgs = Prisma.FindUniqueimagingArgs

/**
 * @deprecated Renamed to `Prisma.FindFirstimagingArgs`
 */
export type FindFirstimagingArgs = Prisma.FindFirstimagingArgs

/**
 * @deprecated Renamed to `Prisma.FindManyimagingArgs`
 */
export type FindManyimagingArgs = Prisma.FindManyimagingArgs

/**
 * @deprecated Renamed to `Prisma.imagingCreateArgs`
 */
export type imagingCreateArgs = Prisma.imagingCreateArgs

/**
 * @deprecated Renamed to `Prisma.imagingUpdateArgs`
 */
export type imagingUpdateArgs = Prisma.imagingUpdateArgs

/**
 * @deprecated Renamed to `Prisma.imagingUpdateManyArgs`
 */
export type imagingUpdateManyArgs = Prisma.imagingUpdateManyArgs

/**
 * @deprecated Renamed to `Prisma.imagingUpsertArgs`
 */
export type imagingUpsertArgs = Prisma.imagingUpsertArgs

/**
 * @deprecated Renamed to `Prisma.imagingDeleteArgs`
 */
export type imagingDeleteArgs = Prisma.imagingDeleteArgs

/**
 * @deprecated Renamed to `Prisma.imagingDeleteManyArgs`
 */
export type imagingDeleteManyArgs = Prisma.imagingDeleteManyArgs

/**
 * @deprecated Renamed to `Prisma.AggregateInfestation`
 */
export type AggregateInfestation = Prisma.AggregateInfestation

/**
 * @deprecated Renamed to `Prisma.InfestationAvgAggregateOutputType`
 */
export type InfestationAvgAggregateOutputType = Prisma.InfestationAvgAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.InfestationSumAggregateOutputType`
 */
export type InfestationSumAggregateOutputType = Prisma.InfestationSumAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.InfestationMinAggregateOutputType`
 */
export type InfestationMinAggregateOutputType = Prisma.InfestationMinAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.InfestationMaxAggregateOutputType`
 */
export type InfestationMaxAggregateOutputType = Prisma.InfestationMaxAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.InfestationCountAggregateOutputType`
 */
export type InfestationCountAggregateOutputType = Prisma.InfestationCountAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.AggregateInfestationArgs`
 */
export type AggregateInfestationArgs = Prisma.AggregateInfestationArgs

/**
 * @deprecated Renamed to `Prisma.InfestationAvgAggregateInputType`
 */
export type InfestationAvgAggregateInputType = Prisma.InfestationAvgAggregateInputType

/**
 * @deprecated Renamed to `Prisma.InfestationSumAggregateInputType`
 */
export type InfestationSumAggregateInputType = Prisma.InfestationSumAggregateInputType

/**
 * @deprecated Renamed to `Prisma.InfestationMinAggregateInputType`
 */
export type InfestationMinAggregateInputType = Prisma.InfestationMinAggregateInputType

/**
 * @deprecated Renamed to `Prisma.InfestationMaxAggregateInputType`
 */
export type InfestationMaxAggregateInputType = Prisma.InfestationMaxAggregateInputType

/**
 * @deprecated Renamed to `Prisma.InfestationCountAggregateInputType`
 */
export type InfestationCountAggregateInputType = Prisma.InfestationCountAggregateInputType

/**
 * @deprecated Renamed to `Prisma.infestationSelect`
 */
export type infestationSelect = Prisma.infestationSelect

/**
 * @deprecated Renamed to `Prisma.infestationInclude`
 */
export type infestationInclude = Prisma.infestationInclude

/**
 * @deprecated Renamed to `Prisma.FindUniqueinfestationArgs`
 */
export type FindUniqueinfestationArgs = Prisma.FindUniqueinfestationArgs

/**
 * @deprecated Renamed to `Prisma.FindFirstinfestationArgs`
 */
export type FindFirstinfestationArgs = Prisma.FindFirstinfestationArgs

/**
 * @deprecated Renamed to `Prisma.FindManyinfestationArgs`
 */
export type FindManyinfestationArgs = Prisma.FindManyinfestationArgs

/**
 * @deprecated Renamed to `Prisma.infestationCreateArgs`
 */
export type infestationCreateArgs = Prisma.infestationCreateArgs

/**
 * @deprecated Renamed to `Prisma.infestationUpdateArgs`
 */
export type infestationUpdateArgs = Prisma.infestationUpdateArgs

/**
 * @deprecated Renamed to `Prisma.infestationUpdateManyArgs`
 */
export type infestationUpdateManyArgs = Prisma.infestationUpdateManyArgs

/**
 * @deprecated Renamed to `Prisma.infestationUpsertArgs`
 */
export type infestationUpsertArgs = Prisma.infestationUpsertArgs

/**
 * @deprecated Renamed to `Prisma.infestationDeleteArgs`
 */
export type infestationDeleteArgs = Prisma.infestationDeleteArgs

/**
 * @deprecated Renamed to `Prisma.infestationDeleteManyArgs`
 */
export type infestationDeleteManyArgs = Prisma.infestationDeleteManyArgs

/**
 * @deprecated Renamed to `Prisma.AggregateMany_quotation_modal_package_has_many_field`
 */
export type AggregateMany_quotation_modal_package_has_many_field = Prisma.AggregateMany_quotation_modal_package_has_many_field

/**
 * @deprecated Renamed to `Prisma.Many_quotation_modal_package_has_many_fieldAvgAggregateOutputType`
 */
export type Many_quotation_modal_package_has_many_fieldAvgAggregateOutputType = Prisma.Many_quotation_modal_package_has_many_fieldAvgAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.Many_quotation_modal_package_has_many_fieldSumAggregateOutputType`
 */
export type Many_quotation_modal_package_has_many_fieldSumAggregateOutputType = Prisma.Many_quotation_modal_package_has_many_fieldSumAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.Many_quotation_modal_package_has_many_fieldMinAggregateOutputType`
 */
export type Many_quotation_modal_package_has_many_fieldMinAggregateOutputType = Prisma.Many_quotation_modal_package_has_many_fieldMinAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.Many_quotation_modal_package_has_many_fieldMaxAggregateOutputType`
 */
export type Many_quotation_modal_package_has_many_fieldMaxAggregateOutputType = Prisma.Many_quotation_modal_package_has_many_fieldMaxAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.Many_quotation_modal_package_has_many_fieldCountAggregateOutputType`
 */
export type Many_quotation_modal_package_has_many_fieldCountAggregateOutputType = Prisma.Many_quotation_modal_package_has_many_fieldCountAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.AggregateMany_quotation_modal_package_has_many_fieldArgs`
 */
export type AggregateMany_quotation_modal_package_has_many_fieldArgs = Prisma.AggregateMany_quotation_modal_package_has_many_fieldArgs

/**
 * @deprecated Renamed to `Prisma.Many_quotation_modal_package_has_many_fieldAvgAggregateInputType`
 */
export type Many_quotation_modal_package_has_many_fieldAvgAggregateInputType = Prisma.Many_quotation_modal_package_has_many_fieldAvgAggregateInputType

/**
 * @deprecated Renamed to `Prisma.Many_quotation_modal_package_has_many_fieldSumAggregateInputType`
 */
export type Many_quotation_modal_package_has_many_fieldSumAggregateInputType = Prisma.Many_quotation_modal_package_has_many_fieldSumAggregateInputType

/**
 * @deprecated Renamed to `Prisma.Many_quotation_modal_package_has_many_fieldMinAggregateInputType`
 */
export type Many_quotation_modal_package_has_many_fieldMinAggregateInputType = Prisma.Many_quotation_modal_package_has_many_fieldMinAggregateInputType

/**
 * @deprecated Renamed to `Prisma.Many_quotation_modal_package_has_many_fieldMaxAggregateInputType`
 */
export type Many_quotation_modal_package_has_many_fieldMaxAggregateInputType = Prisma.Many_quotation_modal_package_has_many_fieldMaxAggregateInputType

/**
 * @deprecated Renamed to `Prisma.Many_quotation_modal_package_has_many_fieldCountAggregateInputType`
 */
export type Many_quotation_modal_package_has_many_fieldCountAggregateInputType = Prisma.Many_quotation_modal_package_has_many_fieldCountAggregateInputType

/**
 * @deprecated Renamed to `Prisma.many_quotation_modal_package_has_many_fieldSelect`
 */
export type many_quotation_modal_package_has_many_fieldSelect = Prisma.many_quotation_modal_package_has_many_fieldSelect

/**
 * @deprecated Renamed to `Prisma.many_quotation_modal_package_has_many_fieldInclude`
 */
export type many_quotation_modal_package_has_many_fieldInclude = Prisma.many_quotation_modal_package_has_many_fieldInclude

/**
 * @deprecated Renamed to `Prisma.FindUniquemany_quotation_modal_package_has_many_fieldArgs`
 */
export type FindUniquemany_quotation_modal_package_has_many_fieldArgs = Prisma.FindUniquemany_quotation_modal_package_has_many_fieldArgs

/**
 * @deprecated Renamed to `Prisma.FindFirstmany_quotation_modal_package_has_many_fieldArgs`
 */
export type FindFirstmany_quotation_modal_package_has_many_fieldArgs = Prisma.FindFirstmany_quotation_modal_package_has_many_fieldArgs

/**
 * @deprecated Renamed to `Prisma.FindManymany_quotation_modal_package_has_many_fieldArgs`
 */
export type FindManymany_quotation_modal_package_has_many_fieldArgs = Prisma.FindManymany_quotation_modal_package_has_many_fieldArgs

/**
 * @deprecated Renamed to `Prisma.many_quotation_modal_package_has_many_fieldCreateArgs`
 */
export type many_quotation_modal_package_has_many_fieldCreateArgs = Prisma.many_quotation_modal_package_has_many_fieldCreateArgs

/**
 * @deprecated Renamed to `Prisma.many_quotation_modal_package_has_many_fieldUpdateArgs`
 */
export type many_quotation_modal_package_has_many_fieldUpdateArgs = Prisma.many_quotation_modal_package_has_many_fieldUpdateArgs

/**
 * @deprecated Renamed to `Prisma.many_quotation_modal_package_has_many_fieldUpdateManyArgs`
 */
export type many_quotation_modal_package_has_many_fieldUpdateManyArgs = Prisma.many_quotation_modal_package_has_many_fieldUpdateManyArgs

/**
 * @deprecated Renamed to `Prisma.many_quotation_modal_package_has_many_fieldUpsertArgs`
 */
export type many_quotation_modal_package_has_many_fieldUpsertArgs = Prisma.many_quotation_modal_package_has_many_fieldUpsertArgs

/**
 * @deprecated Renamed to `Prisma.many_quotation_modal_package_has_many_fieldDeleteArgs`
 */
export type many_quotation_modal_package_has_many_fieldDeleteArgs = Prisma.many_quotation_modal_package_has_many_fieldDeleteArgs

/**
 * @deprecated Renamed to `Prisma.many_quotation_modal_package_has_many_fieldDeleteManyArgs`
 */
export type many_quotation_modal_package_has_many_fieldDeleteManyArgs = Prisma.many_quotation_modal_package_has_many_fieldDeleteManyArgs

/**
 * @deprecated Renamed to `Prisma.AggregateMany_user_has_many_farm`
 */
export type AggregateMany_user_has_many_farm = Prisma.AggregateMany_user_has_many_farm

/**
 * @deprecated Renamed to `Prisma.Many_user_has_many_farmAvgAggregateOutputType`
 */
export type Many_user_has_many_farmAvgAggregateOutputType = Prisma.Many_user_has_many_farmAvgAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.Many_user_has_many_farmSumAggregateOutputType`
 */
export type Many_user_has_many_farmSumAggregateOutputType = Prisma.Many_user_has_many_farmSumAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.Many_user_has_many_farmMinAggregateOutputType`
 */
export type Many_user_has_many_farmMinAggregateOutputType = Prisma.Many_user_has_many_farmMinAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.Many_user_has_many_farmMaxAggregateOutputType`
 */
export type Many_user_has_many_farmMaxAggregateOutputType = Prisma.Many_user_has_many_farmMaxAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.Many_user_has_many_farmCountAggregateOutputType`
 */
export type Many_user_has_many_farmCountAggregateOutputType = Prisma.Many_user_has_many_farmCountAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.AggregateMany_user_has_many_farmArgs`
 */
export type AggregateMany_user_has_many_farmArgs = Prisma.AggregateMany_user_has_many_farmArgs

/**
 * @deprecated Renamed to `Prisma.Many_user_has_many_farmAvgAggregateInputType`
 */
export type Many_user_has_many_farmAvgAggregateInputType = Prisma.Many_user_has_many_farmAvgAggregateInputType

/**
 * @deprecated Renamed to `Prisma.Many_user_has_many_farmSumAggregateInputType`
 */
export type Many_user_has_many_farmSumAggregateInputType = Prisma.Many_user_has_many_farmSumAggregateInputType

/**
 * @deprecated Renamed to `Prisma.Many_user_has_many_farmMinAggregateInputType`
 */
export type Many_user_has_many_farmMinAggregateInputType = Prisma.Many_user_has_many_farmMinAggregateInputType

/**
 * @deprecated Renamed to `Prisma.Many_user_has_many_farmMaxAggregateInputType`
 */
export type Many_user_has_many_farmMaxAggregateInputType = Prisma.Many_user_has_many_farmMaxAggregateInputType

/**
 * @deprecated Renamed to `Prisma.Many_user_has_many_farmCountAggregateInputType`
 */
export type Many_user_has_many_farmCountAggregateInputType = Prisma.Many_user_has_many_farmCountAggregateInputType

/**
 * @deprecated Renamed to `Prisma.many_user_has_many_farmSelect`
 */
export type many_user_has_many_farmSelect = Prisma.many_user_has_many_farmSelect

/**
 * @deprecated Renamed to `Prisma.many_user_has_many_farmInclude`
 */
export type many_user_has_many_farmInclude = Prisma.many_user_has_many_farmInclude

/**
 * @deprecated Renamed to `Prisma.FindUniquemany_user_has_many_farmArgs`
 */
export type FindUniquemany_user_has_many_farmArgs = Prisma.FindUniquemany_user_has_many_farmArgs

/**
 * @deprecated Renamed to `Prisma.FindFirstmany_user_has_many_farmArgs`
 */
export type FindFirstmany_user_has_many_farmArgs = Prisma.FindFirstmany_user_has_many_farmArgs

/**
 * @deprecated Renamed to `Prisma.FindManymany_user_has_many_farmArgs`
 */
export type FindManymany_user_has_many_farmArgs = Prisma.FindManymany_user_has_many_farmArgs

/**
 * @deprecated Renamed to `Prisma.many_user_has_many_farmCreateArgs`
 */
export type many_user_has_many_farmCreateArgs = Prisma.many_user_has_many_farmCreateArgs

/**
 * @deprecated Renamed to `Prisma.many_user_has_many_farmUpdateArgs`
 */
export type many_user_has_many_farmUpdateArgs = Prisma.many_user_has_many_farmUpdateArgs

/**
 * @deprecated Renamed to `Prisma.many_user_has_many_farmUpdateManyArgs`
 */
export type many_user_has_many_farmUpdateManyArgs = Prisma.many_user_has_many_farmUpdateManyArgs

/**
 * @deprecated Renamed to `Prisma.many_user_has_many_farmUpsertArgs`
 */
export type many_user_has_many_farmUpsertArgs = Prisma.many_user_has_many_farmUpsertArgs

/**
 * @deprecated Renamed to `Prisma.many_user_has_many_farmDeleteArgs`
 */
export type many_user_has_many_farmDeleteArgs = Prisma.many_user_has_many_farmDeleteArgs

/**
 * @deprecated Renamed to `Prisma.many_user_has_many_farmDeleteManyArgs`
 */
export type many_user_has_many_farmDeleteManyArgs = Prisma.many_user_has_many_farmDeleteManyArgs

/**
 * @deprecated Renamed to `Prisma.AggregateNotification`
 */
export type AggregateNotification = Prisma.AggregateNotification

/**
 * @deprecated Renamed to `Prisma.NotificationAvgAggregateOutputType`
 */
export type NotificationAvgAggregateOutputType = Prisma.NotificationAvgAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.NotificationSumAggregateOutputType`
 */
export type NotificationSumAggregateOutputType = Prisma.NotificationSumAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.NotificationMinAggregateOutputType`
 */
export type NotificationMinAggregateOutputType = Prisma.NotificationMinAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.NotificationMaxAggregateOutputType`
 */
export type NotificationMaxAggregateOutputType = Prisma.NotificationMaxAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.NotificationCountAggregateOutputType`
 */
export type NotificationCountAggregateOutputType = Prisma.NotificationCountAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.AggregateNotificationArgs`
 */
export type AggregateNotificationArgs = Prisma.AggregateNotificationArgs

/**
 * @deprecated Renamed to `Prisma.NotificationAvgAggregateInputType`
 */
export type NotificationAvgAggregateInputType = Prisma.NotificationAvgAggregateInputType

/**
 * @deprecated Renamed to `Prisma.NotificationSumAggregateInputType`
 */
export type NotificationSumAggregateInputType = Prisma.NotificationSumAggregateInputType

/**
 * @deprecated Renamed to `Prisma.NotificationMinAggregateInputType`
 */
export type NotificationMinAggregateInputType = Prisma.NotificationMinAggregateInputType

/**
 * @deprecated Renamed to `Prisma.NotificationMaxAggregateInputType`
 */
export type NotificationMaxAggregateInputType = Prisma.NotificationMaxAggregateInputType

/**
 * @deprecated Renamed to `Prisma.NotificationCountAggregateInputType`
 */
export type NotificationCountAggregateInputType = Prisma.NotificationCountAggregateInputType

/**
 * @deprecated Renamed to `Prisma.notificationSelect`
 */
export type notificationSelect = Prisma.notificationSelect

/**
 * @deprecated Renamed to `Prisma.notificationInclude`
 */
export type notificationInclude = Prisma.notificationInclude

/**
 * @deprecated Renamed to `Prisma.FindUniquenotificationArgs`
 */
export type FindUniquenotificationArgs = Prisma.FindUniquenotificationArgs

/**
 * @deprecated Renamed to `Prisma.FindFirstnotificationArgs`
 */
export type FindFirstnotificationArgs = Prisma.FindFirstnotificationArgs

/**
 * @deprecated Renamed to `Prisma.FindManynotificationArgs`
 */
export type FindManynotificationArgs = Prisma.FindManynotificationArgs

/**
 * @deprecated Renamed to `Prisma.notificationCreateArgs`
 */
export type notificationCreateArgs = Prisma.notificationCreateArgs

/**
 * @deprecated Renamed to `Prisma.notificationUpdateArgs`
 */
export type notificationUpdateArgs = Prisma.notificationUpdateArgs

/**
 * @deprecated Renamed to `Prisma.notificationUpdateManyArgs`
 */
export type notificationUpdateManyArgs = Prisma.notificationUpdateManyArgs

/**
 * @deprecated Renamed to `Prisma.notificationUpsertArgs`
 */
export type notificationUpsertArgs = Prisma.notificationUpsertArgs

/**
 * @deprecated Renamed to `Prisma.notificationDeleteArgs`
 */
export type notificationDeleteArgs = Prisma.notificationDeleteArgs

/**
 * @deprecated Renamed to `Prisma.notificationDeleteManyArgs`
 */
export type notificationDeleteManyArgs = Prisma.notificationDeleteManyArgs

/**
 * @deprecated Renamed to `Prisma.AggregatePlague`
 */
export type AggregatePlague = Prisma.AggregatePlague

/**
 * @deprecated Renamed to `Prisma.PlagueAvgAggregateOutputType`
 */
export type PlagueAvgAggregateOutputType = Prisma.PlagueAvgAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.PlagueSumAggregateOutputType`
 */
export type PlagueSumAggregateOutputType = Prisma.PlagueSumAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.PlagueMinAggregateOutputType`
 */
export type PlagueMinAggregateOutputType = Prisma.PlagueMinAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.PlagueMaxAggregateOutputType`
 */
export type PlagueMaxAggregateOutputType = Prisma.PlagueMaxAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.PlagueCountAggregateOutputType`
 */
export type PlagueCountAggregateOutputType = Prisma.PlagueCountAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.AggregatePlagueArgs`
 */
export type AggregatePlagueArgs = Prisma.AggregatePlagueArgs

/**
 * @deprecated Renamed to `Prisma.PlagueAvgAggregateInputType`
 */
export type PlagueAvgAggregateInputType = Prisma.PlagueAvgAggregateInputType

/**
 * @deprecated Renamed to `Prisma.PlagueSumAggregateInputType`
 */
export type PlagueSumAggregateInputType = Prisma.PlagueSumAggregateInputType

/**
 * @deprecated Renamed to `Prisma.PlagueMinAggregateInputType`
 */
export type PlagueMinAggregateInputType = Prisma.PlagueMinAggregateInputType

/**
 * @deprecated Renamed to `Prisma.PlagueMaxAggregateInputType`
 */
export type PlagueMaxAggregateInputType = Prisma.PlagueMaxAggregateInputType

/**
 * @deprecated Renamed to `Prisma.PlagueCountAggregateInputType`
 */
export type PlagueCountAggregateInputType = Prisma.PlagueCountAggregateInputType

/**
 * @deprecated Renamed to `Prisma.plagueSelect`
 */
export type plagueSelect = Prisma.plagueSelect

/**
 * @deprecated Renamed to `Prisma.plagueInclude`
 */
export type plagueInclude = Prisma.plagueInclude

/**
 * @deprecated Renamed to `Prisma.FindUniqueplagueArgs`
 */
export type FindUniqueplagueArgs = Prisma.FindUniqueplagueArgs

/**
 * @deprecated Renamed to `Prisma.FindFirstplagueArgs`
 */
export type FindFirstplagueArgs = Prisma.FindFirstplagueArgs

/**
 * @deprecated Renamed to `Prisma.FindManyplagueArgs`
 */
export type FindManyplagueArgs = Prisma.FindManyplagueArgs

/**
 * @deprecated Renamed to `Prisma.plagueCreateArgs`
 */
export type plagueCreateArgs = Prisma.plagueCreateArgs

/**
 * @deprecated Renamed to `Prisma.plagueUpdateArgs`
 */
export type plagueUpdateArgs = Prisma.plagueUpdateArgs

/**
 * @deprecated Renamed to `Prisma.plagueUpdateManyArgs`
 */
export type plagueUpdateManyArgs = Prisma.plagueUpdateManyArgs

/**
 * @deprecated Renamed to `Prisma.plagueUpsertArgs`
 */
export type plagueUpsertArgs = Prisma.plagueUpsertArgs

/**
 * @deprecated Renamed to `Prisma.plagueDeleteArgs`
 */
export type plagueDeleteArgs = Prisma.plagueDeleteArgs

/**
 * @deprecated Renamed to `Prisma.plagueDeleteManyArgs`
 */
export type plagueDeleteManyArgs = Prisma.plagueDeleteManyArgs

/**
 * @deprecated Renamed to `Prisma.AggregatePrescription`
 */
export type AggregatePrescription = Prisma.AggregatePrescription

/**
 * @deprecated Renamed to `Prisma.PrescriptionAvgAggregateOutputType`
 */
export type PrescriptionAvgAggregateOutputType = Prisma.PrescriptionAvgAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.PrescriptionSumAggregateOutputType`
 */
export type PrescriptionSumAggregateOutputType = Prisma.PrescriptionSumAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.PrescriptionMinAggregateOutputType`
 */
export type PrescriptionMinAggregateOutputType = Prisma.PrescriptionMinAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.PrescriptionMaxAggregateOutputType`
 */
export type PrescriptionMaxAggregateOutputType = Prisma.PrescriptionMaxAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.PrescriptionCountAggregateOutputType`
 */
export type PrescriptionCountAggregateOutputType = Prisma.PrescriptionCountAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.AggregatePrescriptionArgs`
 */
export type AggregatePrescriptionArgs = Prisma.AggregatePrescriptionArgs

/**
 * @deprecated Renamed to `Prisma.PrescriptionAvgAggregateInputType`
 */
export type PrescriptionAvgAggregateInputType = Prisma.PrescriptionAvgAggregateInputType

/**
 * @deprecated Renamed to `Prisma.PrescriptionSumAggregateInputType`
 */
export type PrescriptionSumAggregateInputType = Prisma.PrescriptionSumAggregateInputType

/**
 * @deprecated Renamed to `Prisma.PrescriptionMinAggregateInputType`
 */
export type PrescriptionMinAggregateInputType = Prisma.PrescriptionMinAggregateInputType

/**
 * @deprecated Renamed to `Prisma.PrescriptionMaxAggregateInputType`
 */
export type PrescriptionMaxAggregateInputType = Prisma.PrescriptionMaxAggregateInputType

/**
 * @deprecated Renamed to `Prisma.PrescriptionCountAggregateInputType`
 */
export type PrescriptionCountAggregateInputType = Prisma.PrescriptionCountAggregateInputType

/**
 * @deprecated Renamed to `Prisma.prescriptionSelect`
 */
export type prescriptionSelect = Prisma.prescriptionSelect

/**
 * @deprecated Renamed to `Prisma.prescriptionInclude`
 */
export type prescriptionInclude = Prisma.prescriptionInclude

/**
 * @deprecated Renamed to `Prisma.FindUniqueprescriptionArgs`
 */
export type FindUniqueprescriptionArgs = Prisma.FindUniqueprescriptionArgs

/**
 * @deprecated Renamed to `Prisma.FindFirstprescriptionArgs`
 */
export type FindFirstprescriptionArgs = Prisma.FindFirstprescriptionArgs

/**
 * @deprecated Renamed to `Prisma.FindManyprescriptionArgs`
 */
export type FindManyprescriptionArgs = Prisma.FindManyprescriptionArgs

/**
 * @deprecated Renamed to `Prisma.prescriptionCreateArgs`
 */
export type prescriptionCreateArgs = Prisma.prescriptionCreateArgs

/**
 * @deprecated Renamed to `Prisma.prescriptionUpdateArgs`
 */
export type prescriptionUpdateArgs = Prisma.prescriptionUpdateArgs

/**
 * @deprecated Renamed to `Prisma.prescriptionUpdateManyArgs`
 */
export type prescriptionUpdateManyArgs = Prisma.prescriptionUpdateManyArgs

/**
 * @deprecated Renamed to `Prisma.prescriptionUpsertArgs`
 */
export type prescriptionUpsertArgs = Prisma.prescriptionUpsertArgs

/**
 * @deprecated Renamed to `Prisma.prescriptionDeleteArgs`
 */
export type prescriptionDeleteArgs = Prisma.prescriptionDeleteArgs

/**
 * @deprecated Renamed to `Prisma.prescriptionDeleteManyArgs`
 */
export type prescriptionDeleteManyArgs = Prisma.prescriptionDeleteManyArgs

/**
 * @deprecated Renamed to `Prisma.AggregatePrivacy_policy`
 */
export type AggregatePrivacy_policy = Prisma.AggregatePrivacy_policy

/**
 * @deprecated Renamed to `Prisma.Privacy_policyAvgAggregateOutputType`
 */
export type Privacy_policyAvgAggregateOutputType = Prisma.Privacy_policyAvgAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.Privacy_policySumAggregateOutputType`
 */
export type Privacy_policySumAggregateOutputType = Prisma.Privacy_policySumAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.Privacy_policyMinAggregateOutputType`
 */
export type Privacy_policyMinAggregateOutputType = Prisma.Privacy_policyMinAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.Privacy_policyMaxAggregateOutputType`
 */
export type Privacy_policyMaxAggregateOutputType = Prisma.Privacy_policyMaxAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.Privacy_policyCountAggregateOutputType`
 */
export type Privacy_policyCountAggregateOutputType = Prisma.Privacy_policyCountAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.AggregatePrivacy_policyArgs`
 */
export type AggregatePrivacy_policyArgs = Prisma.AggregatePrivacy_policyArgs

/**
 * @deprecated Renamed to `Prisma.Privacy_policyAvgAggregateInputType`
 */
export type Privacy_policyAvgAggregateInputType = Prisma.Privacy_policyAvgAggregateInputType

/**
 * @deprecated Renamed to `Prisma.Privacy_policySumAggregateInputType`
 */
export type Privacy_policySumAggregateInputType = Prisma.Privacy_policySumAggregateInputType

/**
 * @deprecated Renamed to `Prisma.Privacy_policyMinAggregateInputType`
 */
export type Privacy_policyMinAggregateInputType = Prisma.Privacy_policyMinAggregateInputType

/**
 * @deprecated Renamed to `Prisma.Privacy_policyMaxAggregateInputType`
 */
export type Privacy_policyMaxAggregateInputType = Prisma.Privacy_policyMaxAggregateInputType

/**
 * @deprecated Renamed to `Prisma.Privacy_policyCountAggregateInputType`
 */
export type Privacy_policyCountAggregateInputType = Prisma.Privacy_policyCountAggregateInputType

/**
 * @deprecated Renamed to `Prisma.privacy_policySelect`
 */
export type privacy_policySelect = Prisma.privacy_policySelect

/**
 * @deprecated Renamed to `Prisma.privacy_policyInclude`
 */
export type privacy_policyInclude = Prisma.privacy_policyInclude

/**
 * @deprecated Renamed to `Prisma.FindUniqueprivacy_policyArgs`
 */
export type FindUniqueprivacy_policyArgs = Prisma.FindUniqueprivacy_policyArgs

/**
 * @deprecated Renamed to `Prisma.FindFirstprivacy_policyArgs`
 */
export type FindFirstprivacy_policyArgs = Prisma.FindFirstprivacy_policyArgs

/**
 * @deprecated Renamed to `Prisma.FindManyprivacy_policyArgs`
 */
export type FindManyprivacy_policyArgs = Prisma.FindManyprivacy_policyArgs

/**
 * @deprecated Renamed to `Prisma.privacy_policyCreateArgs`
 */
export type privacy_policyCreateArgs = Prisma.privacy_policyCreateArgs

/**
 * @deprecated Renamed to `Prisma.privacy_policyUpdateArgs`
 */
export type privacy_policyUpdateArgs = Prisma.privacy_policyUpdateArgs

/**
 * @deprecated Renamed to `Prisma.privacy_policyUpdateManyArgs`
 */
export type privacy_policyUpdateManyArgs = Prisma.privacy_policyUpdateManyArgs

/**
 * @deprecated Renamed to `Prisma.privacy_policyUpsertArgs`
 */
export type privacy_policyUpsertArgs = Prisma.privacy_policyUpsertArgs

/**
 * @deprecated Renamed to `Prisma.privacy_policyDeleteArgs`
 */
export type privacy_policyDeleteArgs = Prisma.privacy_policyDeleteArgs

/**
 * @deprecated Renamed to `Prisma.privacy_policyDeleteManyArgs`
 */
export type privacy_policyDeleteManyArgs = Prisma.privacy_policyDeleteManyArgs

/**
 * @deprecated Renamed to `Prisma.AggregateQuotation`
 */
export type AggregateQuotation = Prisma.AggregateQuotation

/**
 * @deprecated Renamed to `Prisma.QuotationAvgAggregateOutputType`
 */
export type QuotationAvgAggregateOutputType = Prisma.QuotationAvgAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.QuotationSumAggregateOutputType`
 */
export type QuotationSumAggregateOutputType = Prisma.QuotationSumAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.QuotationMinAggregateOutputType`
 */
export type QuotationMinAggregateOutputType = Prisma.QuotationMinAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.QuotationMaxAggregateOutputType`
 */
export type QuotationMaxAggregateOutputType = Prisma.QuotationMaxAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.QuotationCountAggregateOutputType`
 */
export type QuotationCountAggregateOutputType = Prisma.QuotationCountAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.AggregateQuotationArgs`
 */
export type AggregateQuotationArgs = Prisma.AggregateQuotationArgs

/**
 * @deprecated Renamed to `Prisma.QuotationAvgAggregateInputType`
 */
export type QuotationAvgAggregateInputType = Prisma.QuotationAvgAggregateInputType

/**
 * @deprecated Renamed to `Prisma.QuotationSumAggregateInputType`
 */
export type QuotationSumAggregateInputType = Prisma.QuotationSumAggregateInputType

/**
 * @deprecated Renamed to `Prisma.QuotationMinAggregateInputType`
 */
export type QuotationMinAggregateInputType = Prisma.QuotationMinAggregateInputType

/**
 * @deprecated Renamed to `Prisma.QuotationMaxAggregateInputType`
 */
export type QuotationMaxAggregateInputType = Prisma.QuotationMaxAggregateInputType

/**
 * @deprecated Renamed to `Prisma.QuotationCountAggregateInputType`
 */
export type QuotationCountAggregateInputType = Prisma.QuotationCountAggregateInputType

/**
 * @deprecated Renamed to `Prisma.quotationSelect`
 */
export type quotationSelect = Prisma.quotationSelect

/**
 * @deprecated Renamed to `Prisma.quotationInclude`
 */
export type quotationInclude = Prisma.quotationInclude

/**
 * @deprecated Renamed to `Prisma.FindUniquequotationArgs`
 */
export type FindUniquequotationArgs = Prisma.FindUniquequotationArgs

/**
 * @deprecated Renamed to `Prisma.FindFirstquotationArgs`
 */
export type FindFirstquotationArgs = Prisma.FindFirstquotationArgs

/**
 * @deprecated Renamed to `Prisma.FindManyquotationArgs`
 */
export type FindManyquotationArgs = Prisma.FindManyquotationArgs

/**
 * @deprecated Renamed to `Prisma.quotationCreateArgs`
 */
export type quotationCreateArgs = Prisma.quotationCreateArgs

/**
 * @deprecated Renamed to `Prisma.quotationUpdateArgs`
 */
export type quotationUpdateArgs = Prisma.quotationUpdateArgs

/**
 * @deprecated Renamed to `Prisma.quotationUpdateManyArgs`
 */
export type quotationUpdateManyArgs = Prisma.quotationUpdateManyArgs

/**
 * @deprecated Renamed to `Prisma.quotationUpsertArgs`
 */
export type quotationUpsertArgs = Prisma.quotationUpsertArgs

/**
 * @deprecated Renamed to `Prisma.quotationDeleteArgs`
 */
export type quotationDeleteArgs = Prisma.quotationDeleteArgs

/**
 * @deprecated Renamed to `Prisma.quotationDeleteManyArgs`
 */
export type quotationDeleteManyArgs = Prisma.quotationDeleteManyArgs

/**
 * @deprecated Renamed to `Prisma.AggregateQuotation_checkout`
 */
export type AggregateQuotation_checkout = Prisma.AggregateQuotation_checkout

/**
 * @deprecated Renamed to `Prisma.Quotation_checkoutAvgAggregateOutputType`
 */
export type Quotation_checkoutAvgAggregateOutputType = Prisma.Quotation_checkoutAvgAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.Quotation_checkoutSumAggregateOutputType`
 */
export type Quotation_checkoutSumAggregateOutputType = Prisma.Quotation_checkoutSumAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.Quotation_checkoutMinAggregateOutputType`
 */
export type Quotation_checkoutMinAggregateOutputType = Prisma.Quotation_checkoutMinAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.Quotation_checkoutMaxAggregateOutputType`
 */
export type Quotation_checkoutMaxAggregateOutputType = Prisma.Quotation_checkoutMaxAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.Quotation_checkoutCountAggregateOutputType`
 */
export type Quotation_checkoutCountAggregateOutputType = Prisma.Quotation_checkoutCountAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.AggregateQuotation_checkoutArgs`
 */
export type AggregateQuotation_checkoutArgs = Prisma.AggregateQuotation_checkoutArgs

/**
 * @deprecated Renamed to `Prisma.Quotation_checkoutAvgAggregateInputType`
 */
export type Quotation_checkoutAvgAggregateInputType = Prisma.Quotation_checkoutAvgAggregateInputType

/**
 * @deprecated Renamed to `Prisma.Quotation_checkoutSumAggregateInputType`
 */
export type Quotation_checkoutSumAggregateInputType = Prisma.Quotation_checkoutSumAggregateInputType

/**
 * @deprecated Renamed to `Prisma.Quotation_checkoutMinAggregateInputType`
 */
export type Quotation_checkoutMinAggregateInputType = Prisma.Quotation_checkoutMinAggregateInputType

/**
 * @deprecated Renamed to `Prisma.Quotation_checkoutMaxAggregateInputType`
 */
export type Quotation_checkoutMaxAggregateInputType = Prisma.Quotation_checkoutMaxAggregateInputType

/**
 * @deprecated Renamed to `Prisma.Quotation_checkoutCountAggregateInputType`
 */
export type Quotation_checkoutCountAggregateInputType = Prisma.Quotation_checkoutCountAggregateInputType

/**
 * @deprecated Renamed to `Prisma.quotation_checkoutSelect`
 */
export type quotation_checkoutSelect = Prisma.quotation_checkoutSelect

/**
 * @deprecated Renamed to `Prisma.quotation_checkoutInclude`
 */
export type quotation_checkoutInclude = Prisma.quotation_checkoutInclude

/**
 * @deprecated Renamed to `Prisma.FindUniquequotation_checkoutArgs`
 */
export type FindUniquequotation_checkoutArgs = Prisma.FindUniquequotation_checkoutArgs

/**
 * @deprecated Renamed to `Prisma.FindFirstquotation_checkoutArgs`
 */
export type FindFirstquotation_checkoutArgs = Prisma.FindFirstquotation_checkoutArgs

/**
 * @deprecated Renamed to `Prisma.FindManyquotation_checkoutArgs`
 */
export type FindManyquotation_checkoutArgs = Prisma.FindManyquotation_checkoutArgs

/**
 * @deprecated Renamed to `Prisma.quotation_checkoutCreateArgs`
 */
export type quotation_checkoutCreateArgs = Prisma.quotation_checkoutCreateArgs

/**
 * @deprecated Renamed to `Prisma.quotation_checkoutUpdateArgs`
 */
export type quotation_checkoutUpdateArgs = Prisma.quotation_checkoutUpdateArgs

/**
 * @deprecated Renamed to `Prisma.quotation_checkoutUpdateManyArgs`
 */
export type quotation_checkoutUpdateManyArgs = Prisma.quotation_checkoutUpdateManyArgs

/**
 * @deprecated Renamed to `Prisma.quotation_checkoutUpsertArgs`
 */
export type quotation_checkoutUpsertArgs = Prisma.quotation_checkoutUpsertArgs

/**
 * @deprecated Renamed to `Prisma.quotation_checkoutDeleteArgs`
 */
export type quotation_checkoutDeleteArgs = Prisma.quotation_checkoutDeleteArgs

/**
 * @deprecated Renamed to `Prisma.quotation_checkoutDeleteManyArgs`
 */
export type quotation_checkoutDeleteManyArgs = Prisma.quotation_checkoutDeleteManyArgs

/**
 * @deprecated Renamed to `Prisma.AggregateQuotation_modal_package`
 */
export type AggregateQuotation_modal_package = Prisma.AggregateQuotation_modal_package

/**
 * @deprecated Renamed to `Prisma.Quotation_modal_packageAvgAggregateOutputType`
 */
export type Quotation_modal_packageAvgAggregateOutputType = Prisma.Quotation_modal_packageAvgAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.Quotation_modal_packageSumAggregateOutputType`
 */
export type Quotation_modal_packageSumAggregateOutputType = Prisma.Quotation_modal_packageSumAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.Quotation_modal_packageMinAggregateOutputType`
 */
export type Quotation_modal_packageMinAggregateOutputType = Prisma.Quotation_modal_packageMinAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.Quotation_modal_packageMaxAggregateOutputType`
 */
export type Quotation_modal_packageMaxAggregateOutputType = Prisma.Quotation_modal_packageMaxAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.Quotation_modal_packageCountAggregateOutputType`
 */
export type Quotation_modal_packageCountAggregateOutputType = Prisma.Quotation_modal_packageCountAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.AggregateQuotation_modal_packageArgs`
 */
export type AggregateQuotation_modal_packageArgs = Prisma.AggregateQuotation_modal_packageArgs

/**
 * @deprecated Renamed to `Prisma.Quotation_modal_packageAvgAggregateInputType`
 */
export type Quotation_modal_packageAvgAggregateInputType = Prisma.Quotation_modal_packageAvgAggregateInputType

/**
 * @deprecated Renamed to `Prisma.Quotation_modal_packageSumAggregateInputType`
 */
export type Quotation_modal_packageSumAggregateInputType = Prisma.Quotation_modal_packageSumAggregateInputType

/**
 * @deprecated Renamed to `Prisma.Quotation_modal_packageMinAggregateInputType`
 */
export type Quotation_modal_packageMinAggregateInputType = Prisma.Quotation_modal_packageMinAggregateInputType

/**
 * @deprecated Renamed to `Prisma.Quotation_modal_packageMaxAggregateInputType`
 */
export type Quotation_modal_packageMaxAggregateInputType = Prisma.Quotation_modal_packageMaxAggregateInputType

/**
 * @deprecated Renamed to `Prisma.Quotation_modal_packageCountAggregateInputType`
 */
export type Quotation_modal_packageCountAggregateInputType = Prisma.Quotation_modal_packageCountAggregateInputType

/**
 * @deprecated Renamed to `Prisma.quotation_modal_packageSelect`
 */
export type quotation_modal_packageSelect = Prisma.quotation_modal_packageSelect

/**
 * @deprecated Renamed to `Prisma.quotation_modal_packageInclude`
 */
export type quotation_modal_packageInclude = Prisma.quotation_modal_packageInclude

/**
 * @deprecated Renamed to `Prisma.FindUniquequotation_modal_packageArgs`
 */
export type FindUniquequotation_modal_packageArgs = Prisma.FindUniquequotation_modal_packageArgs

/**
 * @deprecated Renamed to `Prisma.FindFirstquotation_modal_packageArgs`
 */
export type FindFirstquotation_modal_packageArgs = Prisma.FindFirstquotation_modal_packageArgs

/**
 * @deprecated Renamed to `Prisma.FindManyquotation_modal_packageArgs`
 */
export type FindManyquotation_modal_packageArgs = Prisma.FindManyquotation_modal_packageArgs

/**
 * @deprecated Renamed to `Prisma.quotation_modal_packageCreateArgs`
 */
export type quotation_modal_packageCreateArgs = Prisma.quotation_modal_packageCreateArgs

/**
 * @deprecated Renamed to `Prisma.quotation_modal_packageUpdateArgs`
 */
export type quotation_modal_packageUpdateArgs = Prisma.quotation_modal_packageUpdateArgs

/**
 * @deprecated Renamed to `Prisma.quotation_modal_packageUpdateManyArgs`
 */
export type quotation_modal_packageUpdateManyArgs = Prisma.quotation_modal_packageUpdateManyArgs

/**
 * @deprecated Renamed to `Prisma.quotation_modal_packageUpsertArgs`
 */
export type quotation_modal_packageUpsertArgs = Prisma.quotation_modal_packageUpsertArgs

/**
 * @deprecated Renamed to `Prisma.quotation_modal_packageDeleteArgs`
 */
export type quotation_modal_packageDeleteArgs = Prisma.quotation_modal_packageDeleteArgs

/**
 * @deprecated Renamed to `Prisma.quotation_modal_packageDeleteManyArgs`
 */
export type quotation_modal_packageDeleteManyArgs = Prisma.quotation_modal_packageDeleteManyArgs

/**
 * @deprecated Renamed to `Prisma.AggregateQuotation_package`
 */
export type AggregateQuotation_package = Prisma.AggregateQuotation_package

/**
 * @deprecated Renamed to `Prisma.Quotation_packageAvgAggregateOutputType`
 */
export type Quotation_packageAvgAggregateOutputType = Prisma.Quotation_packageAvgAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.Quotation_packageSumAggregateOutputType`
 */
export type Quotation_packageSumAggregateOutputType = Prisma.Quotation_packageSumAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.Quotation_packageMinAggregateOutputType`
 */
export type Quotation_packageMinAggregateOutputType = Prisma.Quotation_packageMinAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.Quotation_packageMaxAggregateOutputType`
 */
export type Quotation_packageMaxAggregateOutputType = Prisma.Quotation_packageMaxAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.Quotation_packageCountAggregateOutputType`
 */
export type Quotation_packageCountAggregateOutputType = Prisma.Quotation_packageCountAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.AggregateQuotation_packageArgs`
 */
export type AggregateQuotation_packageArgs = Prisma.AggregateQuotation_packageArgs

/**
 * @deprecated Renamed to `Prisma.Quotation_packageAvgAggregateInputType`
 */
export type Quotation_packageAvgAggregateInputType = Prisma.Quotation_packageAvgAggregateInputType

/**
 * @deprecated Renamed to `Prisma.Quotation_packageSumAggregateInputType`
 */
export type Quotation_packageSumAggregateInputType = Prisma.Quotation_packageSumAggregateInputType

/**
 * @deprecated Renamed to `Prisma.Quotation_packageMinAggregateInputType`
 */
export type Quotation_packageMinAggregateInputType = Prisma.Quotation_packageMinAggregateInputType

/**
 * @deprecated Renamed to `Prisma.Quotation_packageMaxAggregateInputType`
 */
export type Quotation_packageMaxAggregateInputType = Prisma.Quotation_packageMaxAggregateInputType

/**
 * @deprecated Renamed to `Prisma.Quotation_packageCountAggregateInputType`
 */
export type Quotation_packageCountAggregateInputType = Prisma.Quotation_packageCountAggregateInputType

/**
 * @deprecated Renamed to `Prisma.quotation_packageSelect`
 */
export type quotation_packageSelect = Prisma.quotation_packageSelect

/**
 * @deprecated Renamed to `Prisma.quotation_packageInclude`
 */
export type quotation_packageInclude = Prisma.quotation_packageInclude

/**
 * @deprecated Renamed to `Prisma.FindUniquequotation_packageArgs`
 */
export type FindUniquequotation_packageArgs = Prisma.FindUniquequotation_packageArgs

/**
 * @deprecated Renamed to `Prisma.FindFirstquotation_packageArgs`
 */
export type FindFirstquotation_packageArgs = Prisma.FindFirstquotation_packageArgs

/**
 * @deprecated Renamed to `Prisma.FindManyquotation_packageArgs`
 */
export type FindManyquotation_packageArgs = Prisma.FindManyquotation_packageArgs

/**
 * @deprecated Renamed to `Prisma.quotation_packageCreateArgs`
 */
export type quotation_packageCreateArgs = Prisma.quotation_packageCreateArgs

/**
 * @deprecated Renamed to `Prisma.quotation_packageUpdateArgs`
 */
export type quotation_packageUpdateArgs = Prisma.quotation_packageUpdateArgs

/**
 * @deprecated Renamed to `Prisma.quotation_packageUpdateManyArgs`
 */
export type quotation_packageUpdateManyArgs = Prisma.quotation_packageUpdateManyArgs

/**
 * @deprecated Renamed to `Prisma.quotation_packageUpsertArgs`
 */
export type quotation_packageUpsertArgs = Prisma.quotation_packageUpsertArgs

/**
 * @deprecated Renamed to `Prisma.quotation_packageDeleteArgs`
 */
export type quotation_packageDeleteArgs = Prisma.quotation_packageDeleteArgs

/**
 * @deprecated Renamed to `Prisma.quotation_packageDeleteManyArgs`
 */
export type quotation_packageDeleteManyArgs = Prisma.quotation_packageDeleteManyArgs

/**
 * @deprecated Renamed to `Prisma.AggregateRole`
 */
export type AggregateRole = Prisma.AggregateRole

/**
 * @deprecated Renamed to `Prisma.RoleAvgAggregateOutputType`
 */
export type RoleAvgAggregateOutputType = Prisma.RoleAvgAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.RoleSumAggregateOutputType`
 */
export type RoleSumAggregateOutputType = Prisma.RoleSumAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.RoleMinAggregateOutputType`
 */
export type RoleMinAggregateOutputType = Prisma.RoleMinAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.RoleMaxAggregateOutputType`
 */
export type RoleMaxAggregateOutputType = Prisma.RoleMaxAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.RoleCountAggregateOutputType`
 */
export type RoleCountAggregateOutputType = Prisma.RoleCountAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.AggregateRoleArgs`
 */
export type AggregateRoleArgs = Prisma.AggregateRoleArgs

/**
 * @deprecated Renamed to `Prisma.RoleAvgAggregateInputType`
 */
export type RoleAvgAggregateInputType = Prisma.RoleAvgAggregateInputType

/**
 * @deprecated Renamed to `Prisma.RoleSumAggregateInputType`
 */
export type RoleSumAggregateInputType = Prisma.RoleSumAggregateInputType

/**
 * @deprecated Renamed to `Prisma.RoleMinAggregateInputType`
 */
export type RoleMinAggregateInputType = Prisma.RoleMinAggregateInputType

/**
 * @deprecated Renamed to `Prisma.RoleMaxAggregateInputType`
 */
export type RoleMaxAggregateInputType = Prisma.RoleMaxAggregateInputType

/**
 * @deprecated Renamed to `Prisma.RoleCountAggregateInputType`
 */
export type RoleCountAggregateInputType = Prisma.RoleCountAggregateInputType

/**
 * @deprecated Renamed to `Prisma.roleSelect`
 */
export type roleSelect = Prisma.roleSelect

/**
 * @deprecated Renamed to `Prisma.roleInclude`
 */
export type roleInclude = Prisma.roleInclude

/**
 * @deprecated Renamed to `Prisma.FindUniqueroleArgs`
 */
export type FindUniqueroleArgs = Prisma.FindUniqueroleArgs

/**
 * @deprecated Renamed to `Prisma.FindFirstroleArgs`
 */
export type FindFirstroleArgs = Prisma.FindFirstroleArgs

/**
 * @deprecated Renamed to `Prisma.FindManyroleArgs`
 */
export type FindManyroleArgs = Prisma.FindManyroleArgs

/**
 * @deprecated Renamed to `Prisma.roleCreateArgs`
 */
export type roleCreateArgs = Prisma.roleCreateArgs

/**
 * @deprecated Renamed to `Prisma.roleUpdateArgs`
 */
export type roleUpdateArgs = Prisma.roleUpdateArgs

/**
 * @deprecated Renamed to `Prisma.roleUpdateManyArgs`
 */
export type roleUpdateManyArgs = Prisma.roleUpdateManyArgs

/**
 * @deprecated Renamed to `Prisma.roleUpsertArgs`
 */
export type roleUpsertArgs = Prisma.roleUpsertArgs

/**
 * @deprecated Renamed to `Prisma.roleDeleteArgs`
 */
export type roleDeleteArgs = Prisma.roleDeleteArgs

/**
 * @deprecated Renamed to `Prisma.roleDeleteManyArgs`
 */
export type roleDeleteManyArgs = Prisma.roleDeleteManyArgs

/**
 * @deprecated Renamed to `Prisma.AggregateSeed_revision`
 */
export type AggregateSeed_revision = Prisma.AggregateSeed_revision

/**
 * @deprecated Renamed to `Prisma.Seed_revisionAvgAggregateOutputType`
 */
export type Seed_revisionAvgAggregateOutputType = Prisma.Seed_revisionAvgAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.Seed_revisionSumAggregateOutputType`
 */
export type Seed_revisionSumAggregateOutputType = Prisma.Seed_revisionSumAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.Seed_revisionMinAggregateOutputType`
 */
export type Seed_revisionMinAggregateOutputType = Prisma.Seed_revisionMinAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.Seed_revisionMaxAggregateOutputType`
 */
export type Seed_revisionMaxAggregateOutputType = Prisma.Seed_revisionMaxAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.Seed_revisionCountAggregateOutputType`
 */
export type Seed_revisionCountAggregateOutputType = Prisma.Seed_revisionCountAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.AggregateSeed_revisionArgs`
 */
export type AggregateSeed_revisionArgs = Prisma.AggregateSeed_revisionArgs

/**
 * @deprecated Renamed to `Prisma.Seed_revisionAvgAggregateInputType`
 */
export type Seed_revisionAvgAggregateInputType = Prisma.Seed_revisionAvgAggregateInputType

/**
 * @deprecated Renamed to `Prisma.Seed_revisionSumAggregateInputType`
 */
export type Seed_revisionSumAggregateInputType = Prisma.Seed_revisionSumAggregateInputType

/**
 * @deprecated Renamed to `Prisma.Seed_revisionMinAggregateInputType`
 */
export type Seed_revisionMinAggregateInputType = Prisma.Seed_revisionMinAggregateInputType

/**
 * @deprecated Renamed to `Prisma.Seed_revisionMaxAggregateInputType`
 */
export type Seed_revisionMaxAggregateInputType = Prisma.Seed_revisionMaxAggregateInputType

/**
 * @deprecated Renamed to `Prisma.Seed_revisionCountAggregateInputType`
 */
export type Seed_revisionCountAggregateInputType = Prisma.Seed_revisionCountAggregateInputType

/**
 * @deprecated Renamed to `Prisma.seed_revisionSelect`
 */
export type seed_revisionSelect = Prisma.seed_revisionSelect

/**
 * @deprecated Renamed to `Prisma.FindUniqueseed_revisionArgs`
 */
export type FindUniqueseed_revisionArgs = Prisma.FindUniqueseed_revisionArgs

/**
 * @deprecated Renamed to `Prisma.FindFirstseed_revisionArgs`
 */
export type FindFirstseed_revisionArgs = Prisma.FindFirstseed_revisionArgs

/**
 * @deprecated Renamed to `Prisma.FindManyseed_revisionArgs`
 */
export type FindManyseed_revisionArgs = Prisma.FindManyseed_revisionArgs

/**
 * @deprecated Renamed to `Prisma.seed_revisionCreateArgs`
 */
export type seed_revisionCreateArgs = Prisma.seed_revisionCreateArgs

/**
 * @deprecated Renamed to `Prisma.seed_revisionUpdateArgs`
 */
export type seed_revisionUpdateArgs = Prisma.seed_revisionUpdateArgs

/**
 * @deprecated Renamed to `Prisma.seed_revisionUpdateManyArgs`
 */
export type seed_revisionUpdateManyArgs = Prisma.seed_revisionUpdateManyArgs

/**
 * @deprecated Renamed to `Prisma.seed_revisionUpsertArgs`
 */
export type seed_revisionUpsertArgs = Prisma.seed_revisionUpsertArgs

/**
 * @deprecated Renamed to `Prisma.seed_revisionDeleteArgs`
 */
export type seed_revisionDeleteArgs = Prisma.seed_revisionDeleteArgs

/**
 * @deprecated Renamed to `Prisma.seed_revisionDeleteManyArgs`
 */
export type seed_revisionDeleteManyArgs = Prisma.seed_revisionDeleteManyArgs

/**
 * @deprecated Renamed to `Prisma.AggregateState`
 */
export type AggregateState = Prisma.AggregateState

/**
 * @deprecated Renamed to `Prisma.StateAvgAggregateOutputType`
 */
export type StateAvgAggregateOutputType = Prisma.StateAvgAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.StateSumAggregateOutputType`
 */
export type StateSumAggregateOutputType = Prisma.StateSumAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.StateMinAggregateOutputType`
 */
export type StateMinAggregateOutputType = Prisma.StateMinAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.StateMaxAggregateOutputType`
 */
export type StateMaxAggregateOutputType = Prisma.StateMaxAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.StateCountAggregateOutputType`
 */
export type StateCountAggregateOutputType = Prisma.StateCountAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.AggregateStateArgs`
 */
export type AggregateStateArgs = Prisma.AggregateStateArgs

/**
 * @deprecated Renamed to `Prisma.StateAvgAggregateInputType`
 */
export type StateAvgAggregateInputType = Prisma.StateAvgAggregateInputType

/**
 * @deprecated Renamed to `Prisma.StateSumAggregateInputType`
 */
export type StateSumAggregateInputType = Prisma.StateSumAggregateInputType

/**
 * @deprecated Renamed to `Prisma.StateMinAggregateInputType`
 */
export type StateMinAggregateInputType = Prisma.StateMinAggregateInputType

/**
 * @deprecated Renamed to `Prisma.StateMaxAggregateInputType`
 */
export type StateMaxAggregateInputType = Prisma.StateMaxAggregateInputType

/**
 * @deprecated Renamed to `Prisma.StateCountAggregateInputType`
 */
export type StateCountAggregateInputType = Prisma.StateCountAggregateInputType

/**
 * @deprecated Renamed to `Prisma.stateSelect`
 */
export type stateSelect = Prisma.stateSelect

/**
 * @deprecated Renamed to `Prisma.stateInclude`
 */
export type stateInclude = Prisma.stateInclude

/**
 * @deprecated Renamed to `Prisma.FindUniquestateArgs`
 */
export type FindUniquestateArgs = Prisma.FindUniquestateArgs

/**
 * @deprecated Renamed to `Prisma.FindFirststateArgs`
 */
export type FindFirststateArgs = Prisma.FindFirststateArgs

/**
 * @deprecated Renamed to `Prisma.FindManystateArgs`
 */
export type FindManystateArgs = Prisma.FindManystateArgs

/**
 * @deprecated Renamed to `Prisma.stateCreateArgs`
 */
export type stateCreateArgs = Prisma.stateCreateArgs

/**
 * @deprecated Renamed to `Prisma.stateUpdateArgs`
 */
export type stateUpdateArgs = Prisma.stateUpdateArgs

/**
 * @deprecated Renamed to `Prisma.stateUpdateManyArgs`
 */
export type stateUpdateManyArgs = Prisma.stateUpdateManyArgs

/**
 * @deprecated Renamed to `Prisma.stateUpsertArgs`
 */
export type stateUpsertArgs = Prisma.stateUpsertArgs

/**
 * @deprecated Renamed to `Prisma.stateDeleteArgs`
 */
export type stateDeleteArgs = Prisma.stateDeleteArgs

/**
 * @deprecated Renamed to `Prisma.stateDeleteManyArgs`
 */
export type stateDeleteManyArgs = Prisma.stateDeleteManyArgs

/**
 * @deprecated Renamed to `Prisma.AggregateTerms_and_conditions`
 */
export type AggregateTerms_and_conditions = Prisma.AggregateTerms_and_conditions

/**
 * @deprecated Renamed to `Prisma.Terms_and_conditionsAvgAggregateOutputType`
 */
export type Terms_and_conditionsAvgAggregateOutputType = Prisma.Terms_and_conditionsAvgAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.Terms_and_conditionsSumAggregateOutputType`
 */
export type Terms_and_conditionsSumAggregateOutputType = Prisma.Terms_and_conditionsSumAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.Terms_and_conditionsMinAggregateOutputType`
 */
export type Terms_and_conditionsMinAggregateOutputType = Prisma.Terms_and_conditionsMinAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.Terms_and_conditionsMaxAggregateOutputType`
 */
export type Terms_and_conditionsMaxAggregateOutputType = Prisma.Terms_and_conditionsMaxAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.Terms_and_conditionsCountAggregateOutputType`
 */
export type Terms_and_conditionsCountAggregateOutputType = Prisma.Terms_and_conditionsCountAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.AggregateTerms_and_conditionsArgs`
 */
export type AggregateTerms_and_conditionsArgs = Prisma.AggregateTerms_and_conditionsArgs

/**
 * @deprecated Renamed to `Prisma.Terms_and_conditionsAvgAggregateInputType`
 */
export type Terms_and_conditionsAvgAggregateInputType = Prisma.Terms_and_conditionsAvgAggregateInputType

/**
 * @deprecated Renamed to `Prisma.Terms_and_conditionsSumAggregateInputType`
 */
export type Terms_and_conditionsSumAggregateInputType = Prisma.Terms_and_conditionsSumAggregateInputType

/**
 * @deprecated Renamed to `Prisma.Terms_and_conditionsMinAggregateInputType`
 */
export type Terms_and_conditionsMinAggregateInputType = Prisma.Terms_and_conditionsMinAggregateInputType

/**
 * @deprecated Renamed to `Prisma.Terms_and_conditionsMaxAggregateInputType`
 */
export type Terms_and_conditionsMaxAggregateInputType = Prisma.Terms_and_conditionsMaxAggregateInputType

/**
 * @deprecated Renamed to `Prisma.Terms_and_conditionsCountAggregateInputType`
 */
export type Terms_and_conditionsCountAggregateInputType = Prisma.Terms_and_conditionsCountAggregateInputType

/**
 * @deprecated Renamed to `Prisma.terms_and_conditionsSelect`
 */
export type terms_and_conditionsSelect = Prisma.terms_and_conditionsSelect

/**
 * @deprecated Renamed to `Prisma.terms_and_conditionsInclude`
 */
export type terms_and_conditionsInclude = Prisma.terms_and_conditionsInclude

/**
 * @deprecated Renamed to `Prisma.FindUniqueterms_and_conditionsArgs`
 */
export type FindUniqueterms_and_conditionsArgs = Prisma.FindUniqueterms_and_conditionsArgs

/**
 * @deprecated Renamed to `Prisma.FindFirstterms_and_conditionsArgs`
 */
export type FindFirstterms_and_conditionsArgs = Prisma.FindFirstterms_and_conditionsArgs

/**
 * @deprecated Renamed to `Prisma.FindManyterms_and_conditionsArgs`
 */
export type FindManyterms_and_conditionsArgs = Prisma.FindManyterms_and_conditionsArgs

/**
 * @deprecated Renamed to `Prisma.terms_and_conditionsCreateArgs`
 */
export type terms_and_conditionsCreateArgs = Prisma.terms_and_conditionsCreateArgs

/**
 * @deprecated Renamed to `Prisma.terms_and_conditionsUpdateArgs`
 */
export type terms_and_conditionsUpdateArgs = Prisma.terms_and_conditionsUpdateArgs

/**
 * @deprecated Renamed to `Prisma.terms_and_conditionsUpdateManyArgs`
 */
export type terms_and_conditionsUpdateManyArgs = Prisma.terms_and_conditionsUpdateManyArgs

/**
 * @deprecated Renamed to `Prisma.terms_and_conditionsUpsertArgs`
 */
export type terms_and_conditionsUpsertArgs = Prisma.terms_and_conditionsUpsertArgs

/**
 * @deprecated Renamed to `Prisma.terms_and_conditionsDeleteArgs`
 */
export type terms_and_conditionsDeleteArgs = Prisma.terms_and_conditionsDeleteArgs

/**
 * @deprecated Renamed to `Prisma.terms_and_conditionsDeleteManyArgs`
 */
export type terms_and_conditionsDeleteManyArgs = Prisma.terms_and_conditionsDeleteManyArgs

/**
 * @deprecated Renamed to `Prisma.AggregateUser`
 */
export type AggregateUser = Prisma.AggregateUser

/**
 * @deprecated Renamed to `Prisma.UserAvgAggregateOutputType`
 */
export type UserAvgAggregateOutputType = Prisma.UserAvgAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.UserSumAggregateOutputType`
 */
export type UserSumAggregateOutputType = Prisma.UserSumAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.UserMinAggregateOutputType`
 */
export type UserMinAggregateOutputType = Prisma.UserMinAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.UserMaxAggregateOutputType`
 */
export type UserMaxAggregateOutputType = Prisma.UserMaxAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.UserCountAggregateOutputType`
 */
export type UserCountAggregateOutputType = Prisma.UserCountAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.AggregateUserArgs`
 */
export type AggregateUserArgs = Prisma.AggregateUserArgs

/**
 * @deprecated Renamed to `Prisma.UserAvgAggregateInputType`
 */
export type UserAvgAggregateInputType = Prisma.UserAvgAggregateInputType

/**
 * @deprecated Renamed to `Prisma.UserSumAggregateInputType`
 */
export type UserSumAggregateInputType = Prisma.UserSumAggregateInputType

/**
 * @deprecated Renamed to `Prisma.UserMinAggregateInputType`
 */
export type UserMinAggregateInputType = Prisma.UserMinAggregateInputType

/**
 * @deprecated Renamed to `Prisma.UserMaxAggregateInputType`
 */
export type UserMaxAggregateInputType = Prisma.UserMaxAggregateInputType

/**
 * @deprecated Renamed to `Prisma.UserCountAggregateInputType`
 */
export type UserCountAggregateInputType = Prisma.UserCountAggregateInputType

/**
 * @deprecated Renamed to `Prisma.userSelect`
 */
export type userSelect = Prisma.userSelect

/**
 * @deprecated Renamed to `Prisma.userInclude`
 */
export type userInclude = Prisma.userInclude

/**
 * @deprecated Renamed to `Prisma.FindUniqueuserArgs`
 */
export type FindUniqueuserArgs = Prisma.FindUniqueuserArgs

/**
 * @deprecated Renamed to `Prisma.FindFirstuserArgs`
 */
export type FindFirstuserArgs = Prisma.FindFirstuserArgs

/**
 * @deprecated Renamed to `Prisma.FindManyuserArgs`
 */
export type FindManyuserArgs = Prisma.FindManyuserArgs

/**
 * @deprecated Renamed to `Prisma.userCreateArgs`
 */
export type userCreateArgs = Prisma.userCreateArgs

/**
 * @deprecated Renamed to `Prisma.userUpdateArgs`
 */
export type userUpdateArgs = Prisma.userUpdateArgs

/**
 * @deprecated Renamed to `Prisma.userUpdateManyArgs`
 */
export type userUpdateManyArgs = Prisma.userUpdateManyArgs

/**
 * @deprecated Renamed to `Prisma.userUpsertArgs`
 */
export type userUpsertArgs = Prisma.userUpsertArgs

/**
 * @deprecated Renamed to `Prisma.userDeleteArgs`
 */
export type userDeleteArgs = Prisma.userDeleteArgs

/**
 * @deprecated Renamed to `Prisma.userDeleteManyArgs`
 */
export type userDeleteManyArgs = Prisma.userDeleteManyArgs

/**
 * @deprecated Renamed to `Prisma.AggregateUser_accepted_privacy_policy`
 */
export type AggregateUser_accepted_privacy_policy = Prisma.AggregateUser_accepted_privacy_policy

/**
 * @deprecated Renamed to `Prisma.User_accepted_privacy_policyAvgAggregateOutputType`
 */
export type User_accepted_privacy_policyAvgAggregateOutputType = Prisma.User_accepted_privacy_policyAvgAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.User_accepted_privacy_policySumAggregateOutputType`
 */
export type User_accepted_privacy_policySumAggregateOutputType = Prisma.User_accepted_privacy_policySumAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.User_accepted_privacy_policyMinAggregateOutputType`
 */
export type User_accepted_privacy_policyMinAggregateOutputType = Prisma.User_accepted_privacy_policyMinAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.User_accepted_privacy_policyMaxAggregateOutputType`
 */
export type User_accepted_privacy_policyMaxAggregateOutputType = Prisma.User_accepted_privacy_policyMaxAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.User_accepted_privacy_policyCountAggregateOutputType`
 */
export type User_accepted_privacy_policyCountAggregateOutputType = Prisma.User_accepted_privacy_policyCountAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.AggregateUser_accepted_privacy_policyArgs`
 */
export type AggregateUser_accepted_privacy_policyArgs = Prisma.AggregateUser_accepted_privacy_policyArgs

/**
 * @deprecated Renamed to `Prisma.User_accepted_privacy_policyAvgAggregateInputType`
 */
export type User_accepted_privacy_policyAvgAggregateInputType = Prisma.User_accepted_privacy_policyAvgAggregateInputType

/**
 * @deprecated Renamed to `Prisma.User_accepted_privacy_policySumAggregateInputType`
 */
export type User_accepted_privacy_policySumAggregateInputType = Prisma.User_accepted_privacy_policySumAggregateInputType

/**
 * @deprecated Renamed to `Prisma.User_accepted_privacy_policyMinAggregateInputType`
 */
export type User_accepted_privacy_policyMinAggregateInputType = Prisma.User_accepted_privacy_policyMinAggregateInputType

/**
 * @deprecated Renamed to `Prisma.User_accepted_privacy_policyMaxAggregateInputType`
 */
export type User_accepted_privacy_policyMaxAggregateInputType = Prisma.User_accepted_privacy_policyMaxAggregateInputType

/**
 * @deprecated Renamed to `Prisma.User_accepted_privacy_policyCountAggregateInputType`
 */
export type User_accepted_privacy_policyCountAggregateInputType = Prisma.User_accepted_privacy_policyCountAggregateInputType

/**
 * @deprecated Renamed to `Prisma.user_accepted_privacy_policySelect`
 */
export type user_accepted_privacy_policySelect = Prisma.user_accepted_privacy_policySelect

/**
 * @deprecated Renamed to `Prisma.user_accepted_privacy_policyInclude`
 */
export type user_accepted_privacy_policyInclude = Prisma.user_accepted_privacy_policyInclude

/**
 * @deprecated Renamed to `Prisma.FindUniqueuser_accepted_privacy_policyArgs`
 */
export type FindUniqueuser_accepted_privacy_policyArgs = Prisma.FindUniqueuser_accepted_privacy_policyArgs

/**
 * @deprecated Renamed to `Prisma.FindFirstuser_accepted_privacy_policyArgs`
 */
export type FindFirstuser_accepted_privacy_policyArgs = Prisma.FindFirstuser_accepted_privacy_policyArgs

/**
 * @deprecated Renamed to `Prisma.FindManyuser_accepted_privacy_policyArgs`
 */
export type FindManyuser_accepted_privacy_policyArgs = Prisma.FindManyuser_accepted_privacy_policyArgs

/**
 * @deprecated Renamed to `Prisma.user_accepted_privacy_policyCreateArgs`
 */
export type user_accepted_privacy_policyCreateArgs = Prisma.user_accepted_privacy_policyCreateArgs

/**
 * @deprecated Renamed to `Prisma.user_accepted_privacy_policyUpdateArgs`
 */
export type user_accepted_privacy_policyUpdateArgs = Prisma.user_accepted_privacy_policyUpdateArgs

/**
 * @deprecated Renamed to `Prisma.user_accepted_privacy_policyUpdateManyArgs`
 */
export type user_accepted_privacy_policyUpdateManyArgs = Prisma.user_accepted_privacy_policyUpdateManyArgs

/**
 * @deprecated Renamed to `Prisma.user_accepted_privacy_policyUpsertArgs`
 */
export type user_accepted_privacy_policyUpsertArgs = Prisma.user_accepted_privacy_policyUpsertArgs

/**
 * @deprecated Renamed to `Prisma.user_accepted_privacy_policyDeleteArgs`
 */
export type user_accepted_privacy_policyDeleteArgs = Prisma.user_accepted_privacy_policyDeleteArgs

/**
 * @deprecated Renamed to `Prisma.user_accepted_privacy_policyDeleteManyArgs`
 */
export type user_accepted_privacy_policyDeleteManyArgs = Prisma.user_accepted_privacy_policyDeleteManyArgs

/**
 * @deprecated Renamed to `Prisma.AggregateUser_accepted_terms`
 */
export type AggregateUser_accepted_terms = Prisma.AggregateUser_accepted_terms

/**
 * @deprecated Renamed to `Prisma.User_accepted_termsAvgAggregateOutputType`
 */
export type User_accepted_termsAvgAggregateOutputType = Prisma.User_accepted_termsAvgAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.User_accepted_termsSumAggregateOutputType`
 */
export type User_accepted_termsSumAggregateOutputType = Prisma.User_accepted_termsSumAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.User_accepted_termsMinAggregateOutputType`
 */
export type User_accepted_termsMinAggregateOutputType = Prisma.User_accepted_termsMinAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.User_accepted_termsMaxAggregateOutputType`
 */
export type User_accepted_termsMaxAggregateOutputType = Prisma.User_accepted_termsMaxAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.User_accepted_termsCountAggregateOutputType`
 */
export type User_accepted_termsCountAggregateOutputType = Prisma.User_accepted_termsCountAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.AggregateUser_accepted_termsArgs`
 */
export type AggregateUser_accepted_termsArgs = Prisma.AggregateUser_accepted_termsArgs

/**
 * @deprecated Renamed to `Prisma.User_accepted_termsAvgAggregateInputType`
 */
export type User_accepted_termsAvgAggregateInputType = Prisma.User_accepted_termsAvgAggregateInputType

/**
 * @deprecated Renamed to `Prisma.User_accepted_termsSumAggregateInputType`
 */
export type User_accepted_termsSumAggregateInputType = Prisma.User_accepted_termsSumAggregateInputType

/**
 * @deprecated Renamed to `Prisma.User_accepted_termsMinAggregateInputType`
 */
export type User_accepted_termsMinAggregateInputType = Prisma.User_accepted_termsMinAggregateInputType

/**
 * @deprecated Renamed to `Prisma.User_accepted_termsMaxAggregateInputType`
 */
export type User_accepted_termsMaxAggregateInputType = Prisma.User_accepted_termsMaxAggregateInputType

/**
 * @deprecated Renamed to `Prisma.User_accepted_termsCountAggregateInputType`
 */
export type User_accepted_termsCountAggregateInputType = Prisma.User_accepted_termsCountAggregateInputType

/**
 * @deprecated Renamed to `Prisma.user_accepted_termsSelect`
 */
export type user_accepted_termsSelect = Prisma.user_accepted_termsSelect

/**
 * @deprecated Renamed to `Prisma.user_accepted_termsInclude`
 */
export type user_accepted_termsInclude = Prisma.user_accepted_termsInclude

/**
 * @deprecated Renamed to `Prisma.FindUniqueuser_accepted_termsArgs`
 */
export type FindUniqueuser_accepted_termsArgs = Prisma.FindUniqueuser_accepted_termsArgs

/**
 * @deprecated Renamed to `Prisma.FindFirstuser_accepted_termsArgs`
 */
export type FindFirstuser_accepted_termsArgs = Prisma.FindFirstuser_accepted_termsArgs

/**
 * @deprecated Renamed to `Prisma.FindManyuser_accepted_termsArgs`
 */
export type FindManyuser_accepted_termsArgs = Prisma.FindManyuser_accepted_termsArgs

/**
 * @deprecated Renamed to `Prisma.user_accepted_termsCreateArgs`
 */
export type user_accepted_termsCreateArgs = Prisma.user_accepted_termsCreateArgs

/**
 * @deprecated Renamed to `Prisma.user_accepted_termsUpdateArgs`
 */
export type user_accepted_termsUpdateArgs = Prisma.user_accepted_termsUpdateArgs

/**
 * @deprecated Renamed to `Prisma.user_accepted_termsUpdateManyArgs`
 */
export type user_accepted_termsUpdateManyArgs = Prisma.user_accepted_termsUpdateManyArgs

/**
 * @deprecated Renamed to `Prisma.user_accepted_termsUpsertArgs`
 */
export type user_accepted_termsUpsertArgs = Prisma.user_accepted_termsUpsertArgs

/**
 * @deprecated Renamed to `Prisma.user_accepted_termsDeleteArgs`
 */
export type user_accepted_termsDeleteArgs = Prisma.user_accepted_termsDeleteArgs

/**
 * @deprecated Renamed to `Prisma.user_accepted_termsDeleteManyArgs`
 */
export type user_accepted_termsDeleteManyArgs = Prisma.user_accepted_termsDeleteManyArgs

/**
 * @deprecated Renamed to `Prisma.AggregateUser_role`
 */
export type AggregateUser_role = Prisma.AggregateUser_role

/**
 * @deprecated Renamed to `Prisma.User_roleAvgAggregateOutputType`
 */
export type User_roleAvgAggregateOutputType = Prisma.User_roleAvgAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.User_roleSumAggregateOutputType`
 */
export type User_roleSumAggregateOutputType = Prisma.User_roleSumAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.User_roleMinAggregateOutputType`
 */
export type User_roleMinAggregateOutputType = Prisma.User_roleMinAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.User_roleMaxAggregateOutputType`
 */
export type User_roleMaxAggregateOutputType = Prisma.User_roleMaxAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.User_roleCountAggregateOutputType`
 */
export type User_roleCountAggregateOutputType = Prisma.User_roleCountAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.AggregateUser_roleArgs`
 */
export type AggregateUser_roleArgs = Prisma.AggregateUser_roleArgs

/**
 * @deprecated Renamed to `Prisma.User_roleAvgAggregateInputType`
 */
export type User_roleAvgAggregateInputType = Prisma.User_roleAvgAggregateInputType

/**
 * @deprecated Renamed to `Prisma.User_roleSumAggregateInputType`
 */
export type User_roleSumAggregateInputType = Prisma.User_roleSumAggregateInputType

/**
 * @deprecated Renamed to `Prisma.User_roleMinAggregateInputType`
 */
export type User_roleMinAggregateInputType = Prisma.User_roleMinAggregateInputType

/**
 * @deprecated Renamed to `Prisma.User_roleMaxAggregateInputType`
 */
export type User_roleMaxAggregateInputType = Prisma.User_roleMaxAggregateInputType

/**
 * @deprecated Renamed to `Prisma.User_roleCountAggregateInputType`
 */
export type User_roleCountAggregateInputType = Prisma.User_roleCountAggregateInputType

/**
 * @deprecated Renamed to `Prisma.user_roleSelect`
 */
export type user_roleSelect = Prisma.user_roleSelect

/**
 * @deprecated Renamed to `Prisma.user_roleInclude`
 */
export type user_roleInclude = Prisma.user_roleInclude

/**
 * @deprecated Renamed to `Prisma.FindUniqueuser_roleArgs`
 */
export type FindUniqueuser_roleArgs = Prisma.FindUniqueuser_roleArgs

/**
 * @deprecated Renamed to `Prisma.FindFirstuser_roleArgs`
 */
export type FindFirstuser_roleArgs = Prisma.FindFirstuser_roleArgs

/**
 * @deprecated Renamed to `Prisma.FindManyuser_roleArgs`
 */
export type FindManyuser_roleArgs = Prisma.FindManyuser_roleArgs

/**
 * @deprecated Renamed to `Prisma.user_roleCreateArgs`
 */
export type user_roleCreateArgs = Prisma.user_roleCreateArgs

/**
 * @deprecated Renamed to `Prisma.user_roleUpdateArgs`
 */
export type user_roleUpdateArgs = Prisma.user_roleUpdateArgs

/**
 * @deprecated Renamed to `Prisma.user_roleUpdateManyArgs`
 */
export type user_roleUpdateManyArgs = Prisma.user_roleUpdateManyArgs

/**
 * @deprecated Renamed to `Prisma.user_roleUpsertArgs`
 */
export type user_roleUpsertArgs = Prisma.user_roleUpsertArgs

/**
 * @deprecated Renamed to `Prisma.user_roleDeleteArgs`
 */
export type user_roleDeleteArgs = Prisma.user_roleDeleteArgs

/**
 * @deprecated Renamed to `Prisma.user_roleDeleteManyArgs`
 */
export type user_roleDeleteManyArgs = Prisma.user_roleDeleteManyArgs

/**
 * @deprecated Renamed to `Prisma.addressWhereInput`
 */
export type addressWhereInput = Prisma.addressWhereInput

/**
 * @deprecated Renamed to `Prisma.addressOrderByInput`
 */
export type addressOrderByInput = Prisma.addressOrderByInput

/**
 * @deprecated Renamed to `Prisma.addressWhereUniqueInput`
 */
export type addressWhereUniqueInput = Prisma.addressWhereUniqueInput

/**
 * @deprecated Renamed to `Prisma.areaWhereInput`
 */
export type areaWhereInput = Prisma.areaWhereInput

/**
 * @deprecated Renamed to `Prisma.areaOrderByInput`
 */
export type areaOrderByInput = Prisma.areaOrderByInput

/**
 * @deprecated Renamed to `Prisma.areaWhereUniqueInput`
 */
export type areaWhereUniqueInput = Prisma.areaWhereUniqueInput

/**
 * @deprecated Renamed to `Prisma.companyWhereInput`
 */
export type companyWhereInput = Prisma.companyWhereInput

/**
 * @deprecated Renamed to `Prisma.companyOrderByInput`
 */
export type companyOrderByInput = Prisma.companyOrderByInput

/**
 * @deprecated Renamed to `Prisma.companyWhereUniqueInput`
 */
export type companyWhereUniqueInput = Prisma.companyWhereUniqueInput

/**
 * @deprecated Renamed to `Prisma.cropWhereInput`
 */
export type cropWhereInput = Prisma.cropWhereInput

/**
 * @deprecated Renamed to `Prisma.cropOrderByInput`
 */
export type cropOrderByInput = Prisma.cropOrderByInput

/**
 * @deprecated Renamed to `Prisma.cropWhereUniqueInput`
 */
export type cropWhereUniqueInput = Prisma.cropWhereUniqueInput

/**
 * @deprecated Renamed to `Prisma.diagnosisWhereInput`
 */
export type diagnosisWhereInput = Prisma.diagnosisWhereInput

/**
 * @deprecated Renamed to `Prisma.diagnosisOrderByInput`
 */
export type diagnosisOrderByInput = Prisma.diagnosisOrderByInput

/**
 * @deprecated Renamed to `Prisma.diagnosisWhereUniqueInput`
 */
export type diagnosisWhereUniqueInput = Prisma.diagnosisWhereUniqueInput

/**
 * @deprecated Renamed to `Prisma.emailWhereInput`
 */
export type emailWhereInput = Prisma.emailWhereInput

/**
 * @deprecated Renamed to `Prisma.emailOrderByInput`
 */
export type emailOrderByInput = Prisma.emailOrderByInput

/**
 * @deprecated Renamed to `Prisma.emailWhereUniqueInput`
 */
export type emailWhereUniqueInput = Prisma.emailWhereUniqueInput

/**
 * @deprecated Renamed to `Prisma.farmWhereInput`
 */
export type farmWhereInput = Prisma.farmWhereInput

/**
 * @deprecated Renamed to `Prisma.farmOrderByInput`
 */
export type farmOrderByInput = Prisma.farmOrderByInput

/**
 * @deprecated Renamed to `Prisma.farmWhereUniqueInput`
 */
export type farmWhereUniqueInput = Prisma.farmWhereUniqueInput

/**
 * @deprecated Renamed to `Prisma.fieldWhereInput`
 */
export type fieldWhereInput = Prisma.fieldWhereInput

/**
 * @deprecated Renamed to `Prisma.fieldOrderByInput`
 */
export type fieldOrderByInput = Prisma.fieldOrderByInput

/**
 * @deprecated Renamed to `Prisma.fieldWhereUniqueInput`
 */
export type fieldWhereUniqueInput = Prisma.fieldWhereUniqueInput

/**
 * @deprecated Renamed to `Prisma.imagingWhereInput`
 */
export type imagingWhereInput = Prisma.imagingWhereInput

/**
 * @deprecated Renamed to `Prisma.imagingOrderByInput`
 */
export type imagingOrderByInput = Prisma.imagingOrderByInput

/**
 * @deprecated Renamed to `Prisma.imagingWhereUniqueInput`
 */
export type imagingWhereUniqueInput = Prisma.imagingWhereUniqueInput

/**
 * @deprecated Renamed to `Prisma.infestationWhereInput`
 */
export type infestationWhereInput = Prisma.infestationWhereInput

/**
 * @deprecated Renamed to `Prisma.infestationOrderByInput`
 */
export type infestationOrderByInput = Prisma.infestationOrderByInput

/**
 * @deprecated Renamed to `Prisma.infestationWhereUniqueInput`
 */
export type infestationWhereUniqueInput = Prisma.infestationWhereUniqueInput

/**
 * @deprecated Renamed to `Prisma.many_quotation_modal_package_has_many_fieldWhereInput`
 */
export type many_quotation_modal_package_has_many_fieldWhereInput = Prisma.many_quotation_modal_package_has_many_fieldWhereInput

/**
 * @deprecated Renamed to `Prisma.many_quotation_modal_package_has_many_fieldOrderByInput`
 */
export type many_quotation_modal_package_has_many_fieldOrderByInput = Prisma.many_quotation_modal_package_has_many_fieldOrderByInput

/**
 * @deprecated Renamed to `Prisma.many_quotation_modal_package_has_many_fieldWhereUniqueInput`
 */
export type many_quotation_modal_package_has_many_fieldWhereUniqueInput = Prisma.many_quotation_modal_package_has_many_fieldWhereUniqueInput

/**
 * @deprecated Renamed to `Prisma.many_user_has_many_farmWhereInput`
 */
export type many_user_has_many_farmWhereInput = Prisma.many_user_has_many_farmWhereInput

/**
 * @deprecated Renamed to `Prisma.many_user_has_many_farmOrderByInput`
 */
export type many_user_has_many_farmOrderByInput = Prisma.many_user_has_many_farmOrderByInput

/**
 * @deprecated Renamed to `Prisma.many_user_has_many_farmWhereUniqueInput`
 */
export type many_user_has_many_farmWhereUniqueInput = Prisma.many_user_has_many_farmWhereUniqueInput

/**
 * @deprecated Renamed to `Prisma.notificationWhereInput`
 */
export type notificationWhereInput = Prisma.notificationWhereInput

/**
 * @deprecated Renamed to `Prisma.notificationOrderByInput`
 */
export type notificationOrderByInput = Prisma.notificationOrderByInput

/**
 * @deprecated Renamed to `Prisma.notificationWhereUniqueInput`
 */
export type notificationWhereUniqueInput = Prisma.notificationWhereUniqueInput

/**
 * @deprecated Renamed to `Prisma.plagueWhereInput`
 */
export type plagueWhereInput = Prisma.plagueWhereInput

/**
 * @deprecated Renamed to `Prisma.plagueOrderByInput`
 */
export type plagueOrderByInput = Prisma.plagueOrderByInput

/**
 * @deprecated Renamed to `Prisma.plagueWhereUniqueInput`
 */
export type plagueWhereUniqueInput = Prisma.plagueWhereUniqueInput

/**
 * @deprecated Renamed to `Prisma.prescriptionWhereInput`
 */
export type prescriptionWhereInput = Prisma.prescriptionWhereInput

/**
 * @deprecated Renamed to `Prisma.prescriptionOrderByInput`
 */
export type prescriptionOrderByInput = Prisma.prescriptionOrderByInput

/**
 * @deprecated Renamed to `Prisma.prescriptionWhereUniqueInput`
 */
export type prescriptionWhereUniqueInput = Prisma.prescriptionWhereUniqueInput

/**
 * @deprecated Renamed to `Prisma.privacy_policyWhereInput`
 */
export type privacy_policyWhereInput = Prisma.privacy_policyWhereInput

/**
 * @deprecated Renamed to `Prisma.privacy_policyOrderByInput`
 */
export type privacy_policyOrderByInput = Prisma.privacy_policyOrderByInput

/**
 * @deprecated Renamed to `Prisma.privacy_policyWhereUniqueInput`
 */
export type privacy_policyWhereUniqueInput = Prisma.privacy_policyWhereUniqueInput

/**
 * @deprecated Renamed to `Prisma.quotationWhereInput`
 */
export type quotationWhereInput = Prisma.quotationWhereInput

/**
 * @deprecated Renamed to `Prisma.quotationOrderByInput`
 */
export type quotationOrderByInput = Prisma.quotationOrderByInput

/**
 * @deprecated Renamed to `Prisma.quotationWhereUniqueInput`
 */
export type quotationWhereUniqueInput = Prisma.quotationWhereUniqueInput

/**
 * @deprecated Renamed to `Prisma.quotation_checkoutWhereInput`
 */
export type quotation_checkoutWhereInput = Prisma.quotation_checkoutWhereInput

/**
 * @deprecated Renamed to `Prisma.quotation_checkoutOrderByInput`
 */
export type quotation_checkoutOrderByInput = Prisma.quotation_checkoutOrderByInput

/**
 * @deprecated Renamed to `Prisma.quotation_checkoutWhereUniqueInput`
 */
export type quotation_checkoutWhereUniqueInput = Prisma.quotation_checkoutWhereUniqueInput

/**
 * @deprecated Renamed to `Prisma.quotation_modal_packageWhereInput`
 */
export type quotation_modal_packageWhereInput = Prisma.quotation_modal_packageWhereInput

/**
 * @deprecated Renamed to `Prisma.quotation_modal_packageOrderByInput`
 */
export type quotation_modal_packageOrderByInput = Prisma.quotation_modal_packageOrderByInput

/**
 * @deprecated Renamed to `Prisma.quotation_modal_packageWhereUniqueInput`
 */
export type quotation_modal_packageWhereUniqueInput = Prisma.quotation_modal_packageWhereUniqueInput

/**
 * @deprecated Renamed to `Prisma.quotation_packageWhereInput`
 */
export type quotation_packageWhereInput = Prisma.quotation_packageWhereInput

/**
 * @deprecated Renamed to `Prisma.quotation_packageOrderByInput`
 */
export type quotation_packageOrderByInput = Prisma.quotation_packageOrderByInput

/**
 * @deprecated Renamed to `Prisma.quotation_packageWhereUniqueInput`
 */
export type quotation_packageWhereUniqueInput = Prisma.quotation_packageWhereUniqueInput

/**
 * @deprecated Renamed to `Prisma.roleWhereInput`
 */
export type roleWhereInput = Prisma.roleWhereInput

/**
 * @deprecated Renamed to `Prisma.roleOrderByInput`
 */
export type roleOrderByInput = Prisma.roleOrderByInput

/**
 * @deprecated Renamed to `Prisma.roleWhereUniqueInput`
 */
export type roleWhereUniqueInput = Prisma.roleWhereUniqueInput

/**
 * @deprecated Renamed to `Prisma.seed_revisionWhereInput`
 */
export type seed_revisionWhereInput = Prisma.seed_revisionWhereInput

/**
 * @deprecated Renamed to `Prisma.seed_revisionOrderByInput`
 */
export type seed_revisionOrderByInput = Prisma.seed_revisionOrderByInput

/**
 * @deprecated Renamed to `Prisma.seed_revisionWhereUniqueInput`
 */
export type seed_revisionWhereUniqueInput = Prisma.seed_revisionWhereUniqueInput

/**
 * @deprecated Renamed to `Prisma.stateWhereInput`
 */
export type stateWhereInput = Prisma.stateWhereInput

/**
 * @deprecated Renamed to `Prisma.stateOrderByInput`
 */
export type stateOrderByInput = Prisma.stateOrderByInput

/**
 * @deprecated Renamed to `Prisma.stateWhereUniqueInput`
 */
export type stateWhereUniqueInput = Prisma.stateWhereUniqueInput

/**
 * @deprecated Renamed to `Prisma.terms_and_conditionsWhereInput`
 */
export type terms_and_conditionsWhereInput = Prisma.terms_and_conditionsWhereInput

/**
 * @deprecated Renamed to `Prisma.terms_and_conditionsOrderByInput`
 */
export type terms_and_conditionsOrderByInput = Prisma.terms_and_conditionsOrderByInput

/**
 * @deprecated Renamed to `Prisma.terms_and_conditionsWhereUniqueInput`
 */
export type terms_and_conditionsWhereUniqueInput = Prisma.terms_and_conditionsWhereUniqueInput

/**
 * @deprecated Renamed to `Prisma.userWhereInput`
 */
export type userWhereInput = Prisma.userWhereInput

/**
 * @deprecated Renamed to `Prisma.userOrderByInput`
 */
export type userOrderByInput = Prisma.userOrderByInput

/**
 * @deprecated Renamed to `Prisma.userWhereUniqueInput`
 */
export type userWhereUniqueInput = Prisma.userWhereUniqueInput

/**
 * @deprecated Renamed to `Prisma.user_accepted_privacy_policyWhereInput`
 */
export type user_accepted_privacy_policyWhereInput = Prisma.user_accepted_privacy_policyWhereInput

/**
 * @deprecated Renamed to `Prisma.user_accepted_privacy_policyOrderByInput`
 */
export type user_accepted_privacy_policyOrderByInput = Prisma.user_accepted_privacy_policyOrderByInput

/**
 * @deprecated Renamed to `Prisma.user_accepted_privacy_policyWhereUniqueInput`
 */
export type user_accepted_privacy_policyWhereUniqueInput = Prisma.user_accepted_privacy_policyWhereUniqueInput

/**
 * @deprecated Renamed to `Prisma.user_accepted_termsWhereInput`
 */
export type user_accepted_termsWhereInput = Prisma.user_accepted_termsWhereInput

/**
 * @deprecated Renamed to `Prisma.user_accepted_termsOrderByInput`
 */
export type user_accepted_termsOrderByInput = Prisma.user_accepted_termsOrderByInput

/**
 * @deprecated Renamed to `Prisma.user_accepted_termsWhereUniqueInput`
 */
export type user_accepted_termsWhereUniqueInput = Prisma.user_accepted_termsWhereUniqueInput

/**
 * @deprecated Renamed to `Prisma.user_roleWhereInput`
 */
export type user_roleWhereInput = Prisma.user_roleWhereInput

/**
 * @deprecated Renamed to `Prisma.user_roleOrderByInput`
 */
export type user_roleOrderByInput = Prisma.user_roleOrderByInput

/**
 * @deprecated Renamed to `Prisma.user_roleWhereUniqueInput`
 */
export type user_roleWhereUniqueInput = Prisma.user_roleWhereUniqueInput

/**
 * @deprecated Renamed to `Prisma.addressCreateInput`
 */
export type addressCreateInput = Prisma.addressCreateInput

/**
 * @deprecated Renamed to `Prisma.addressUpdateInput`
 */
export type addressUpdateInput = Prisma.addressUpdateInput

/**
 * @deprecated Renamed to `Prisma.addressUpdateManyMutationInput`
 */
export type addressUpdateManyMutationInput = Prisma.addressUpdateManyMutationInput

/**
 * @deprecated Renamed to `Prisma.areaCreateInput`
 */
export type areaCreateInput = Prisma.areaCreateInput

/**
 * @deprecated Renamed to `Prisma.areaUpdateInput`
 */
export type areaUpdateInput = Prisma.areaUpdateInput

/**
 * @deprecated Renamed to `Prisma.areaUpdateManyMutationInput`
 */
export type areaUpdateManyMutationInput = Prisma.areaUpdateManyMutationInput

/**
 * @deprecated Renamed to `Prisma.companyCreateInput`
 */
export type companyCreateInput = Prisma.companyCreateInput

/**
 * @deprecated Renamed to `Prisma.companyUpdateInput`
 */
export type companyUpdateInput = Prisma.companyUpdateInput

/**
 * @deprecated Renamed to `Prisma.companyUpdateManyMutationInput`
 */
export type companyUpdateManyMutationInput = Prisma.companyUpdateManyMutationInput

/**
 * @deprecated Renamed to `Prisma.cropCreateInput`
 */
export type cropCreateInput = Prisma.cropCreateInput

/**
 * @deprecated Renamed to `Prisma.cropUpdateInput`
 */
export type cropUpdateInput = Prisma.cropUpdateInput

/**
 * @deprecated Renamed to `Prisma.cropUpdateManyMutationInput`
 */
export type cropUpdateManyMutationInput = Prisma.cropUpdateManyMutationInput

/**
 * @deprecated Renamed to `Prisma.diagnosisCreateInput`
 */
export type diagnosisCreateInput = Prisma.diagnosisCreateInput

/**
 * @deprecated Renamed to `Prisma.diagnosisUpdateInput`
 */
export type diagnosisUpdateInput = Prisma.diagnosisUpdateInput

/**
 * @deprecated Renamed to `Prisma.diagnosisUpdateManyMutationInput`
 */
export type diagnosisUpdateManyMutationInput = Prisma.diagnosisUpdateManyMutationInput

/**
 * @deprecated Renamed to `Prisma.emailCreateInput`
 */
export type emailCreateInput = Prisma.emailCreateInput

/**
 * @deprecated Renamed to `Prisma.emailUpdateInput`
 */
export type emailUpdateInput = Prisma.emailUpdateInput

/**
 * @deprecated Renamed to `Prisma.emailUpdateManyMutationInput`
 */
export type emailUpdateManyMutationInput = Prisma.emailUpdateManyMutationInput

/**
 * @deprecated Renamed to `Prisma.farmCreateInput`
 */
export type farmCreateInput = Prisma.farmCreateInput

/**
 * @deprecated Renamed to `Prisma.farmUpdateInput`
 */
export type farmUpdateInput = Prisma.farmUpdateInput

/**
 * @deprecated Renamed to `Prisma.farmUpdateManyMutationInput`
 */
export type farmUpdateManyMutationInput = Prisma.farmUpdateManyMutationInput

/**
 * @deprecated Renamed to `Prisma.fieldCreateInput`
 */
export type fieldCreateInput = Prisma.fieldCreateInput

/**
 * @deprecated Renamed to `Prisma.fieldUpdateInput`
 */
export type fieldUpdateInput = Prisma.fieldUpdateInput

/**
 * @deprecated Renamed to `Prisma.fieldUpdateManyMutationInput`
 */
export type fieldUpdateManyMutationInput = Prisma.fieldUpdateManyMutationInput

/**
 * @deprecated Renamed to `Prisma.imagingCreateInput`
 */
export type imagingCreateInput = Prisma.imagingCreateInput

/**
 * @deprecated Renamed to `Prisma.imagingUpdateInput`
 */
export type imagingUpdateInput = Prisma.imagingUpdateInput

/**
 * @deprecated Renamed to `Prisma.imagingUpdateManyMutationInput`
 */
export type imagingUpdateManyMutationInput = Prisma.imagingUpdateManyMutationInput

/**
 * @deprecated Renamed to `Prisma.infestationCreateInput`
 */
export type infestationCreateInput = Prisma.infestationCreateInput

/**
 * @deprecated Renamed to `Prisma.infestationUpdateInput`
 */
export type infestationUpdateInput = Prisma.infestationUpdateInput

/**
 * @deprecated Renamed to `Prisma.infestationUpdateManyMutationInput`
 */
export type infestationUpdateManyMutationInput = Prisma.infestationUpdateManyMutationInput

/**
 * @deprecated Renamed to `Prisma.many_quotation_modal_package_has_many_fieldCreateInput`
 */
export type many_quotation_modal_package_has_many_fieldCreateInput = Prisma.many_quotation_modal_package_has_many_fieldCreateInput

/**
 * @deprecated Renamed to `Prisma.many_quotation_modal_package_has_many_fieldUpdateInput`
 */
export type many_quotation_modal_package_has_many_fieldUpdateInput = Prisma.many_quotation_modal_package_has_many_fieldUpdateInput

/**
 * @deprecated Renamed to `Prisma.many_quotation_modal_package_has_many_fieldUpdateManyMutationInput`
 */
export type many_quotation_modal_package_has_many_fieldUpdateManyMutationInput = Prisma.many_quotation_modal_package_has_many_fieldUpdateManyMutationInput

/**
 * @deprecated Renamed to `Prisma.many_user_has_many_farmCreateInput`
 */
export type many_user_has_many_farmCreateInput = Prisma.many_user_has_many_farmCreateInput

/**
 * @deprecated Renamed to `Prisma.many_user_has_many_farmUpdateInput`
 */
export type many_user_has_many_farmUpdateInput = Prisma.many_user_has_many_farmUpdateInput

/**
 * @deprecated Renamed to `Prisma.many_user_has_many_farmUpdateManyMutationInput`
 */
export type many_user_has_many_farmUpdateManyMutationInput = Prisma.many_user_has_many_farmUpdateManyMutationInput

/**
 * @deprecated Renamed to `Prisma.notificationCreateInput`
 */
export type notificationCreateInput = Prisma.notificationCreateInput

/**
 * @deprecated Renamed to `Prisma.notificationUpdateInput`
 */
export type notificationUpdateInput = Prisma.notificationUpdateInput

/**
 * @deprecated Renamed to `Prisma.notificationUpdateManyMutationInput`
 */
export type notificationUpdateManyMutationInput = Prisma.notificationUpdateManyMutationInput

/**
 * @deprecated Renamed to `Prisma.plagueCreateInput`
 */
export type plagueCreateInput = Prisma.plagueCreateInput

/**
 * @deprecated Renamed to `Prisma.plagueUpdateInput`
 */
export type plagueUpdateInput = Prisma.plagueUpdateInput

/**
 * @deprecated Renamed to `Prisma.plagueUpdateManyMutationInput`
 */
export type plagueUpdateManyMutationInput = Prisma.plagueUpdateManyMutationInput

/**
 * @deprecated Renamed to `Prisma.prescriptionCreateInput`
 */
export type prescriptionCreateInput = Prisma.prescriptionCreateInput

/**
 * @deprecated Renamed to `Prisma.prescriptionUpdateInput`
 */
export type prescriptionUpdateInput = Prisma.prescriptionUpdateInput

/**
 * @deprecated Renamed to `Prisma.prescriptionUpdateManyMutationInput`
 */
export type prescriptionUpdateManyMutationInput = Prisma.prescriptionUpdateManyMutationInput

/**
 * @deprecated Renamed to `Prisma.privacy_policyCreateInput`
 */
export type privacy_policyCreateInput = Prisma.privacy_policyCreateInput

/**
 * @deprecated Renamed to `Prisma.privacy_policyUpdateInput`
 */
export type privacy_policyUpdateInput = Prisma.privacy_policyUpdateInput

/**
 * @deprecated Renamed to `Prisma.privacy_policyUpdateManyMutationInput`
 */
export type privacy_policyUpdateManyMutationInput = Prisma.privacy_policyUpdateManyMutationInput

/**
 * @deprecated Renamed to `Prisma.quotationCreateInput`
 */
export type quotationCreateInput = Prisma.quotationCreateInput

/**
 * @deprecated Renamed to `Prisma.quotationUpdateInput`
 */
export type quotationUpdateInput = Prisma.quotationUpdateInput

/**
 * @deprecated Renamed to `Prisma.quotationUpdateManyMutationInput`
 */
export type quotationUpdateManyMutationInput = Prisma.quotationUpdateManyMutationInput

/**
 * @deprecated Renamed to `Prisma.quotation_checkoutCreateInput`
 */
export type quotation_checkoutCreateInput = Prisma.quotation_checkoutCreateInput

/**
 * @deprecated Renamed to `Prisma.quotation_checkoutUpdateInput`
 */
export type quotation_checkoutUpdateInput = Prisma.quotation_checkoutUpdateInput

/**
 * @deprecated Renamed to `Prisma.quotation_checkoutUpdateManyMutationInput`
 */
export type quotation_checkoutUpdateManyMutationInput = Prisma.quotation_checkoutUpdateManyMutationInput

/**
 * @deprecated Renamed to `Prisma.quotation_modal_packageCreateInput`
 */
export type quotation_modal_packageCreateInput = Prisma.quotation_modal_packageCreateInput

/**
 * @deprecated Renamed to `Prisma.quotation_modal_packageUpdateInput`
 */
export type quotation_modal_packageUpdateInput = Prisma.quotation_modal_packageUpdateInput

/**
 * @deprecated Renamed to `Prisma.quotation_modal_packageUpdateManyMutationInput`
 */
export type quotation_modal_packageUpdateManyMutationInput = Prisma.quotation_modal_packageUpdateManyMutationInput

/**
 * @deprecated Renamed to `Prisma.quotation_packageCreateInput`
 */
export type quotation_packageCreateInput = Prisma.quotation_packageCreateInput

/**
 * @deprecated Renamed to `Prisma.quotation_packageUpdateInput`
 */
export type quotation_packageUpdateInput = Prisma.quotation_packageUpdateInput

/**
 * @deprecated Renamed to `Prisma.quotation_packageUpdateManyMutationInput`
 */
export type quotation_packageUpdateManyMutationInput = Prisma.quotation_packageUpdateManyMutationInput

/**
 * @deprecated Renamed to `Prisma.roleCreateInput`
 */
export type roleCreateInput = Prisma.roleCreateInput

/**
 * @deprecated Renamed to `Prisma.roleUpdateInput`
 */
export type roleUpdateInput = Prisma.roleUpdateInput

/**
 * @deprecated Renamed to `Prisma.roleUpdateManyMutationInput`
 */
export type roleUpdateManyMutationInput = Prisma.roleUpdateManyMutationInput

/**
 * @deprecated Renamed to `Prisma.seed_revisionCreateInput`
 */
export type seed_revisionCreateInput = Prisma.seed_revisionCreateInput

/**
 * @deprecated Renamed to `Prisma.seed_revisionUpdateInput`
 */
export type seed_revisionUpdateInput = Prisma.seed_revisionUpdateInput

/**
 * @deprecated Renamed to `Prisma.seed_revisionUpdateManyMutationInput`
 */
export type seed_revisionUpdateManyMutationInput = Prisma.seed_revisionUpdateManyMutationInput

/**
 * @deprecated Renamed to `Prisma.stateCreateInput`
 */
export type stateCreateInput = Prisma.stateCreateInput

/**
 * @deprecated Renamed to `Prisma.stateUpdateInput`
 */
export type stateUpdateInput = Prisma.stateUpdateInput

/**
 * @deprecated Renamed to `Prisma.stateUpdateManyMutationInput`
 */
export type stateUpdateManyMutationInput = Prisma.stateUpdateManyMutationInput

/**
 * @deprecated Renamed to `Prisma.terms_and_conditionsCreateInput`
 */
export type terms_and_conditionsCreateInput = Prisma.terms_and_conditionsCreateInput

/**
 * @deprecated Renamed to `Prisma.terms_and_conditionsUpdateInput`
 */
export type terms_and_conditionsUpdateInput = Prisma.terms_and_conditionsUpdateInput

/**
 * @deprecated Renamed to `Prisma.terms_and_conditionsUpdateManyMutationInput`
 */
export type terms_and_conditionsUpdateManyMutationInput = Prisma.terms_and_conditionsUpdateManyMutationInput

/**
 * @deprecated Renamed to `Prisma.userCreateInput`
 */
export type userCreateInput = Prisma.userCreateInput

/**
 * @deprecated Renamed to `Prisma.userUpdateInput`
 */
export type userUpdateInput = Prisma.userUpdateInput

/**
 * @deprecated Renamed to `Prisma.userUpdateManyMutationInput`
 */
export type userUpdateManyMutationInput = Prisma.userUpdateManyMutationInput

/**
 * @deprecated Renamed to `Prisma.user_accepted_privacy_policyCreateInput`
 */
export type user_accepted_privacy_policyCreateInput = Prisma.user_accepted_privacy_policyCreateInput

/**
 * @deprecated Renamed to `Prisma.user_accepted_privacy_policyUpdateInput`
 */
export type user_accepted_privacy_policyUpdateInput = Prisma.user_accepted_privacy_policyUpdateInput

/**
 * @deprecated Renamed to `Prisma.user_accepted_privacy_policyUpdateManyMutationInput`
 */
export type user_accepted_privacy_policyUpdateManyMutationInput = Prisma.user_accepted_privacy_policyUpdateManyMutationInput

/**
 * @deprecated Renamed to `Prisma.user_accepted_termsCreateInput`
 */
export type user_accepted_termsCreateInput = Prisma.user_accepted_termsCreateInput

/**
 * @deprecated Renamed to `Prisma.user_accepted_termsUpdateInput`
 */
export type user_accepted_termsUpdateInput = Prisma.user_accepted_termsUpdateInput

/**
 * @deprecated Renamed to `Prisma.user_accepted_termsUpdateManyMutationInput`
 */
export type user_accepted_termsUpdateManyMutationInput = Prisma.user_accepted_termsUpdateManyMutationInput

/**
 * @deprecated Renamed to `Prisma.user_roleCreateInput`
 */
export type user_roleCreateInput = Prisma.user_roleCreateInput

/**
 * @deprecated Renamed to `Prisma.user_roleUpdateInput`
 */
export type user_roleUpdateInput = Prisma.user_roleUpdateInput

/**
 * @deprecated Renamed to `Prisma.user_roleUpdateManyMutationInput`
 */
export type user_roleUpdateManyMutationInput = Prisma.user_roleUpdateManyMutationInput

/**
 * @deprecated Renamed to `Prisma.IntFilter`
 */
export type IntFilter = Prisma.IntFilter

/**
 * @deprecated Renamed to `Prisma.StringFilter`
 */
export type StringFilter = Prisma.StringFilter

/**
 * @deprecated Renamed to `Prisma.IntNullableFilter`
 */
export type IntNullableFilter = Prisma.IntNullableFilter

/**
 * @deprecated Renamed to `Prisma.StringNullableFilter`
 */
export type StringNullableFilter = Prisma.StringNullableFilter

/**
 * @deprecated Renamed to `Prisma.StateRelationFilter`
 */
export type StateRelationFilter = Prisma.StateRelationFilter

/**
 * @deprecated Renamed to `Prisma.CompanyListRelationFilter`
 */
export type CompanyListRelationFilter = Prisma.CompanyListRelationFilter

/**
 * @deprecated Renamed to `Prisma.FarmListRelationFilter`
 */
export type FarmListRelationFilter = Prisma.FarmListRelationFilter

/**
 * @deprecated Renamed to `Prisma.FloatFilter`
 */
export type FloatFilter = Prisma.FloatFilter

/**
 * @deprecated Renamed to `Prisma.JsonNullableFilter`
 */
export type JsonNullableFilter = Prisma.JsonNullableFilter

/**
 * @deprecated Renamed to `Prisma.FarmRelationFilter`
 */
export type FarmRelationFilter = Prisma.FarmRelationFilter

/**
 * @deprecated Renamed to `Prisma.FieldListRelationFilter`
 */
export type FieldListRelationFilter = Prisma.FieldListRelationFilter

/**
 * @deprecated Renamed to `Prisma.Name_per_farm_unCompoundUniqueInput`
 */
export type Name_per_farm_unCompoundUniqueInput = Prisma.Name_per_farm_unCompoundUniqueInput

/**
 * @deprecated Renamed to `Prisma.BoolFilter`
 */
export type BoolFilter = Prisma.BoolFilter

/**
 * @deprecated Renamed to `Prisma.AddressRelationFilter`
 */
export type AddressRelationFilter = Prisma.AddressRelationFilter

/**
 * @deprecated Renamed to `Prisma.QuotationListRelationFilter`
 */
export type QuotationListRelationFilter = Prisma.QuotationListRelationFilter

/**
 * @deprecated Renamed to `Prisma.DateTimeFilter`
 */
export type DateTimeFilter = Prisma.DateTimeFilter

/**
 * @deprecated Renamed to `Prisma.BoolNullableFilter`
 */
export type BoolNullableFilter = Prisma.BoolNullableFilter

/**
 * @deprecated Renamed to `Prisma.FieldRelationFilter`
 */
export type FieldRelationFilter = Prisma.FieldRelationFilter

/**
 * @deprecated Renamed to `Prisma.DiagnosisListRelationFilter`
 */
export type DiagnosisListRelationFilter = Prisma.DiagnosisListRelationFilter

/**
 * @deprecated Renamed to `Prisma.CropRelationFilter`
 */
export type CropRelationFilter = Prisma.CropRelationFilter

/**
 * @deprecated Renamed to `Prisma.InfestationListRelationFilter`
 */
export type InfestationListRelationFilter = Prisma.InfestationListRelationFilter

/**
 * @deprecated Renamed to `Prisma.PrescriptionListRelationFilter`
 */
export type PrescriptionListRelationFilter = Prisma.PrescriptionListRelationFilter

/**
 * @deprecated Renamed to `Prisma.FloatNullableFilter`
 */
export type FloatNullableFilter = Prisma.FloatNullableFilter

/**
 * @deprecated Renamed to `Prisma.AreaListRelationFilter`
 */
export type AreaListRelationFilter = Prisma.AreaListRelationFilter

/**
 * @deprecated Renamed to `Prisma.ImagingListRelationFilter`
 */
export type ImagingListRelationFilter = Prisma.ImagingListRelationFilter

/**
 * @deprecated Renamed to `Prisma.Many_user_has_many_farmListRelationFilter`
 */
export type Many_user_has_many_farmListRelationFilter = Prisma.Many_user_has_many_farmListRelationFilter

/**
 * @deprecated Renamed to `Prisma.JsonFilter`
 */
export type JsonFilter = Prisma.JsonFilter

/**
 * @deprecated Renamed to `Prisma.AreaRelationFilter`
 */
export type AreaRelationFilter = Prisma.AreaRelationFilter

/**
 * @deprecated Renamed to `Prisma.CropListRelationFilter`
 */
export type CropListRelationFilter = Prisma.CropListRelationFilter

/**
 * @deprecated Renamed to `Prisma.Many_quotation_modal_package_has_many_fieldListRelationFilter`
 */
export type Many_quotation_modal_package_has_many_fieldListRelationFilter = Prisma.Many_quotation_modal_package_has_many_fieldListRelationFilter

/**
 * @deprecated Renamed to `Prisma.Name_per_area_unCompoundUniqueInput`
 */
export type Name_per_area_unCompoundUniqueInput = Prisma.Name_per_area_unCompoundUniqueInput

/**
 * @deprecated Renamed to `Prisma.DiagnosisRelationFilter`
 */
export type DiagnosisRelationFilter = Prisma.DiagnosisRelationFilter

/**
 * @deprecated Renamed to `Prisma.PlagueRelationFilter`
 */
export type PlagueRelationFilter = Prisma.PlagueRelationFilter

/**
 * @deprecated Renamed to `Prisma.Diagnosis_plague_unCompoundUniqueInput`
 */
export type Diagnosis_plague_unCompoundUniqueInput = Prisma.Diagnosis_plague_unCompoundUniqueInput

/**
 * @deprecated Renamed to `Prisma.Quotation_modal_packageRelationFilter`
 */
export type Quotation_modal_packageRelationFilter = Prisma.Quotation_modal_packageRelationFilter

/**
 * @deprecated Renamed to `Prisma.Id_quotation_modal_packageId_fieldCompoundUniqueInput`
 */
export type Id_quotation_modal_packageId_fieldCompoundUniqueInput = Prisma.Id_quotation_modal_packageId_fieldCompoundUniqueInput

/**
 * @deprecated Renamed to `Prisma.UserRelationFilter`
 */
export type UserRelationFilter = Prisma.UserRelationFilter

/**
 * @deprecated Renamed to `Prisma.User_idFarm_idCompoundUniqueInput`
 */
export type User_idFarm_idCompoundUniqueInput = Prisma.User_idFarm_idCompoundUniqueInput

/**
 * @deprecated Renamed to `Prisma.DateTimeNullableFilter`
 */
export type DateTimeNullableFilter = Prisma.DateTimeNullableFilter

/**
 * @deprecated Renamed to `Prisma.User_accepted_privacy_policyListRelationFilter`
 */
export type User_accepted_privacy_policyListRelationFilter = Prisma.User_accepted_privacy_policyListRelationFilter

/**
 * @deprecated Renamed to `Prisma.CompanyRelationFilter`
 */
export type CompanyRelationFilter = Prisma.CompanyRelationFilter

/**
 * @deprecated Renamed to `Prisma.Quotation_checkoutRelationFilter`
 */
export type Quotation_checkoutRelationFilter = Prisma.Quotation_checkoutRelationFilter

/**
 * @deprecated Renamed to `Prisma.QuotationRelationFilter`
 */
export type QuotationRelationFilter = Prisma.QuotationRelationFilter

/**
 * @deprecated Renamed to `Prisma.Quotation_packageRelationFilter`
 */
export type Quotation_packageRelationFilter = Prisma.Quotation_packageRelationFilter

/**
 * @deprecated Renamed to `Prisma.Quotation_modal_packageListRelationFilter`
 */
export type Quotation_modal_packageListRelationFilter = Prisma.Quotation_modal_packageListRelationFilter

/**
 * @deprecated Renamed to `Prisma.User_roleListRelationFilter`
 */
export type User_roleListRelationFilter = Prisma.User_roleListRelationFilter

/**
 * @deprecated Renamed to `Prisma.AddressListRelationFilter`
 */
export type AddressListRelationFilter = Prisma.AddressListRelationFilter

/**
 * @deprecated Renamed to `Prisma.User_accepted_termsListRelationFilter`
 */
export type User_accepted_termsListRelationFilter = Prisma.User_accepted_termsListRelationFilter

/**
 * @deprecated Renamed to `Prisma.NotificationListRelationFilter`
 */
export type NotificationListRelationFilter = Prisma.NotificationListRelationFilter

/**
 * @deprecated Renamed to `Prisma.Privacy_policyRelationFilter`
 */
export type Privacy_policyRelationFilter = Prisma.Privacy_policyRelationFilter

/**
 * @deprecated Renamed to `Prisma.Terms_and_conditionsRelationFilter`
 */
export type Terms_and_conditionsRelationFilter = Prisma.Terms_and_conditionsRelationFilter

/**
 * @deprecated Renamed to `Prisma.RoleRelationFilter`
 */
export type RoleRelationFilter = Prisma.RoleRelationFilter

/**
 * @deprecated Renamed to `Prisma.stateCreateOneWithoutAddressInput`
 */
export type stateCreateOneWithoutAddressInput = Prisma.stateCreateOneWithoutAddressInput

/**
 * @deprecated Renamed to `Prisma.companyCreateManyWithoutAddressInput`
 */
export type companyCreateManyWithoutAddressInput = Prisma.companyCreateManyWithoutAddressInput

/**
 * @deprecated Renamed to `Prisma.farmCreateManyWithoutAddressInput`
 */
export type farmCreateManyWithoutAddressInput = Prisma.farmCreateManyWithoutAddressInput

/**
 * @deprecated Renamed to `Prisma.StringFieldUpdateOperationsInput`
 */
export type StringFieldUpdateOperationsInput = Prisma.StringFieldUpdateOperationsInput

/**
 * @deprecated Renamed to `Prisma.NullableIntFieldUpdateOperationsInput`
 */
export type NullableIntFieldUpdateOperationsInput = Prisma.NullableIntFieldUpdateOperationsInput

/**
 * @deprecated Renamed to `Prisma.NullableStringFieldUpdateOperationsInput`
 */
export type NullableStringFieldUpdateOperationsInput = Prisma.NullableStringFieldUpdateOperationsInput

/**
 * @deprecated Renamed to `Prisma.stateUpdateOneRequiredWithoutAddressInput`
 */
export type stateUpdateOneRequiredWithoutAddressInput = Prisma.stateUpdateOneRequiredWithoutAddressInput

/**
 * @deprecated Renamed to `Prisma.companyUpdateManyWithoutAddressInput`
 */
export type companyUpdateManyWithoutAddressInput = Prisma.companyUpdateManyWithoutAddressInput

/**
 * @deprecated Renamed to `Prisma.farmUpdateManyWithoutAddressInput`
 */
export type farmUpdateManyWithoutAddressInput = Prisma.farmUpdateManyWithoutAddressInput

/**
 * @deprecated Renamed to `Prisma.farmCreateOneWithoutAreaInput`
 */
export type farmCreateOneWithoutAreaInput = Prisma.farmCreateOneWithoutAreaInput

/**
 * @deprecated Renamed to `Prisma.fieldCreateManyWithoutAreaInput`
 */
export type fieldCreateManyWithoutAreaInput = Prisma.fieldCreateManyWithoutAreaInput

/**
 * @deprecated Renamed to `Prisma.IntFieldUpdateOperationsInput`
 */
export type IntFieldUpdateOperationsInput = Prisma.IntFieldUpdateOperationsInput

/**
 * @deprecated Renamed to `Prisma.FloatFieldUpdateOperationsInput`
 */
export type FloatFieldUpdateOperationsInput = Prisma.FloatFieldUpdateOperationsInput

/**
 * @deprecated Renamed to `Prisma.farmUpdateOneRequiredWithoutAreaInput`
 */
export type farmUpdateOneRequiredWithoutAreaInput = Prisma.farmUpdateOneRequiredWithoutAreaInput

/**
 * @deprecated Renamed to `Prisma.fieldUpdateManyWithoutAreaInput`
 */
export type fieldUpdateManyWithoutAreaInput = Prisma.fieldUpdateManyWithoutAreaInput

/**
 * @deprecated Renamed to `Prisma.addressCreateOneWithoutCompanyInput`
 */
export type addressCreateOneWithoutCompanyInput = Prisma.addressCreateOneWithoutCompanyInput

/**
 * @deprecated Renamed to `Prisma.quotationCreateManyWithoutCompanyInput`
 */
export type quotationCreateManyWithoutCompanyInput = Prisma.quotationCreateManyWithoutCompanyInput

/**
 * @deprecated Renamed to `Prisma.BoolFieldUpdateOperationsInput`
 */
export type BoolFieldUpdateOperationsInput = Prisma.BoolFieldUpdateOperationsInput

/**
 * @deprecated Renamed to `Prisma.addressUpdateOneRequiredWithoutCompanyInput`
 */
export type addressUpdateOneRequiredWithoutCompanyInput = Prisma.addressUpdateOneRequiredWithoutCompanyInput

/**
 * @deprecated Renamed to `Prisma.quotationUpdateManyWithoutCompanyInput`
 */
export type quotationUpdateManyWithoutCompanyInput = Prisma.quotationUpdateManyWithoutCompanyInput

/**
 * @deprecated Renamed to `Prisma.fieldCreateOneWithoutCropInput`
 */
export type fieldCreateOneWithoutCropInput = Prisma.fieldCreateOneWithoutCropInput

/**
 * @deprecated Renamed to `Prisma.diagnosisCreateManyWithoutCropInput`
 */
export type diagnosisCreateManyWithoutCropInput = Prisma.diagnosisCreateManyWithoutCropInput

/**
 * @deprecated Renamed to `Prisma.DateTimeFieldUpdateOperationsInput`
 */
export type DateTimeFieldUpdateOperationsInput = Prisma.DateTimeFieldUpdateOperationsInput

/**
 * @deprecated Renamed to `Prisma.NullableBoolFieldUpdateOperationsInput`
 */
export type NullableBoolFieldUpdateOperationsInput = Prisma.NullableBoolFieldUpdateOperationsInput

/**
 * @deprecated Renamed to `Prisma.fieldUpdateOneRequiredWithoutCropInput`
 */
export type fieldUpdateOneRequiredWithoutCropInput = Prisma.fieldUpdateOneRequiredWithoutCropInput

/**
 * @deprecated Renamed to `Prisma.diagnosisUpdateManyWithoutCropInput`
 */
export type diagnosisUpdateManyWithoutCropInput = Prisma.diagnosisUpdateManyWithoutCropInput

/**
 * @deprecated Renamed to `Prisma.cropCreateOneWithoutDiagnosisInput`
 */
export type cropCreateOneWithoutDiagnosisInput = Prisma.cropCreateOneWithoutDiagnosisInput

/**
 * @deprecated Renamed to `Prisma.infestationCreateManyWithoutDiagnosisInput`
 */
export type infestationCreateManyWithoutDiagnosisInput = Prisma.infestationCreateManyWithoutDiagnosisInput

/**
 * @deprecated Renamed to `Prisma.prescriptionCreateManyWithoutDiagnosisInput`
 */
export type prescriptionCreateManyWithoutDiagnosisInput = Prisma.prescriptionCreateManyWithoutDiagnosisInput

/**
 * @deprecated Renamed to `Prisma.cropUpdateOneWithoutDiagnosisInput`
 */
export type cropUpdateOneWithoutDiagnosisInput = Prisma.cropUpdateOneWithoutDiagnosisInput

/**
 * @deprecated Renamed to `Prisma.infestationUpdateManyWithoutDiagnosisInput`
 */
export type infestationUpdateManyWithoutDiagnosisInput = Prisma.infestationUpdateManyWithoutDiagnosisInput

/**
 * @deprecated Renamed to `Prisma.prescriptionUpdateManyWithoutDiagnosisInput`
 */
export type prescriptionUpdateManyWithoutDiagnosisInput = Prisma.prescriptionUpdateManyWithoutDiagnosisInput

/**
 * @deprecated Renamed to `Prisma.addressCreateOneWithoutFarmInput`
 */
export type addressCreateOneWithoutFarmInput = Prisma.addressCreateOneWithoutFarmInput

/**
 * @deprecated Renamed to `Prisma.areaCreateManyWithoutFarmInput`
 */
export type areaCreateManyWithoutFarmInput = Prisma.areaCreateManyWithoutFarmInput

/**
 * @deprecated Renamed to `Prisma.imagingCreateManyWithoutFarmInput`
 */
export type imagingCreateManyWithoutFarmInput = Prisma.imagingCreateManyWithoutFarmInput

/**
 * @deprecated Renamed to `Prisma.many_user_has_many_farmCreateManyWithoutFarmInput`
 */
export type many_user_has_many_farmCreateManyWithoutFarmInput = Prisma.many_user_has_many_farmCreateManyWithoutFarmInput

/**
 * @deprecated Renamed to `Prisma.NullableFloatFieldUpdateOperationsInput`
 */
export type NullableFloatFieldUpdateOperationsInput = Prisma.NullableFloatFieldUpdateOperationsInput

/**
 * @deprecated Renamed to `Prisma.addressUpdateOneRequiredWithoutFarmInput`
 */
export type addressUpdateOneRequiredWithoutFarmInput = Prisma.addressUpdateOneRequiredWithoutFarmInput

/**
 * @deprecated Renamed to `Prisma.areaUpdateManyWithoutFarmInput`
 */
export type areaUpdateManyWithoutFarmInput = Prisma.areaUpdateManyWithoutFarmInput

/**
 * @deprecated Renamed to `Prisma.imagingUpdateManyWithoutFarmInput`
 */
export type imagingUpdateManyWithoutFarmInput = Prisma.imagingUpdateManyWithoutFarmInput

/**
 * @deprecated Renamed to `Prisma.many_user_has_many_farmUpdateManyWithoutFarmInput`
 */
export type many_user_has_many_farmUpdateManyWithoutFarmInput = Prisma.many_user_has_many_farmUpdateManyWithoutFarmInput

/**
 * @deprecated Renamed to `Prisma.areaCreateOneWithoutFieldInput`
 */
export type areaCreateOneWithoutFieldInput = Prisma.areaCreateOneWithoutFieldInput

/**
 * @deprecated Renamed to `Prisma.cropCreateManyWithoutFieldInput`
 */
export type cropCreateManyWithoutFieldInput = Prisma.cropCreateManyWithoutFieldInput

/**
 * @deprecated Renamed to `Prisma.many_quotation_modal_package_has_many_fieldCreateManyWithoutFieldInput`
 */
export type many_quotation_modal_package_has_many_fieldCreateManyWithoutFieldInput = Prisma.many_quotation_modal_package_has_many_fieldCreateManyWithoutFieldInput

/**
 * @deprecated Renamed to `Prisma.areaUpdateOneRequiredWithoutFieldInput`
 */
export type areaUpdateOneRequiredWithoutFieldInput = Prisma.areaUpdateOneRequiredWithoutFieldInput

/**
 * @deprecated Renamed to `Prisma.cropUpdateManyWithoutFieldInput`
 */
export type cropUpdateManyWithoutFieldInput = Prisma.cropUpdateManyWithoutFieldInput

/**
 * @deprecated Renamed to `Prisma.many_quotation_modal_package_has_many_fieldUpdateManyWithoutFieldInput`
 */
export type many_quotation_modal_package_has_many_fieldUpdateManyWithoutFieldInput = Prisma.many_quotation_modal_package_has_many_fieldUpdateManyWithoutFieldInput

/**
 * @deprecated Renamed to `Prisma.farmCreateOneWithoutImagingInput`
 */
export type farmCreateOneWithoutImagingInput = Prisma.farmCreateOneWithoutImagingInput

/**
 * @deprecated Renamed to `Prisma.farmUpdateOneWithoutImagingInput`
 */
export type farmUpdateOneWithoutImagingInput = Prisma.farmUpdateOneWithoutImagingInput

/**
 * @deprecated Renamed to `Prisma.diagnosisCreateOneWithoutInfestationInput`
 */
export type diagnosisCreateOneWithoutInfestationInput = Prisma.diagnosisCreateOneWithoutInfestationInput

/**
 * @deprecated Renamed to `Prisma.plagueCreateOneWithoutInfestationInput`
 */
export type plagueCreateOneWithoutInfestationInput = Prisma.plagueCreateOneWithoutInfestationInput

/**
 * @deprecated Renamed to `Prisma.diagnosisUpdateOneRequiredWithoutInfestationInput`
 */
export type diagnosisUpdateOneRequiredWithoutInfestationInput = Prisma.diagnosisUpdateOneRequiredWithoutInfestationInput

/**
 * @deprecated Renamed to `Prisma.plagueUpdateOneRequiredWithoutInfestationInput`
 */
export type plagueUpdateOneRequiredWithoutInfestationInput = Prisma.plagueUpdateOneRequiredWithoutInfestationInput

/**
 * @deprecated Renamed to `Prisma.fieldCreateOneWithoutMany_quotation_modal_package_has_many_fieldInput`
 */
export type fieldCreateOneWithoutMany_quotation_modal_package_has_many_fieldInput = Prisma.fieldCreateOneWithoutMany_quotation_modal_package_has_many_fieldInput

/**
 * @deprecated Renamed to `Prisma.quotation_modal_packageCreateOneWithoutMany_quotation_modal_package_has_many_fieldInput`
 */
export type quotation_modal_packageCreateOneWithoutMany_quotation_modal_package_has_many_fieldInput = Prisma.quotation_modal_packageCreateOneWithoutMany_quotation_modal_package_has_many_fieldInput

/**
 * @deprecated Renamed to `Prisma.fieldUpdateOneRequiredWithoutMany_quotation_modal_package_has_many_fieldInput`
 */
export type fieldUpdateOneRequiredWithoutMany_quotation_modal_package_has_many_fieldInput = Prisma.fieldUpdateOneRequiredWithoutMany_quotation_modal_package_has_many_fieldInput

/**
 * @deprecated Renamed to `Prisma.quotation_modal_packageUpdateOneRequiredWithoutMany_quotation_modal_package_has_many_fieldInput`
 */
export type quotation_modal_packageUpdateOneRequiredWithoutMany_quotation_modal_package_has_many_fieldInput = Prisma.quotation_modal_packageUpdateOneRequiredWithoutMany_quotation_modal_package_has_many_fieldInput

/**
 * @deprecated Renamed to `Prisma.farmCreateOneWithoutMany_user_has_many_farmInput`
 */
export type farmCreateOneWithoutMany_user_has_many_farmInput = Prisma.farmCreateOneWithoutMany_user_has_many_farmInput

/**
 * @deprecated Renamed to `Prisma.userCreateOneWithoutMany_user_has_many_farmInput`
 */
export type userCreateOneWithoutMany_user_has_many_farmInput = Prisma.userCreateOneWithoutMany_user_has_many_farmInput

/**
 * @deprecated Renamed to `Prisma.farmUpdateOneRequiredWithoutMany_user_has_many_farmInput`
 */
export type farmUpdateOneRequiredWithoutMany_user_has_many_farmInput = Prisma.farmUpdateOneRequiredWithoutMany_user_has_many_farmInput

/**
 * @deprecated Renamed to `Prisma.userUpdateOneRequiredWithoutMany_user_has_many_farmInput`
 */
export type userUpdateOneRequiredWithoutMany_user_has_many_farmInput = Prisma.userUpdateOneRequiredWithoutMany_user_has_many_farmInput

/**
 * @deprecated Renamed to `Prisma.userCreateOneWithoutNotificationInput`
 */
export type userCreateOneWithoutNotificationInput = Prisma.userCreateOneWithoutNotificationInput

/**
 * @deprecated Renamed to `Prisma.NullableDateTimeFieldUpdateOperationsInput`
 */
export type NullableDateTimeFieldUpdateOperationsInput = Prisma.NullableDateTimeFieldUpdateOperationsInput

/**
 * @deprecated Renamed to `Prisma.userUpdateOneRequiredWithoutNotificationInput`
 */
export type userUpdateOneRequiredWithoutNotificationInput = Prisma.userUpdateOneRequiredWithoutNotificationInput

/**
 * @deprecated Renamed to `Prisma.infestationCreateManyWithoutPlagueInput`
 */
export type infestationCreateManyWithoutPlagueInput = Prisma.infestationCreateManyWithoutPlagueInput

/**
 * @deprecated Renamed to `Prisma.infestationUpdateManyWithoutPlagueInput`
 */
export type infestationUpdateManyWithoutPlagueInput = Prisma.infestationUpdateManyWithoutPlagueInput

/**
 * @deprecated Renamed to `Prisma.diagnosisCreateOneWithoutPrescriptionInput`
 */
export type diagnosisCreateOneWithoutPrescriptionInput = Prisma.diagnosisCreateOneWithoutPrescriptionInput

/**
 * @deprecated Renamed to `Prisma.diagnosisUpdateOneRequiredWithoutPrescriptionInput`
 */
export type diagnosisUpdateOneRequiredWithoutPrescriptionInput = Prisma.diagnosisUpdateOneRequiredWithoutPrescriptionInput

/**
 * @deprecated Renamed to `Prisma.user_accepted_privacy_policyCreateManyWithoutPrivacy_policyInput`
 */
export type user_accepted_privacy_policyCreateManyWithoutPrivacy_policyInput = Prisma.user_accepted_privacy_policyCreateManyWithoutPrivacy_policyInput

/**
 * @deprecated Renamed to `Prisma.user_accepted_privacy_policyUpdateManyWithoutPrivacy_policyInput`
 */
export type user_accepted_privacy_policyUpdateManyWithoutPrivacy_policyInput = Prisma.user_accepted_privacy_policyUpdateManyWithoutPrivacy_policyInput

/**
 * @deprecated Renamed to `Prisma.companyCreateOneWithoutQuotationInput`
 */
export type companyCreateOneWithoutQuotationInput = Prisma.companyCreateOneWithoutQuotationInput

/**
 * @deprecated Renamed to `Prisma.quotation_modal_packageCreateOneWithoutQuotationInput`
 */
export type quotation_modal_packageCreateOneWithoutQuotationInput = Prisma.quotation_modal_packageCreateOneWithoutQuotationInput

/**
 * @deprecated Renamed to `Prisma.quotation_checkoutCreateOneWithoutQuotationInput`
 */
export type quotation_checkoutCreateOneWithoutQuotationInput = Prisma.quotation_checkoutCreateOneWithoutQuotationInput

/**
 * @deprecated Renamed to `Prisma.companyUpdateOneRequiredWithoutQuotationInput`
 */
export type companyUpdateOneRequiredWithoutQuotationInput = Prisma.companyUpdateOneRequiredWithoutQuotationInput

/**
 * @deprecated Renamed to `Prisma.quotation_modal_packageUpdateOneRequiredWithoutQuotationInput`
 */
export type quotation_modal_packageUpdateOneRequiredWithoutQuotationInput = Prisma.quotation_modal_packageUpdateOneRequiredWithoutQuotationInput

/**
 * @deprecated Renamed to `Prisma.quotation_checkoutUpdateOneWithoutQuotationInput`
 */
export type quotation_checkoutUpdateOneWithoutQuotationInput = Prisma.quotation_checkoutUpdateOneWithoutQuotationInput

/**
 * @deprecated Renamed to `Prisma.quotationCreateOneWithoutQuotation_checkoutInput`
 */
export type quotationCreateOneWithoutQuotation_checkoutInput = Prisma.quotationCreateOneWithoutQuotation_checkoutInput

/**
 * @deprecated Renamed to `Prisma.quotationUpdateOneRequiredWithoutQuotation_checkoutInput`
 */
export type quotationUpdateOneRequiredWithoutQuotation_checkoutInput = Prisma.quotationUpdateOneRequiredWithoutQuotation_checkoutInput

/**
 * @deprecated Renamed to `Prisma.quotation_packageCreateOneWithoutQuotation_modal_packageInput`
 */
export type quotation_packageCreateOneWithoutQuotation_modal_packageInput = Prisma.quotation_packageCreateOneWithoutQuotation_modal_packageInput

/**
 * @deprecated Renamed to `Prisma.many_quotation_modal_package_has_many_fieldCreateManyWithoutQuotation_modal_packageInput`
 */
export type many_quotation_modal_package_has_many_fieldCreateManyWithoutQuotation_modal_packageInput = Prisma.many_quotation_modal_package_has_many_fieldCreateManyWithoutQuotation_modal_packageInput

/**
 * @deprecated Renamed to `Prisma.quotationCreateManyWithoutQuotation_modal_packageInput`
 */
export type quotationCreateManyWithoutQuotation_modal_packageInput = Prisma.quotationCreateManyWithoutQuotation_modal_packageInput

/**
 * @deprecated Renamed to `Prisma.quotation_packageUpdateOneRequiredWithoutQuotation_modal_packageInput`
 */
export type quotation_packageUpdateOneRequiredWithoutQuotation_modal_packageInput = Prisma.quotation_packageUpdateOneRequiredWithoutQuotation_modal_packageInput

/**
 * @deprecated Renamed to `Prisma.many_quotation_modal_package_has_many_fieldUpdateManyWithoutQuotation_modal_packageInput`
 */
export type many_quotation_modal_package_has_many_fieldUpdateManyWithoutQuotation_modal_packageInput = Prisma.many_quotation_modal_package_has_many_fieldUpdateManyWithoutQuotation_modal_packageInput

/**
 * @deprecated Renamed to `Prisma.quotationUpdateManyWithoutQuotation_modal_packageInput`
 */
export type quotationUpdateManyWithoutQuotation_modal_packageInput = Prisma.quotationUpdateManyWithoutQuotation_modal_packageInput

/**
 * @deprecated Renamed to `Prisma.quotation_modal_packageCreateManyWithoutQuotation_packageInput`
 */
export type quotation_modal_packageCreateManyWithoutQuotation_packageInput = Prisma.quotation_modal_packageCreateManyWithoutQuotation_packageInput

/**
 * @deprecated Renamed to `Prisma.quotation_modal_packageUpdateManyWithoutQuotation_packageInput`
 */
export type quotation_modal_packageUpdateManyWithoutQuotation_packageInput = Prisma.quotation_modal_packageUpdateManyWithoutQuotation_packageInput

/**
 * @deprecated Renamed to `Prisma.user_roleCreateManyWithoutRoleInput`
 */
export type user_roleCreateManyWithoutRoleInput = Prisma.user_roleCreateManyWithoutRoleInput

/**
 * @deprecated Renamed to `Prisma.user_roleUpdateManyWithoutRoleInput`
 */
export type user_roleUpdateManyWithoutRoleInput = Prisma.user_roleUpdateManyWithoutRoleInput

/**
 * @deprecated Renamed to `Prisma.addressCreateManyWithoutStateInput`
 */
export type addressCreateManyWithoutStateInput = Prisma.addressCreateManyWithoutStateInput

/**
 * @deprecated Renamed to `Prisma.addressUpdateManyWithoutStateInput`
 */
export type addressUpdateManyWithoutStateInput = Prisma.addressUpdateManyWithoutStateInput

/**
 * @deprecated Renamed to `Prisma.user_accepted_termsCreateManyWithoutTerms_and_conditionsInput`
 */
export type user_accepted_termsCreateManyWithoutTerms_and_conditionsInput = Prisma.user_accepted_termsCreateManyWithoutTerms_and_conditionsInput

/**
 * @deprecated Renamed to `Prisma.user_accepted_termsUpdateManyWithoutTerms_and_conditionsInput`
 */
export type user_accepted_termsUpdateManyWithoutTerms_and_conditionsInput = Prisma.user_accepted_termsUpdateManyWithoutTerms_and_conditionsInput

/**
 * @deprecated Renamed to `Prisma.many_user_has_many_farmCreateManyWithoutUserInput`
 */
export type many_user_has_many_farmCreateManyWithoutUserInput = Prisma.many_user_has_many_farmCreateManyWithoutUserInput

/**
 * @deprecated Renamed to `Prisma.notificationCreateManyWithoutUserInput`
 */
export type notificationCreateManyWithoutUserInput = Prisma.notificationCreateManyWithoutUserInput

/**
 * @deprecated Renamed to `Prisma.user_accepted_privacy_policyCreateManyWithoutUserInput`
 */
export type user_accepted_privacy_policyCreateManyWithoutUserInput = Prisma.user_accepted_privacy_policyCreateManyWithoutUserInput

/**
 * @deprecated Renamed to `Prisma.user_accepted_termsCreateManyWithoutUserInput`
 */
export type user_accepted_termsCreateManyWithoutUserInput = Prisma.user_accepted_termsCreateManyWithoutUserInput

/**
 * @deprecated Renamed to `Prisma.user_roleCreateManyWithoutUserInput`
 */
export type user_roleCreateManyWithoutUserInput = Prisma.user_roleCreateManyWithoutUserInput

/**
 * @deprecated Renamed to `Prisma.many_user_has_many_farmUpdateManyWithoutUserInput`
 */
export type many_user_has_many_farmUpdateManyWithoutUserInput = Prisma.many_user_has_many_farmUpdateManyWithoutUserInput

/**
 * @deprecated Renamed to `Prisma.notificationUpdateManyWithoutUserInput`
 */
export type notificationUpdateManyWithoutUserInput = Prisma.notificationUpdateManyWithoutUserInput

/**
 * @deprecated Renamed to `Prisma.user_accepted_privacy_policyUpdateManyWithoutUserInput`
 */
export type user_accepted_privacy_policyUpdateManyWithoutUserInput = Prisma.user_accepted_privacy_policyUpdateManyWithoutUserInput

/**
 * @deprecated Renamed to `Prisma.user_accepted_termsUpdateManyWithoutUserInput`
 */
export type user_accepted_termsUpdateManyWithoutUserInput = Prisma.user_accepted_termsUpdateManyWithoutUserInput

/**
 * @deprecated Renamed to `Prisma.user_roleUpdateManyWithoutUserInput`
 */
export type user_roleUpdateManyWithoutUserInput = Prisma.user_roleUpdateManyWithoutUserInput

/**
 * @deprecated Renamed to `Prisma.privacy_policyCreateOneWithoutUser_accepted_privacy_policyInput`
 */
export type privacy_policyCreateOneWithoutUser_accepted_privacy_policyInput = Prisma.privacy_policyCreateOneWithoutUser_accepted_privacy_policyInput

/**
 * @deprecated Renamed to `Prisma.userCreateOneWithoutUser_accepted_privacy_policyInput`
 */
export type userCreateOneWithoutUser_accepted_privacy_policyInput = Prisma.userCreateOneWithoutUser_accepted_privacy_policyInput

/**
 * @deprecated Renamed to `Prisma.privacy_policyUpdateOneRequiredWithoutUser_accepted_privacy_policyInput`
 */
export type privacy_policyUpdateOneRequiredWithoutUser_accepted_privacy_policyInput = Prisma.privacy_policyUpdateOneRequiredWithoutUser_accepted_privacy_policyInput

/**
 * @deprecated Renamed to `Prisma.userUpdateOneRequiredWithoutUser_accepted_privacy_policyInput`
 */
export type userUpdateOneRequiredWithoutUser_accepted_privacy_policyInput = Prisma.userUpdateOneRequiredWithoutUser_accepted_privacy_policyInput

/**
 * @deprecated Renamed to `Prisma.terms_and_conditionsCreateOneWithoutUser_accepted_termsInput`
 */
export type terms_and_conditionsCreateOneWithoutUser_accepted_termsInput = Prisma.terms_and_conditionsCreateOneWithoutUser_accepted_termsInput

/**
 * @deprecated Renamed to `Prisma.userCreateOneWithoutUser_accepted_termsInput`
 */
export type userCreateOneWithoutUser_accepted_termsInput = Prisma.userCreateOneWithoutUser_accepted_termsInput

/**
 * @deprecated Renamed to `Prisma.terms_and_conditionsUpdateOneRequiredWithoutUser_accepted_termsInput`
 */
export type terms_and_conditionsUpdateOneRequiredWithoutUser_accepted_termsInput = Prisma.terms_and_conditionsUpdateOneRequiredWithoutUser_accepted_termsInput

/**
 * @deprecated Renamed to `Prisma.userUpdateOneRequiredWithoutUser_accepted_termsInput`
 */
export type userUpdateOneRequiredWithoutUser_accepted_termsInput = Prisma.userUpdateOneRequiredWithoutUser_accepted_termsInput

/**
 * @deprecated Renamed to `Prisma.roleCreateOneWithoutUser_roleInput`
 */
export type roleCreateOneWithoutUser_roleInput = Prisma.roleCreateOneWithoutUser_roleInput

/**
 * @deprecated Renamed to `Prisma.userCreateOneWithoutUser_roleInput`
 */
export type userCreateOneWithoutUser_roleInput = Prisma.userCreateOneWithoutUser_roleInput

/**
 * @deprecated Renamed to `Prisma.roleUpdateOneRequiredWithoutUser_roleInput`
 */
export type roleUpdateOneRequiredWithoutUser_roleInput = Prisma.roleUpdateOneRequiredWithoutUser_roleInput

/**
 * @deprecated Renamed to `Prisma.userUpdateOneRequiredWithoutUser_roleInput`
 */
export type userUpdateOneRequiredWithoutUser_roleInput = Prisma.userUpdateOneRequiredWithoutUser_roleInput

/**
 * @deprecated Renamed to `Prisma.NestedIntFilter`
 */
export type NestedIntFilter = Prisma.NestedIntFilter

/**
 * @deprecated Renamed to `Prisma.NestedStringFilter`
 */
export type NestedStringFilter = Prisma.NestedStringFilter

/**
 * @deprecated Renamed to `Prisma.NestedIntNullableFilter`
 */
export type NestedIntNullableFilter = Prisma.NestedIntNullableFilter

/**
 * @deprecated Renamed to `Prisma.NestedStringNullableFilter`
 */
export type NestedStringNullableFilter = Prisma.NestedStringNullableFilter

/**
 * @deprecated Renamed to `Prisma.NestedFloatFilter`
 */
export type NestedFloatFilter = Prisma.NestedFloatFilter

/**
 * @deprecated Renamed to `Prisma.NestedBoolFilter`
 */
export type NestedBoolFilter = Prisma.NestedBoolFilter

/**
 * @deprecated Renamed to `Prisma.NestedDateTimeFilter`
 */
export type NestedDateTimeFilter = Prisma.NestedDateTimeFilter

/**
 * @deprecated Renamed to `Prisma.NestedBoolNullableFilter`
 */
export type NestedBoolNullableFilter = Prisma.NestedBoolNullableFilter

/**
 * @deprecated Renamed to `Prisma.NestedFloatNullableFilter`
 */
export type NestedFloatNullableFilter = Prisma.NestedFloatNullableFilter

/**
 * @deprecated Renamed to `Prisma.NestedDateTimeNullableFilter`
 */
export type NestedDateTimeNullableFilter = Prisma.NestedDateTimeNullableFilter

/**
 * @deprecated Renamed to `Prisma.stateCreateWithoutAddressInput`
 */
export type stateCreateWithoutAddressInput = Prisma.stateCreateWithoutAddressInput

/**
 * @deprecated Renamed to `Prisma.stateCreateOrConnectWithoutaddressInput`
 */
export type stateCreateOrConnectWithoutaddressInput = Prisma.stateCreateOrConnectWithoutaddressInput

/**
 * @deprecated Renamed to `Prisma.companyCreateWithoutAddressInput`
 */
export type companyCreateWithoutAddressInput = Prisma.companyCreateWithoutAddressInput

/**
 * @deprecated Renamed to `Prisma.companyCreateOrConnectWithoutaddressInput`
 */
export type companyCreateOrConnectWithoutaddressInput = Prisma.companyCreateOrConnectWithoutaddressInput

/**
 * @deprecated Renamed to `Prisma.farmCreateWithoutAddressInput`
 */
export type farmCreateWithoutAddressInput = Prisma.farmCreateWithoutAddressInput

/**
 * @deprecated Renamed to `Prisma.farmCreateOrConnectWithoutaddressInput`
 */
export type farmCreateOrConnectWithoutaddressInput = Prisma.farmCreateOrConnectWithoutaddressInput

/**
 * @deprecated Renamed to `Prisma.stateUpdateWithoutAddressInput`
 */
export type stateUpdateWithoutAddressInput = Prisma.stateUpdateWithoutAddressInput

/**
 * @deprecated Renamed to `Prisma.stateUpsertWithoutAddressInput`
 */
export type stateUpsertWithoutAddressInput = Prisma.stateUpsertWithoutAddressInput

/**
 * @deprecated Renamed to `Prisma.companyUpdateWithWhereUniqueWithoutAddressInput`
 */
export type companyUpdateWithWhereUniqueWithoutAddressInput = Prisma.companyUpdateWithWhereUniqueWithoutAddressInput

/**
 * @deprecated Renamed to `Prisma.companyUpdateManyWithWhereWithoutAddressInput`
 */
export type companyUpdateManyWithWhereWithoutAddressInput = Prisma.companyUpdateManyWithWhereWithoutAddressInput

/**
 * @deprecated Renamed to `Prisma.companyScalarWhereInput`
 */
export type companyScalarWhereInput = Prisma.companyScalarWhereInput

/**
 * @deprecated Renamed to `Prisma.companyUpsertWithWhereUniqueWithoutAddressInput`
 */
export type companyUpsertWithWhereUniqueWithoutAddressInput = Prisma.companyUpsertWithWhereUniqueWithoutAddressInput

/**
 * @deprecated Renamed to `Prisma.farmUpdateWithWhereUniqueWithoutAddressInput`
 */
export type farmUpdateWithWhereUniqueWithoutAddressInput = Prisma.farmUpdateWithWhereUniqueWithoutAddressInput

/**
 * @deprecated Renamed to `Prisma.farmUpdateManyWithWhereWithoutAddressInput`
 */
export type farmUpdateManyWithWhereWithoutAddressInput = Prisma.farmUpdateManyWithWhereWithoutAddressInput

/**
 * @deprecated Renamed to `Prisma.farmScalarWhereInput`
 */
export type farmScalarWhereInput = Prisma.farmScalarWhereInput

/**
 * @deprecated Renamed to `Prisma.farmUpsertWithWhereUniqueWithoutAddressInput`
 */
export type farmUpsertWithWhereUniqueWithoutAddressInput = Prisma.farmUpsertWithWhereUniqueWithoutAddressInput

/**
 * @deprecated Renamed to `Prisma.farmCreateWithoutAreaInput`
 */
export type farmCreateWithoutAreaInput = Prisma.farmCreateWithoutAreaInput

/**
 * @deprecated Renamed to `Prisma.farmCreateOrConnectWithoutareaInput`
 */
export type farmCreateOrConnectWithoutareaInput = Prisma.farmCreateOrConnectWithoutareaInput

/**
 * @deprecated Renamed to `Prisma.fieldCreateWithoutAreaInput`
 */
export type fieldCreateWithoutAreaInput = Prisma.fieldCreateWithoutAreaInput

/**
 * @deprecated Renamed to `Prisma.fieldCreateOrConnectWithoutareaInput`
 */
export type fieldCreateOrConnectWithoutareaInput = Prisma.fieldCreateOrConnectWithoutareaInput

/**
 * @deprecated Renamed to `Prisma.farmUpdateWithoutAreaInput`
 */
export type farmUpdateWithoutAreaInput = Prisma.farmUpdateWithoutAreaInput

/**
 * @deprecated Renamed to `Prisma.farmUpsertWithoutAreaInput`
 */
export type farmUpsertWithoutAreaInput = Prisma.farmUpsertWithoutAreaInput

/**
 * @deprecated Renamed to `Prisma.fieldUpdateWithWhereUniqueWithoutAreaInput`
 */
export type fieldUpdateWithWhereUniqueWithoutAreaInput = Prisma.fieldUpdateWithWhereUniqueWithoutAreaInput

/**
 * @deprecated Renamed to `Prisma.fieldUpdateManyWithWhereWithoutAreaInput`
 */
export type fieldUpdateManyWithWhereWithoutAreaInput = Prisma.fieldUpdateManyWithWhereWithoutAreaInput

/**
 * @deprecated Renamed to `Prisma.fieldScalarWhereInput`
 */
export type fieldScalarWhereInput = Prisma.fieldScalarWhereInput

/**
 * @deprecated Renamed to `Prisma.fieldUpsertWithWhereUniqueWithoutAreaInput`
 */
export type fieldUpsertWithWhereUniqueWithoutAreaInput = Prisma.fieldUpsertWithWhereUniqueWithoutAreaInput

/**
 * @deprecated Renamed to `Prisma.addressCreateWithoutCompanyInput`
 */
export type addressCreateWithoutCompanyInput = Prisma.addressCreateWithoutCompanyInput

/**
 * @deprecated Renamed to `Prisma.addressCreateOrConnectWithoutcompanyInput`
 */
export type addressCreateOrConnectWithoutcompanyInput = Prisma.addressCreateOrConnectWithoutcompanyInput

/**
 * @deprecated Renamed to `Prisma.quotationCreateWithoutCompanyInput`
 */
export type quotationCreateWithoutCompanyInput = Prisma.quotationCreateWithoutCompanyInput

/**
 * @deprecated Renamed to `Prisma.quotationCreateOrConnectWithoutcompanyInput`
 */
export type quotationCreateOrConnectWithoutcompanyInput = Prisma.quotationCreateOrConnectWithoutcompanyInput

/**
 * @deprecated Renamed to `Prisma.addressUpdateWithoutCompanyInput`
 */
export type addressUpdateWithoutCompanyInput = Prisma.addressUpdateWithoutCompanyInput

/**
 * @deprecated Renamed to `Prisma.addressUpsertWithoutCompanyInput`
 */
export type addressUpsertWithoutCompanyInput = Prisma.addressUpsertWithoutCompanyInput

/**
 * @deprecated Renamed to `Prisma.quotationUpdateWithWhereUniqueWithoutCompanyInput`
 */
export type quotationUpdateWithWhereUniqueWithoutCompanyInput = Prisma.quotationUpdateWithWhereUniqueWithoutCompanyInput

/**
 * @deprecated Renamed to `Prisma.quotationUpdateManyWithWhereWithoutCompanyInput`
 */
export type quotationUpdateManyWithWhereWithoutCompanyInput = Prisma.quotationUpdateManyWithWhereWithoutCompanyInput

/**
 * @deprecated Renamed to `Prisma.quotationScalarWhereInput`
 */
export type quotationScalarWhereInput = Prisma.quotationScalarWhereInput

/**
 * @deprecated Renamed to `Prisma.quotationUpsertWithWhereUniqueWithoutCompanyInput`
 */
export type quotationUpsertWithWhereUniqueWithoutCompanyInput = Prisma.quotationUpsertWithWhereUniqueWithoutCompanyInput

/**
 * @deprecated Renamed to `Prisma.fieldCreateWithoutCropInput`
 */
export type fieldCreateWithoutCropInput = Prisma.fieldCreateWithoutCropInput

/**
 * @deprecated Renamed to `Prisma.fieldCreateOrConnectWithoutcropInput`
 */
export type fieldCreateOrConnectWithoutcropInput = Prisma.fieldCreateOrConnectWithoutcropInput

/**
 * @deprecated Renamed to `Prisma.diagnosisCreateWithoutCropInput`
 */
export type diagnosisCreateWithoutCropInput = Prisma.diagnosisCreateWithoutCropInput

/**
 * @deprecated Renamed to `Prisma.diagnosisCreateOrConnectWithoutcropInput`
 */
export type diagnosisCreateOrConnectWithoutcropInput = Prisma.diagnosisCreateOrConnectWithoutcropInput

/**
 * @deprecated Renamed to `Prisma.fieldUpdateWithoutCropInput`
 */
export type fieldUpdateWithoutCropInput = Prisma.fieldUpdateWithoutCropInput

/**
 * @deprecated Renamed to `Prisma.fieldUpsertWithoutCropInput`
 */
export type fieldUpsertWithoutCropInput = Prisma.fieldUpsertWithoutCropInput

/**
 * @deprecated Renamed to `Prisma.diagnosisUpdateWithWhereUniqueWithoutCropInput`
 */
export type diagnosisUpdateWithWhereUniqueWithoutCropInput = Prisma.diagnosisUpdateWithWhereUniqueWithoutCropInput

/**
 * @deprecated Renamed to `Prisma.diagnosisUpdateManyWithWhereWithoutCropInput`
 */
export type diagnosisUpdateManyWithWhereWithoutCropInput = Prisma.diagnosisUpdateManyWithWhereWithoutCropInput

/**
 * @deprecated Renamed to `Prisma.diagnosisScalarWhereInput`
 */
export type diagnosisScalarWhereInput = Prisma.diagnosisScalarWhereInput

/**
 * @deprecated Renamed to `Prisma.diagnosisUpsertWithWhereUniqueWithoutCropInput`
 */
export type diagnosisUpsertWithWhereUniqueWithoutCropInput = Prisma.diagnosisUpsertWithWhereUniqueWithoutCropInput

/**
 * @deprecated Renamed to `Prisma.cropCreateWithoutDiagnosisInput`
 */
export type cropCreateWithoutDiagnosisInput = Prisma.cropCreateWithoutDiagnosisInput

/**
 * @deprecated Renamed to `Prisma.cropCreateOrConnectWithoutdiagnosisInput`
 */
export type cropCreateOrConnectWithoutdiagnosisInput = Prisma.cropCreateOrConnectWithoutdiagnosisInput

/**
 * @deprecated Renamed to `Prisma.infestationCreateWithoutDiagnosisInput`
 */
export type infestationCreateWithoutDiagnosisInput = Prisma.infestationCreateWithoutDiagnosisInput

/**
 * @deprecated Renamed to `Prisma.infestationCreateOrConnectWithoutdiagnosisInput`
 */
export type infestationCreateOrConnectWithoutdiagnosisInput = Prisma.infestationCreateOrConnectWithoutdiagnosisInput

/**
 * @deprecated Renamed to `Prisma.prescriptionCreateWithoutDiagnosisInput`
 */
export type prescriptionCreateWithoutDiagnosisInput = Prisma.prescriptionCreateWithoutDiagnosisInput

/**
 * @deprecated Renamed to `Prisma.prescriptionCreateOrConnectWithoutdiagnosisInput`
 */
export type prescriptionCreateOrConnectWithoutdiagnosisInput = Prisma.prescriptionCreateOrConnectWithoutdiagnosisInput

/**
 * @deprecated Renamed to `Prisma.cropUpdateWithoutDiagnosisInput`
 */
export type cropUpdateWithoutDiagnosisInput = Prisma.cropUpdateWithoutDiagnosisInput

/**
 * @deprecated Renamed to `Prisma.cropUpsertWithoutDiagnosisInput`
 */
export type cropUpsertWithoutDiagnosisInput = Prisma.cropUpsertWithoutDiagnosisInput

/**
 * @deprecated Renamed to `Prisma.infestationUpdateWithWhereUniqueWithoutDiagnosisInput`
 */
export type infestationUpdateWithWhereUniqueWithoutDiagnosisInput = Prisma.infestationUpdateWithWhereUniqueWithoutDiagnosisInput

/**
 * @deprecated Renamed to `Prisma.infestationUpdateManyWithWhereWithoutDiagnosisInput`
 */
export type infestationUpdateManyWithWhereWithoutDiagnosisInput = Prisma.infestationUpdateManyWithWhereWithoutDiagnosisInput

/**
 * @deprecated Renamed to `Prisma.infestationScalarWhereInput`
 */
export type infestationScalarWhereInput = Prisma.infestationScalarWhereInput

/**
 * @deprecated Renamed to `Prisma.infestationUpsertWithWhereUniqueWithoutDiagnosisInput`
 */
export type infestationUpsertWithWhereUniqueWithoutDiagnosisInput = Prisma.infestationUpsertWithWhereUniqueWithoutDiagnosisInput

/**
 * @deprecated Renamed to `Prisma.prescriptionUpdateWithWhereUniqueWithoutDiagnosisInput`
 */
export type prescriptionUpdateWithWhereUniqueWithoutDiagnosisInput = Prisma.prescriptionUpdateWithWhereUniqueWithoutDiagnosisInput

/**
 * @deprecated Renamed to `Prisma.prescriptionUpdateManyWithWhereWithoutDiagnosisInput`
 */
export type prescriptionUpdateManyWithWhereWithoutDiagnosisInput = Prisma.prescriptionUpdateManyWithWhereWithoutDiagnosisInput

/**
 * @deprecated Renamed to `Prisma.prescriptionScalarWhereInput`
 */
export type prescriptionScalarWhereInput = Prisma.prescriptionScalarWhereInput

/**
 * @deprecated Renamed to `Prisma.prescriptionUpsertWithWhereUniqueWithoutDiagnosisInput`
 */
export type prescriptionUpsertWithWhereUniqueWithoutDiagnosisInput = Prisma.prescriptionUpsertWithWhereUniqueWithoutDiagnosisInput

/**
 * @deprecated Renamed to `Prisma.addressCreateWithoutFarmInput`
 */
export type addressCreateWithoutFarmInput = Prisma.addressCreateWithoutFarmInput

/**
 * @deprecated Renamed to `Prisma.addressCreateOrConnectWithoutfarmInput`
 */
export type addressCreateOrConnectWithoutfarmInput = Prisma.addressCreateOrConnectWithoutfarmInput

/**
 * @deprecated Renamed to `Prisma.areaCreateWithoutFarmInput`
 */
export type areaCreateWithoutFarmInput = Prisma.areaCreateWithoutFarmInput

/**
 * @deprecated Renamed to `Prisma.areaCreateOrConnectWithoutfarmInput`
 */
export type areaCreateOrConnectWithoutfarmInput = Prisma.areaCreateOrConnectWithoutfarmInput

/**
 * @deprecated Renamed to `Prisma.imagingCreateWithoutFarmInput`
 */
export type imagingCreateWithoutFarmInput = Prisma.imagingCreateWithoutFarmInput

/**
 * @deprecated Renamed to `Prisma.imagingCreateOrConnectWithoutfarmInput`
 */
export type imagingCreateOrConnectWithoutfarmInput = Prisma.imagingCreateOrConnectWithoutfarmInput

/**
 * @deprecated Renamed to `Prisma.many_user_has_many_farmCreateWithoutFarmInput`
 */
export type many_user_has_many_farmCreateWithoutFarmInput = Prisma.many_user_has_many_farmCreateWithoutFarmInput

/**
 * @deprecated Renamed to `Prisma.many_user_has_many_farmCreateOrConnectWithoutfarmInput`
 */
export type many_user_has_many_farmCreateOrConnectWithoutfarmInput = Prisma.many_user_has_many_farmCreateOrConnectWithoutfarmInput

/**
 * @deprecated Renamed to `Prisma.addressUpdateWithoutFarmInput`
 */
export type addressUpdateWithoutFarmInput = Prisma.addressUpdateWithoutFarmInput

/**
 * @deprecated Renamed to `Prisma.addressUpsertWithoutFarmInput`
 */
export type addressUpsertWithoutFarmInput = Prisma.addressUpsertWithoutFarmInput

/**
 * @deprecated Renamed to `Prisma.areaUpdateWithWhereUniqueWithoutFarmInput`
 */
export type areaUpdateWithWhereUniqueWithoutFarmInput = Prisma.areaUpdateWithWhereUniqueWithoutFarmInput

/**
 * @deprecated Renamed to `Prisma.areaUpdateManyWithWhereWithoutFarmInput`
 */
export type areaUpdateManyWithWhereWithoutFarmInput = Prisma.areaUpdateManyWithWhereWithoutFarmInput

/**
 * @deprecated Renamed to `Prisma.areaScalarWhereInput`
 */
export type areaScalarWhereInput = Prisma.areaScalarWhereInput

/**
 * @deprecated Renamed to `Prisma.areaUpsertWithWhereUniqueWithoutFarmInput`
 */
export type areaUpsertWithWhereUniqueWithoutFarmInput = Prisma.areaUpsertWithWhereUniqueWithoutFarmInput

/**
 * @deprecated Renamed to `Prisma.imagingUpdateWithWhereUniqueWithoutFarmInput`
 */
export type imagingUpdateWithWhereUniqueWithoutFarmInput = Prisma.imagingUpdateWithWhereUniqueWithoutFarmInput

/**
 * @deprecated Renamed to `Prisma.imagingUpdateManyWithWhereWithoutFarmInput`
 */
export type imagingUpdateManyWithWhereWithoutFarmInput = Prisma.imagingUpdateManyWithWhereWithoutFarmInput

/**
 * @deprecated Renamed to `Prisma.imagingScalarWhereInput`
 */
export type imagingScalarWhereInput = Prisma.imagingScalarWhereInput

/**
 * @deprecated Renamed to `Prisma.imagingUpsertWithWhereUniqueWithoutFarmInput`
 */
export type imagingUpsertWithWhereUniqueWithoutFarmInput = Prisma.imagingUpsertWithWhereUniqueWithoutFarmInput

/**
 * @deprecated Renamed to `Prisma.many_user_has_many_farmUpdateWithWhereUniqueWithoutFarmInput`
 */
export type many_user_has_many_farmUpdateWithWhereUniqueWithoutFarmInput = Prisma.many_user_has_many_farmUpdateWithWhereUniqueWithoutFarmInput

/**
 * @deprecated Renamed to `Prisma.many_user_has_many_farmUpdateManyWithWhereWithoutFarmInput`
 */
export type many_user_has_many_farmUpdateManyWithWhereWithoutFarmInput = Prisma.many_user_has_many_farmUpdateManyWithWhereWithoutFarmInput

/**
 * @deprecated Renamed to `Prisma.many_user_has_many_farmScalarWhereInput`
 */
export type many_user_has_many_farmScalarWhereInput = Prisma.many_user_has_many_farmScalarWhereInput

/**
 * @deprecated Renamed to `Prisma.many_user_has_many_farmUpsertWithWhereUniqueWithoutFarmInput`
 */
export type many_user_has_many_farmUpsertWithWhereUniqueWithoutFarmInput = Prisma.many_user_has_many_farmUpsertWithWhereUniqueWithoutFarmInput

/**
 * @deprecated Renamed to `Prisma.areaCreateWithoutFieldInput`
 */
export type areaCreateWithoutFieldInput = Prisma.areaCreateWithoutFieldInput

/**
 * @deprecated Renamed to `Prisma.areaCreateOrConnectWithoutfieldInput`
 */
export type areaCreateOrConnectWithoutfieldInput = Prisma.areaCreateOrConnectWithoutfieldInput

/**
 * @deprecated Renamed to `Prisma.cropCreateWithoutFieldInput`
 */
export type cropCreateWithoutFieldInput = Prisma.cropCreateWithoutFieldInput

/**
 * @deprecated Renamed to `Prisma.cropCreateOrConnectWithoutfieldInput`
 */
export type cropCreateOrConnectWithoutfieldInput = Prisma.cropCreateOrConnectWithoutfieldInput

/**
 * @deprecated Renamed to `Prisma.many_quotation_modal_package_has_many_fieldCreateWithoutFieldInput`
 */
export type many_quotation_modal_package_has_many_fieldCreateWithoutFieldInput = Prisma.many_quotation_modal_package_has_many_fieldCreateWithoutFieldInput

/**
 * @deprecated Renamed to `Prisma.many_quotation_modal_package_has_many_fieldCreateOrConnectWithoutfieldInput`
 */
export type many_quotation_modal_package_has_many_fieldCreateOrConnectWithoutfieldInput = Prisma.many_quotation_modal_package_has_many_fieldCreateOrConnectWithoutfieldInput

/**
 * @deprecated Renamed to `Prisma.areaUpdateWithoutFieldInput`
 */
export type areaUpdateWithoutFieldInput = Prisma.areaUpdateWithoutFieldInput

/**
 * @deprecated Renamed to `Prisma.areaUpsertWithoutFieldInput`
 */
export type areaUpsertWithoutFieldInput = Prisma.areaUpsertWithoutFieldInput

/**
 * @deprecated Renamed to `Prisma.cropUpdateWithWhereUniqueWithoutFieldInput`
 */
export type cropUpdateWithWhereUniqueWithoutFieldInput = Prisma.cropUpdateWithWhereUniqueWithoutFieldInput

/**
 * @deprecated Renamed to `Prisma.cropUpdateManyWithWhereWithoutFieldInput`
 */
export type cropUpdateManyWithWhereWithoutFieldInput = Prisma.cropUpdateManyWithWhereWithoutFieldInput

/**
 * @deprecated Renamed to `Prisma.cropScalarWhereInput`
 */
export type cropScalarWhereInput = Prisma.cropScalarWhereInput

/**
 * @deprecated Renamed to `Prisma.cropUpsertWithWhereUniqueWithoutFieldInput`
 */
export type cropUpsertWithWhereUniqueWithoutFieldInput = Prisma.cropUpsertWithWhereUniqueWithoutFieldInput

/**
 * @deprecated Renamed to `Prisma.many_quotation_modal_package_has_many_fieldUpdateWithWhereUniqueWithoutFieldInput`
 */
export type many_quotation_modal_package_has_many_fieldUpdateWithWhereUniqueWithoutFieldInput = Prisma.many_quotation_modal_package_has_many_fieldUpdateWithWhereUniqueWithoutFieldInput

/**
 * @deprecated Renamed to `Prisma.many_quotation_modal_package_has_many_fieldUpdateManyWithWhereWithoutFieldInput`
 */
export type many_quotation_modal_package_has_many_fieldUpdateManyWithWhereWithoutFieldInput = Prisma.many_quotation_modal_package_has_many_fieldUpdateManyWithWhereWithoutFieldInput

/**
 * @deprecated Renamed to `Prisma.many_quotation_modal_package_has_many_fieldScalarWhereInput`
 */
export type many_quotation_modal_package_has_many_fieldScalarWhereInput = Prisma.many_quotation_modal_package_has_many_fieldScalarWhereInput

/**
 * @deprecated Renamed to `Prisma.many_quotation_modal_package_has_many_fieldUpsertWithWhereUniqueWithoutFieldInput`
 */
export type many_quotation_modal_package_has_many_fieldUpsertWithWhereUniqueWithoutFieldInput = Prisma.many_quotation_modal_package_has_many_fieldUpsertWithWhereUniqueWithoutFieldInput

/**
 * @deprecated Renamed to `Prisma.farmCreateWithoutImagingInput`
 */
export type farmCreateWithoutImagingInput = Prisma.farmCreateWithoutImagingInput

/**
 * @deprecated Renamed to `Prisma.farmCreateOrConnectWithoutimagingInput`
 */
export type farmCreateOrConnectWithoutimagingInput = Prisma.farmCreateOrConnectWithoutimagingInput

/**
 * @deprecated Renamed to `Prisma.farmUpdateWithoutImagingInput`
 */
export type farmUpdateWithoutImagingInput = Prisma.farmUpdateWithoutImagingInput

/**
 * @deprecated Renamed to `Prisma.farmUpsertWithoutImagingInput`
 */
export type farmUpsertWithoutImagingInput = Prisma.farmUpsertWithoutImagingInput

/**
 * @deprecated Renamed to `Prisma.diagnosisCreateWithoutInfestationInput`
 */
export type diagnosisCreateWithoutInfestationInput = Prisma.diagnosisCreateWithoutInfestationInput

/**
 * @deprecated Renamed to `Prisma.diagnosisCreateOrConnectWithoutinfestationInput`
 */
export type diagnosisCreateOrConnectWithoutinfestationInput = Prisma.diagnosisCreateOrConnectWithoutinfestationInput

/**
 * @deprecated Renamed to `Prisma.plagueCreateWithoutInfestationInput`
 */
export type plagueCreateWithoutInfestationInput = Prisma.plagueCreateWithoutInfestationInput

/**
 * @deprecated Renamed to `Prisma.plagueCreateOrConnectWithoutinfestationInput`
 */
export type plagueCreateOrConnectWithoutinfestationInput = Prisma.plagueCreateOrConnectWithoutinfestationInput

/**
 * @deprecated Renamed to `Prisma.diagnosisUpdateWithoutInfestationInput`
 */
export type diagnosisUpdateWithoutInfestationInput = Prisma.diagnosisUpdateWithoutInfestationInput

/**
 * @deprecated Renamed to `Prisma.diagnosisUpsertWithoutInfestationInput`
 */
export type diagnosisUpsertWithoutInfestationInput = Prisma.diagnosisUpsertWithoutInfestationInput

/**
 * @deprecated Renamed to `Prisma.plagueUpdateWithoutInfestationInput`
 */
export type plagueUpdateWithoutInfestationInput = Prisma.plagueUpdateWithoutInfestationInput

/**
 * @deprecated Renamed to `Prisma.plagueUpsertWithoutInfestationInput`
 */
export type plagueUpsertWithoutInfestationInput = Prisma.plagueUpsertWithoutInfestationInput

/**
 * @deprecated Renamed to `Prisma.fieldCreateWithoutMany_quotation_modal_package_has_many_fieldInput`
 */
export type fieldCreateWithoutMany_quotation_modal_package_has_many_fieldInput = Prisma.fieldCreateWithoutMany_quotation_modal_package_has_many_fieldInput

/**
 * @deprecated Renamed to `Prisma.fieldCreateOrConnectWithoutmany_quotation_modal_package_has_many_fieldInput`
 */
export type fieldCreateOrConnectWithoutmany_quotation_modal_package_has_many_fieldInput = Prisma.fieldCreateOrConnectWithoutmany_quotation_modal_package_has_many_fieldInput

/**
 * @deprecated Renamed to `Prisma.quotation_modal_packageCreateWithoutMany_quotation_modal_package_has_many_fieldInput`
 */
export type quotation_modal_packageCreateWithoutMany_quotation_modal_package_has_many_fieldInput = Prisma.quotation_modal_packageCreateWithoutMany_quotation_modal_package_has_many_fieldInput

/**
 * @deprecated Renamed to `Prisma.quotation_modal_packageCreateOrConnectWithoutmany_quotation_modal_package_has_many_fieldInput`
 */
export type quotation_modal_packageCreateOrConnectWithoutmany_quotation_modal_package_has_many_fieldInput = Prisma.quotation_modal_packageCreateOrConnectWithoutmany_quotation_modal_package_has_many_fieldInput

/**
 * @deprecated Renamed to `Prisma.fieldUpdateWithoutMany_quotation_modal_package_has_many_fieldInput`
 */
export type fieldUpdateWithoutMany_quotation_modal_package_has_many_fieldInput = Prisma.fieldUpdateWithoutMany_quotation_modal_package_has_many_fieldInput

/**
 * @deprecated Renamed to `Prisma.fieldUpsertWithoutMany_quotation_modal_package_has_many_fieldInput`
 */
export type fieldUpsertWithoutMany_quotation_modal_package_has_many_fieldInput = Prisma.fieldUpsertWithoutMany_quotation_modal_package_has_many_fieldInput

/**
 * @deprecated Renamed to `Prisma.quotation_modal_packageUpdateWithoutMany_quotation_modal_package_has_many_fieldInput`
 */
export type quotation_modal_packageUpdateWithoutMany_quotation_modal_package_has_many_fieldInput = Prisma.quotation_modal_packageUpdateWithoutMany_quotation_modal_package_has_many_fieldInput

/**
 * @deprecated Renamed to `Prisma.quotation_modal_packageUpsertWithoutMany_quotation_modal_package_has_many_fieldInput`
 */
export type quotation_modal_packageUpsertWithoutMany_quotation_modal_package_has_many_fieldInput = Prisma.quotation_modal_packageUpsertWithoutMany_quotation_modal_package_has_many_fieldInput

/**
 * @deprecated Renamed to `Prisma.farmCreateWithoutMany_user_has_many_farmInput`
 */
export type farmCreateWithoutMany_user_has_many_farmInput = Prisma.farmCreateWithoutMany_user_has_many_farmInput

/**
 * @deprecated Renamed to `Prisma.farmCreateOrConnectWithoutmany_user_has_many_farmInput`
 */
export type farmCreateOrConnectWithoutmany_user_has_many_farmInput = Prisma.farmCreateOrConnectWithoutmany_user_has_many_farmInput

/**
 * @deprecated Renamed to `Prisma.userCreateWithoutMany_user_has_many_farmInput`
 */
export type userCreateWithoutMany_user_has_many_farmInput = Prisma.userCreateWithoutMany_user_has_many_farmInput

/**
 * @deprecated Renamed to `Prisma.userCreateOrConnectWithoutmany_user_has_many_farmInput`
 */
export type userCreateOrConnectWithoutmany_user_has_many_farmInput = Prisma.userCreateOrConnectWithoutmany_user_has_many_farmInput

/**
 * @deprecated Renamed to `Prisma.farmUpdateWithoutMany_user_has_many_farmInput`
 */
export type farmUpdateWithoutMany_user_has_many_farmInput = Prisma.farmUpdateWithoutMany_user_has_many_farmInput

/**
 * @deprecated Renamed to `Prisma.farmUpsertWithoutMany_user_has_many_farmInput`
 */
export type farmUpsertWithoutMany_user_has_many_farmInput = Prisma.farmUpsertWithoutMany_user_has_many_farmInput

/**
 * @deprecated Renamed to `Prisma.userUpdateWithoutMany_user_has_many_farmInput`
 */
export type userUpdateWithoutMany_user_has_many_farmInput = Prisma.userUpdateWithoutMany_user_has_many_farmInput

/**
 * @deprecated Renamed to `Prisma.userUpsertWithoutMany_user_has_many_farmInput`
 */
export type userUpsertWithoutMany_user_has_many_farmInput = Prisma.userUpsertWithoutMany_user_has_many_farmInput

/**
 * @deprecated Renamed to `Prisma.userCreateWithoutNotificationInput`
 */
export type userCreateWithoutNotificationInput = Prisma.userCreateWithoutNotificationInput

/**
 * @deprecated Renamed to `Prisma.userCreateOrConnectWithoutnotificationInput`
 */
export type userCreateOrConnectWithoutnotificationInput = Prisma.userCreateOrConnectWithoutnotificationInput

/**
 * @deprecated Renamed to `Prisma.userUpdateWithoutNotificationInput`
 */
export type userUpdateWithoutNotificationInput = Prisma.userUpdateWithoutNotificationInput

/**
 * @deprecated Renamed to `Prisma.userUpsertWithoutNotificationInput`
 */
export type userUpsertWithoutNotificationInput = Prisma.userUpsertWithoutNotificationInput

/**
 * @deprecated Renamed to `Prisma.infestationCreateWithoutPlagueInput`
 */
export type infestationCreateWithoutPlagueInput = Prisma.infestationCreateWithoutPlagueInput

/**
 * @deprecated Renamed to `Prisma.infestationCreateOrConnectWithoutplagueInput`
 */
export type infestationCreateOrConnectWithoutplagueInput = Prisma.infestationCreateOrConnectWithoutplagueInput

/**
 * @deprecated Renamed to `Prisma.infestationUpdateWithWhereUniqueWithoutPlagueInput`
 */
export type infestationUpdateWithWhereUniqueWithoutPlagueInput = Prisma.infestationUpdateWithWhereUniqueWithoutPlagueInput

/**
 * @deprecated Renamed to `Prisma.infestationUpdateManyWithWhereWithoutPlagueInput`
 */
export type infestationUpdateManyWithWhereWithoutPlagueInput = Prisma.infestationUpdateManyWithWhereWithoutPlagueInput

/**
 * @deprecated Renamed to `Prisma.infestationUpsertWithWhereUniqueWithoutPlagueInput`
 */
export type infestationUpsertWithWhereUniqueWithoutPlagueInput = Prisma.infestationUpsertWithWhereUniqueWithoutPlagueInput

/**
 * @deprecated Renamed to `Prisma.diagnosisCreateWithoutPrescriptionInput`
 */
export type diagnosisCreateWithoutPrescriptionInput = Prisma.diagnosisCreateWithoutPrescriptionInput

/**
 * @deprecated Renamed to `Prisma.diagnosisCreateOrConnectWithoutprescriptionInput`
 */
export type diagnosisCreateOrConnectWithoutprescriptionInput = Prisma.diagnosisCreateOrConnectWithoutprescriptionInput

/**
 * @deprecated Renamed to `Prisma.diagnosisUpdateWithoutPrescriptionInput`
 */
export type diagnosisUpdateWithoutPrescriptionInput = Prisma.diagnosisUpdateWithoutPrescriptionInput

/**
 * @deprecated Renamed to `Prisma.diagnosisUpsertWithoutPrescriptionInput`
 */
export type diagnosisUpsertWithoutPrescriptionInput = Prisma.diagnosisUpsertWithoutPrescriptionInput

/**
 * @deprecated Renamed to `Prisma.user_accepted_privacy_policyCreateWithoutPrivacy_policyInput`
 */
export type user_accepted_privacy_policyCreateWithoutPrivacy_policyInput = Prisma.user_accepted_privacy_policyCreateWithoutPrivacy_policyInput

/**
 * @deprecated Renamed to `Prisma.user_accepted_privacy_policyCreateOrConnectWithoutprivacy_policyInput`
 */
export type user_accepted_privacy_policyCreateOrConnectWithoutprivacy_policyInput = Prisma.user_accepted_privacy_policyCreateOrConnectWithoutprivacy_policyInput

/**
 * @deprecated Renamed to `Prisma.user_accepted_privacy_policyUpdateWithWhereUniqueWithoutPrivacy_policyInput`
 */
export type user_accepted_privacy_policyUpdateWithWhereUniqueWithoutPrivacy_policyInput = Prisma.user_accepted_privacy_policyUpdateWithWhereUniqueWithoutPrivacy_policyInput

/**
 * @deprecated Renamed to `Prisma.user_accepted_privacy_policyUpdateManyWithWhereWithoutPrivacy_policyInput`
 */
export type user_accepted_privacy_policyUpdateManyWithWhereWithoutPrivacy_policyInput = Prisma.user_accepted_privacy_policyUpdateManyWithWhereWithoutPrivacy_policyInput

/**
 * @deprecated Renamed to `Prisma.user_accepted_privacy_policyScalarWhereInput`
 */
export type user_accepted_privacy_policyScalarWhereInput = Prisma.user_accepted_privacy_policyScalarWhereInput

/**
 * @deprecated Renamed to `Prisma.user_accepted_privacy_policyUpsertWithWhereUniqueWithoutPrivacy_policyInput`
 */
export type user_accepted_privacy_policyUpsertWithWhereUniqueWithoutPrivacy_policyInput = Prisma.user_accepted_privacy_policyUpsertWithWhereUniqueWithoutPrivacy_policyInput

/**
 * @deprecated Renamed to `Prisma.companyCreateWithoutQuotationInput`
 */
export type companyCreateWithoutQuotationInput = Prisma.companyCreateWithoutQuotationInput

/**
 * @deprecated Renamed to `Prisma.companyCreateOrConnectWithoutquotationInput`
 */
export type companyCreateOrConnectWithoutquotationInput = Prisma.companyCreateOrConnectWithoutquotationInput

/**
 * @deprecated Renamed to `Prisma.quotation_modal_packageCreateWithoutQuotationInput`
 */
export type quotation_modal_packageCreateWithoutQuotationInput = Prisma.quotation_modal_packageCreateWithoutQuotationInput

/**
 * @deprecated Renamed to `Prisma.quotation_modal_packageCreateOrConnectWithoutquotationInput`
 */
export type quotation_modal_packageCreateOrConnectWithoutquotationInput = Prisma.quotation_modal_packageCreateOrConnectWithoutquotationInput

/**
 * @deprecated Renamed to `Prisma.quotation_checkoutCreateWithoutQuotationInput`
 */
export type quotation_checkoutCreateWithoutQuotationInput = Prisma.quotation_checkoutCreateWithoutQuotationInput

/**
 * @deprecated Renamed to `Prisma.quotation_checkoutCreateOrConnectWithoutquotationInput`
 */
export type quotation_checkoutCreateOrConnectWithoutquotationInput = Prisma.quotation_checkoutCreateOrConnectWithoutquotationInput

/**
 * @deprecated Renamed to `Prisma.companyUpdateWithoutQuotationInput`
 */
export type companyUpdateWithoutQuotationInput = Prisma.companyUpdateWithoutQuotationInput

/**
 * @deprecated Renamed to `Prisma.companyUpsertWithoutQuotationInput`
 */
export type companyUpsertWithoutQuotationInput = Prisma.companyUpsertWithoutQuotationInput

/**
 * @deprecated Renamed to `Prisma.quotation_modal_packageUpdateWithoutQuotationInput`
 */
export type quotation_modal_packageUpdateWithoutQuotationInput = Prisma.quotation_modal_packageUpdateWithoutQuotationInput

/**
 * @deprecated Renamed to `Prisma.quotation_modal_packageUpsertWithoutQuotationInput`
 */
export type quotation_modal_packageUpsertWithoutQuotationInput = Prisma.quotation_modal_packageUpsertWithoutQuotationInput

/**
 * @deprecated Renamed to `Prisma.quotation_checkoutUpdateWithoutQuotationInput`
 */
export type quotation_checkoutUpdateWithoutQuotationInput = Prisma.quotation_checkoutUpdateWithoutQuotationInput

/**
 * @deprecated Renamed to `Prisma.quotation_checkoutUpsertWithoutQuotationInput`
 */
export type quotation_checkoutUpsertWithoutQuotationInput = Prisma.quotation_checkoutUpsertWithoutQuotationInput

/**
 * @deprecated Renamed to `Prisma.quotationCreateWithoutQuotation_checkoutInput`
 */
export type quotationCreateWithoutQuotation_checkoutInput = Prisma.quotationCreateWithoutQuotation_checkoutInput

/**
 * @deprecated Renamed to `Prisma.quotationCreateOrConnectWithoutquotation_checkoutInput`
 */
export type quotationCreateOrConnectWithoutquotation_checkoutInput = Prisma.quotationCreateOrConnectWithoutquotation_checkoutInput

/**
 * @deprecated Renamed to `Prisma.quotationUpdateWithoutQuotation_checkoutInput`
 */
export type quotationUpdateWithoutQuotation_checkoutInput = Prisma.quotationUpdateWithoutQuotation_checkoutInput

/**
 * @deprecated Renamed to `Prisma.quotationUpsertWithoutQuotation_checkoutInput`
 */
export type quotationUpsertWithoutQuotation_checkoutInput = Prisma.quotationUpsertWithoutQuotation_checkoutInput

/**
 * @deprecated Renamed to `Prisma.quotation_packageCreateWithoutQuotation_modal_packageInput`
 */
export type quotation_packageCreateWithoutQuotation_modal_packageInput = Prisma.quotation_packageCreateWithoutQuotation_modal_packageInput

/**
 * @deprecated Renamed to `Prisma.quotation_packageCreateOrConnectWithoutquotation_modal_packageInput`
 */
export type quotation_packageCreateOrConnectWithoutquotation_modal_packageInput = Prisma.quotation_packageCreateOrConnectWithoutquotation_modal_packageInput

/**
 * @deprecated Renamed to `Prisma.many_quotation_modal_package_has_many_fieldCreateWithoutQuotation_modal_packageInput`
 */
export type many_quotation_modal_package_has_many_fieldCreateWithoutQuotation_modal_packageInput = Prisma.many_quotation_modal_package_has_many_fieldCreateWithoutQuotation_modal_packageInput

/**
 * @deprecated Renamed to `Prisma.many_quotation_modal_package_has_many_fieldCreateOrConnectWithoutquotation_modal_packageInput`
 */
export type many_quotation_modal_package_has_many_fieldCreateOrConnectWithoutquotation_modal_packageInput = Prisma.many_quotation_modal_package_has_many_fieldCreateOrConnectWithoutquotation_modal_packageInput

/**
 * @deprecated Renamed to `Prisma.quotationCreateWithoutQuotation_modal_packageInput`
 */
export type quotationCreateWithoutQuotation_modal_packageInput = Prisma.quotationCreateWithoutQuotation_modal_packageInput

/**
 * @deprecated Renamed to `Prisma.quotationCreateOrConnectWithoutquotation_modal_packageInput`
 */
export type quotationCreateOrConnectWithoutquotation_modal_packageInput = Prisma.quotationCreateOrConnectWithoutquotation_modal_packageInput

/**
 * @deprecated Renamed to `Prisma.quotation_packageUpdateWithoutQuotation_modal_packageInput`
 */
export type quotation_packageUpdateWithoutQuotation_modal_packageInput = Prisma.quotation_packageUpdateWithoutQuotation_modal_packageInput

/**
 * @deprecated Renamed to `Prisma.quotation_packageUpsertWithoutQuotation_modal_packageInput`
 */
export type quotation_packageUpsertWithoutQuotation_modal_packageInput = Prisma.quotation_packageUpsertWithoutQuotation_modal_packageInput

/**
 * @deprecated Renamed to `Prisma.many_quotation_modal_package_has_many_fieldUpdateWithWhereUniqueWithoutQuotation_modal_packageInput`
 */
export type many_quotation_modal_package_has_many_fieldUpdateWithWhereUniqueWithoutQuotation_modal_packageInput = Prisma.many_quotation_modal_package_has_many_fieldUpdateWithWhereUniqueWithoutQuotation_modal_packageInput

/**
 * @deprecated Renamed to `Prisma.many_quotation_modal_package_has_many_fieldUpdateManyWithWhereWithoutQuotation_modal_packageInput`
 */
export type many_quotation_modal_package_has_many_fieldUpdateManyWithWhereWithoutQuotation_modal_packageInput = Prisma.many_quotation_modal_package_has_many_fieldUpdateManyWithWhereWithoutQuotation_modal_packageInput

/**
 * @deprecated Renamed to `Prisma.many_quotation_modal_package_has_many_fieldUpsertWithWhereUniqueWithoutQuotation_modal_packageInput`
 */
export type many_quotation_modal_package_has_many_fieldUpsertWithWhereUniqueWithoutQuotation_modal_packageInput = Prisma.many_quotation_modal_package_has_many_fieldUpsertWithWhereUniqueWithoutQuotation_modal_packageInput

/**
 * @deprecated Renamed to `Prisma.quotationUpdateWithWhereUniqueWithoutQuotation_modal_packageInput`
 */
export type quotationUpdateWithWhereUniqueWithoutQuotation_modal_packageInput = Prisma.quotationUpdateWithWhereUniqueWithoutQuotation_modal_packageInput

/**
 * @deprecated Renamed to `Prisma.quotationUpdateManyWithWhereWithoutQuotation_modal_packageInput`
 */
export type quotationUpdateManyWithWhereWithoutQuotation_modal_packageInput = Prisma.quotationUpdateManyWithWhereWithoutQuotation_modal_packageInput

/**
 * @deprecated Renamed to `Prisma.quotationUpsertWithWhereUniqueWithoutQuotation_modal_packageInput`
 */
export type quotationUpsertWithWhereUniqueWithoutQuotation_modal_packageInput = Prisma.quotationUpsertWithWhereUniqueWithoutQuotation_modal_packageInput

/**
 * @deprecated Renamed to `Prisma.quotation_modal_packageCreateWithoutQuotation_packageInput`
 */
export type quotation_modal_packageCreateWithoutQuotation_packageInput = Prisma.quotation_modal_packageCreateWithoutQuotation_packageInput

/**
 * @deprecated Renamed to `Prisma.quotation_modal_packageCreateOrConnectWithoutquotation_packageInput`
 */
export type quotation_modal_packageCreateOrConnectWithoutquotation_packageInput = Prisma.quotation_modal_packageCreateOrConnectWithoutquotation_packageInput

/**
 * @deprecated Renamed to `Prisma.quotation_modal_packageUpdateWithWhereUniqueWithoutQuotation_packageInput`
 */
export type quotation_modal_packageUpdateWithWhereUniqueWithoutQuotation_packageInput = Prisma.quotation_modal_packageUpdateWithWhereUniqueWithoutQuotation_packageInput

/**
 * @deprecated Renamed to `Prisma.quotation_modal_packageUpdateManyWithWhereWithoutQuotation_packageInput`
 */
export type quotation_modal_packageUpdateManyWithWhereWithoutQuotation_packageInput = Prisma.quotation_modal_packageUpdateManyWithWhereWithoutQuotation_packageInput

/**
 * @deprecated Renamed to `Prisma.quotation_modal_packageScalarWhereInput`
 */
export type quotation_modal_packageScalarWhereInput = Prisma.quotation_modal_packageScalarWhereInput

/**
 * @deprecated Renamed to `Prisma.quotation_modal_packageUpsertWithWhereUniqueWithoutQuotation_packageInput`
 */
export type quotation_modal_packageUpsertWithWhereUniqueWithoutQuotation_packageInput = Prisma.quotation_modal_packageUpsertWithWhereUniqueWithoutQuotation_packageInput

/**
 * @deprecated Renamed to `Prisma.user_roleCreateWithoutRoleInput`
 */
export type user_roleCreateWithoutRoleInput = Prisma.user_roleCreateWithoutRoleInput

/**
 * @deprecated Renamed to `Prisma.user_roleCreateOrConnectWithoutroleInput`
 */
export type user_roleCreateOrConnectWithoutroleInput = Prisma.user_roleCreateOrConnectWithoutroleInput

/**
 * @deprecated Renamed to `Prisma.user_roleUpdateWithWhereUniqueWithoutRoleInput`
 */
export type user_roleUpdateWithWhereUniqueWithoutRoleInput = Prisma.user_roleUpdateWithWhereUniqueWithoutRoleInput

/**
 * @deprecated Renamed to `Prisma.user_roleUpdateManyWithWhereWithoutRoleInput`
 */
export type user_roleUpdateManyWithWhereWithoutRoleInput = Prisma.user_roleUpdateManyWithWhereWithoutRoleInput

/**
 * @deprecated Renamed to `Prisma.user_roleScalarWhereInput`
 */
export type user_roleScalarWhereInput = Prisma.user_roleScalarWhereInput

/**
 * @deprecated Renamed to `Prisma.user_roleUpsertWithWhereUniqueWithoutRoleInput`
 */
export type user_roleUpsertWithWhereUniqueWithoutRoleInput = Prisma.user_roleUpsertWithWhereUniqueWithoutRoleInput

/**
 * @deprecated Renamed to `Prisma.addressCreateWithoutStateInput`
 */
export type addressCreateWithoutStateInput = Prisma.addressCreateWithoutStateInput

/**
 * @deprecated Renamed to `Prisma.addressCreateOrConnectWithoutstateInput`
 */
export type addressCreateOrConnectWithoutstateInput = Prisma.addressCreateOrConnectWithoutstateInput

/**
 * @deprecated Renamed to `Prisma.addressUpdateWithWhereUniqueWithoutStateInput`
 */
export type addressUpdateWithWhereUniqueWithoutStateInput = Prisma.addressUpdateWithWhereUniqueWithoutStateInput

/**
 * @deprecated Renamed to `Prisma.addressUpdateManyWithWhereWithoutStateInput`
 */
export type addressUpdateManyWithWhereWithoutStateInput = Prisma.addressUpdateManyWithWhereWithoutStateInput

/**
 * @deprecated Renamed to `Prisma.addressScalarWhereInput`
 */
export type addressScalarWhereInput = Prisma.addressScalarWhereInput

/**
 * @deprecated Renamed to `Prisma.addressUpsertWithWhereUniqueWithoutStateInput`
 */
export type addressUpsertWithWhereUniqueWithoutStateInput = Prisma.addressUpsertWithWhereUniqueWithoutStateInput

/**
 * @deprecated Renamed to `Prisma.user_accepted_termsCreateWithoutTerms_and_conditionsInput`
 */
export type user_accepted_termsCreateWithoutTerms_and_conditionsInput = Prisma.user_accepted_termsCreateWithoutTerms_and_conditionsInput

/**
 * @deprecated Renamed to `Prisma.user_accepted_termsCreateOrConnectWithoutterms_and_conditionsInput`
 */
export type user_accepted_termsCreateOrConnectWithoutterms_and_conditionsInput = Prisma.user_accepted_termsCreateOrConnectWithoutterms_and_conditionsInput

/**
 * @deprecated Renamed to `Prisma.user_accepted_termsUpdateWithWhereUniqueWithoutTerms_and_conditionsInput`
 */
export type user_accepted_termsUpdateWithWhereUniqueWithoutTerms_and_conditionsInput = Prisma.user_accepted_termsUpdateWithWhereUniqueWithoutTerms_and_conditionsInput

/**
 * @deprecated Renamed to `Prisma.user_accepted_termsUpdateManyWithWhereWithoutTerms_and_conditionsInput`
 */
export type user_accepted_termsUpdateManyWithWhereWithoutTerms_and_conditionsInput = Prisma.user_accepted_termsUpdateManyWithWhereWithoutTerms_and_conditionsInput

/**
 * @deprecated Renamed to `Prisma.user_accepted_termsScalarWhereInput`
 */
export type user_accepted_termsScalarWhereInput = Prisma.user_accepted_termsScalarWhereInput

/**
 * @deprecated Renamed to `Prisma.user_accepted_termsUpsertWithWhereUniqueWithoutTerms_and_conditionsInput`
 */
export type user_accepted_termsUpsertWithWhereUniqueWithoutTerms_and_conditionsInput = Prisma.user_accepted_termsUpsertWithWhereUniqueWithoutTerms_and_conditionsInput

/**
 * @deprecated Renamed to `Prisma.many_user_has_many_farmCreateWithoutUserInput`
 */
export type many_user_has_many_farmCreateWithoutUserInput = Prisma.many_user_has_many_farmCreateWithoutUserInput

/**
 * @deprecated Renamed to `Prisma.many_user_has_many_farmCreateOrConnectWithoutuserInput`
 */
export type many_user_has_many_farmCreateOrConnectWithoutuserInput = Prisma.many_user_has_many_farmCreateOrConnectWithoutuserInput

/**
 * @deprecated Renamed to `Prisma.notificationCreateWithoutUserInput`
 */
export type notificationCreateWithoutUserInput = Prisma.notificationCreateWithoutUserInput

/**
 * @deprecated Renamed to `Prisma.notificationCreateOrConnectWithoutuserInput`
 */
export type notificationCreateOrConnectWithoutuserInput = Prisma.notificationCreateOrConnectWithoutuserInput

/**
 * @deprecated Renamed to `Prisma.user_accepted_privacy_policyCreateWithoutUserInput`
 */
export type user_accepted_privacy_policyCreateWithoutUserInput = Prisma.user_accepted_privacy_policyCreateWithoutUserInput

/**
 * @deprecated Renamed to `Prisma.user_accepted_privacy_policyCreateOrConnectWithoutuserInput`
 */
export type user_accepted_privacy_policyCreateOrConnectWithoutuserInput = Prisma.user_accepted_privacy_policyCreateOrConnectWithoutuserInput

/**
 * @deprecated Renamed to `Prisma.user_accepted_termsCreateWithoutUserInput`
 */
export type user_accepted_termsCreateWithoutUserInput = Prisma.user_accepted_termsCreateWithoutUserInput

/**
 * @deprecated Renamed to `Prisma.user_accepted_termsCreateOrConnectWithoutuserInput`
 */
export type user_accepted_termsCreateOrConnectWithoutuserInput = Prisma.user_accepted_termsCreateOrConnectWithoutuserInput

/**
 * @deprecated Renamed to `Prisma.user_roleCreateWithoutUserInput`
 */
export type user_roleCreateWithoutUserInput = Prisma.user_roleCreateWithoutUserInput

/**
 * @deprecated Renamed to `Prisma.user_roleCreateOrConnectWithoutuserInput`
 */
export type user_roleCreateOrConnectWithoutuserInput = Prisma.user_roleCreateOrConnectWithoutuserInput

/**
 * @deprecated Renamed to `Prisma.many_user_has_many_farmUpdateWithWhereUniqueWithoutUserInput`
 */
export type many_user_has_many_farmUpdateWithWhereUniqueWithoutUserInput = Prisma.many_user_has_many_farmUpdateWithWhereUniqueWithoutUserInput

/**
 * @deprecated Renamed to `Prisma.many_user_has_many_farmUpdateManyWithWhereWithoutUserInput`
 */
export type many_user_has_many_farmUpdateManyWithWhereWithoutUserInput = Prisma.many_user_has_many_farmUpdateManyWithWhereWithoutUserInput

/**
 * @deprecated Renamed to `Prisma.many_user_has_many_farmUpsertWithWhereUniqueWithoutUserInput`
 */
export type many_user_has_many_farmUpsertWithWhereUniqueWithoutUserInput = Prisma.many_user_has_many_farmUpsertWithWhereUniqueWithoutUserInput

/**
 * @deprecated Renamed to `Prisma.notificationUpdateWithWhereUniqueWithoutUserInput`
 */
export type notificationUpdateWithWhereUniqueWithoutUserInput = Prisma.notificationUpdateWithWhereUniqueWithoutUserInput

/**
 * @deprecated Renamed to `Prisma.notificationUpdateManyWithWhereWithoutUserInput`
 */
export type notificationUpdateManyWithWhereWithoutUserInput = Prisma.notificationUpdateManyWithWhereWithoutUserInput

/**
 * @deprecated Renamed to `Prisma.notificationScalarWhereInput`
 */
export type notificationScalarWhereInput = Prisma.notificationScalarWhereInput

/**
 * @deprecated Renamed to `Prisma.notificationUpsertWithWhereUniqueWithoutUserInput`
 */
export type notificationUpsertWithWhereUniqueWithoutUserInput = Prisma.notificationUpsertWithWhereUniqueWithoutUserInput

/**
 * @deprecated Renamed to `Prisma.user_accepted_privacy_policyUpdateWithWhereUniqueWithoutUserInput`
 */
export type user_accepted_privacy_policyUpdateWithWhereUniqueWithoutUserInput = Prisma.user_accepted_privacy_policyUpdateWithWhereUniqueWithoutUserInput

/**
 * @deprecated Renamed to `Prisma.user_accepted_privacy_policyUpdateManyWithWhereWithoutUserInput`
 */
export type user_accepted_privacy_policyUpdateManyWithWhereWithoutUserInput = Prisma.user_accepted_privacy_policyUpdateManyWithWhereWithoutUserInput

/**
 * @deprecated Renamed to `Prisma.user_accepted_privacy_policyUpsertWithWhereUniqueWithoutUserInput`
 */
export type user_accepted_privacy_policyUpsertWithWhereUniqueWithoutUserInput = Prisma.user_accepted_privacy_policyUpsertWithWhereUniqueWithoutUserInput

/**
 * @deprecated Renamed to `Prisma.user_accepted_termsUpdateWithWhereUniqueWithoutUserInput`
 */
export type user_accepted_termsUpdateWithWhereUniqueWithoutUserInput = Prisma.user_accepted_termsUpdateWithWhereUniqueWithoutUserInput

/**
 * @deprecated Renamed to `Prisma.user_accepted_termsUpdateManyWithWhereWithoutUserInput`
 */
export type user_accepted_termsUpdateManyWithWhereWithoutUserInput = Prisma.user_accepted_termsUpdateManyWithWhereWithoutUserInput

/**
 * @deprecated Renamed to `Prisma.user_accepted_termsUpsertWithWhereUniqueWithoutUserInput`
 */
export type user_accepted_termsUpsertWithWhereUniqueWithoutUserInput = Prisma.user_accepted_termsUpsertWithWhereUniqueWithoutUserInput

/**
 * @deprecated Renamed to `Prisma.user_roleUpdateWithWhereUniqueWithoutUserInput`
 */
export type user_roleUpdateWithWhereUniqueWithoutUserInput = Prisma.user_roleUpdateWithWhereUniqueWithoutUserInput

/**
 * @deprecated Renamed to `Prisma.user_roleUpdateManyWithWhereWithoutUserInput`
 */
export type user_roleUpdateManyWithWhereWithoutUserInput = Prisma.user_roleUpdateManyWithWhereWithoutUserInput

/**
 * @deprecated Renamed to `Prisma.user_roleUpsertWithWhereUniqueWithoutUserInput`
 */
export type user_roleUpsertWithWhereUniqueWithoutUserInput = Prisma.user_roleUpsertWithWhereUniqueWithoutUserInput

/**
 * @deprecated Renamed to `Prisma.privacy_policyCreateWithoutUser_accepted_privacy_policyInput`
 */
export type privacy_policyCreateWithoutUser_accepted_privacy_policyInput = Prisma.privacy_policyCreateWithoutUser_accepted_privacy_policyInput

/**
 * @deprecated Renamed to `Prisma.privacy_policyCreateOrConnectWithoutuser_accepted_privacy_policyInput`
 */
export type privacy_policyCreateOrConnectWithoutuser_accepted_privacy_policyInput = Prisma.privacy_policyCreateOrConnectWithoutuser_accepted_privacy_policyInput

/**
 * @deprecated Renamed to `Prisma.userCreateWithoutUser_accepted_privacy_policyInput`
 */
export type userCreateWithoutUser_accepted_privacy_policyInput = Prisma.userCreateWithoutUser_accepted_privacy_policyInput

/**
 * @deprecated Renamed to `Prisma.userCreateOrConnectWithoutuser_accepted_privacy_policyInput`
 */
export type userCreateOrConnectWithoutuser_accepted_privacy_policyInput = Prisma.userCreateOrConnectWithoutuser_accepted_privacy_policyInput

/**
 * @deprecated Renamed to `Prisma.privacy_policyUpdateWithoutUser_accepted_privacy_policyInput`
 */
export type privacy_policyUpdateWithoutUser_accepted_privacy_policyInput = Prisma.privacy_policyUpdateWithoutUser_accepted_privacy_policyInput

/**
 * @deprecated Renamed to `Prisma.privacy_policyUpsertWithoutUser_accepted_privacy_policyInput`
 */
export type privacy_policyUpsertWithoutUser_accepted_privacy_policyInput = Prisma.privacy_policyUpsertWithoutUser_accepted_privacy_policyInput

/**
 * @deprecated Renamed to `Prisma.userUpdateWithoutUser_accepted_privacy_policyInput`
 */
export type userUpdateWithoutUser_accepted_privacy_policyInput = Prisma.userUpdateWithoutUser_accepted_privacy_policyInput

/**
 * @deprecated Renamed to `Prisma.userUpsertWithoutUser_accepted_privacy_policyInput`
 */
export type userUpsertWithoutUser_accepted_privacy_policyInput = Prisma.userUpsertWithoutUser_accepted_privacy_policyInput

/**
 * @deprecated Renamed to `Prisma.terms_and_conditionsCreateWithoutUser_accepted_termsInput`
 */
export type terms_and_conditionsCreateWithoutUser_accepted_termsInput = Prisma.terms_and_conditionsCreateWithoutUser_accepted_termsInput

/**
 * @deprecated Renamed to `Prisma.terms_and_conditionsCreateOrConnectWithoutuser_accepted_termsInput`
 */
export type terms_and_conditionsCreateOrConnectWithoutuser_accepted_termsInput = Prisma.terms_and_conditionsCreateOrConnectWithoutuser_accepted_termsInput

/**
 * @deprecated Renamed to `Prisma.userCreateWithoutUser_accepted_termsInput`
 */
export type userCreateWithoutUser_accepted_termsInput = Prisma.userCreateWithoutUser_accepted_termsInput

/**
 * @deprecated Renamed to `Prisma.userCreateOrConnectWithoutuser_accepted_termsInput`
 */
export type userCreateOrConnectWithoutuser_accepted_termsInput = Prisma.userCreateOrConnectWithoutuser_accepted_termsInput

/**
 * @deprecated Renamed to `Prisma.terms_and_conditionsUpdateWithoutUser_accepted_termsInput`
 */
export type terms_and_conditionsUpdateWithoutUser_accepted_termsInput = Prisma.terms_and_conditionsUpdateWithoutUser_accepted_termsInput

/**
 * @deprecated Renamed to `Prisma.terms_and_conditionsUpsertWithoutUser_accepted_termsInput`
 */
export type terms_and_conditionsUpsertWithoutUser_accepted_termsInput = Prisma.terms_and_conditionsUpsertWithoutUser_accepted_termsInput

/**
 * @deprecated Renamed to `Prisma.userUpdateWithoutUser_accepted_termsInput`
 */
export type userUpdateWithoutUser_accepted_termsInput = Prisma.userUpdateWithoutUser_accepted_termsInput

/**
 * @deprecated Renamed to `Prisma.userUpsertWithoutUser_accepted_termsInput`
 */
export type userUpsertWithoutUser_accepted_termsInput = Prisma.userUpsertWithoutUser_accepted_termsInput

/**
 * @deprecated Renamed to `Prisma.roleCreateWithoutUser_roleInput`
 */
export type roleCreateWithoutUser_roleInput = Prisma.roleCreateWithoutUser_roleInput

/**
 * @deprecated Renamed to `Prisma.roleCreateOrConnectWithoutuser_roleInput`
 */
export type roleCreateOrConnectWithoutuser_roleInput = Prisma.roleCreateOrConnectWithoutuser_roleInput

/**
 * @deprecated Renamed to `Prisma.userCreateWithoutUser_roleInput`
 */
export type userCreateWithoutUser_roleInput = Prisma.userCreateWithoutUser_roleInput

/**
 * @deprecated Renamed to `Prisma.userCreateOrConnectWithoutuser_roleInput`
 */
export type userCreateOrConnectWithoutuser_roleInput = Prisma.userCreateOrConnectWithoutuser_roleInput

/**
 * @deprecated Renamed to `Prisma.roleUpdateWithoutUser_roleInput`
 */
export type roleUpdateWithoutUser_roleInput = Prisma.roleUpdateWithoutUser_roleInput

/**
 * @deprecated Renamed to `Prisma.roleUpsertWithoutUser_roleInput`
 */
export type roleUpsertWithoutUser_roleInput = Prisma.roleUpsertWithoutUser_roleInput

/**
 * @deprecated Renamed to `Prisma.userUpdateWithoutUser_roleInput`
 */
export type userUpdateWithoutUser_roleInput = Prisma.userUpdateWithoutUser_roleInput

/**
 * @deprecated Renamed to `Prisma.userUpsertWithoutUser_roleInput`
 */
export type userUpsertWithoutUser_roleInput = Prisma.userUpsertWithoutUser_roleInput

/**
 * @deprecated Renamed to `Prisma.companyUpdateWithoutAddressInput`
 */
export type companyUpdateWithoutAddressInput = Prisma.companyUpdateWithoutAddressInput

/**
 * @deprecated Renamed to `Prisma.farmUpdateWithoutAddressInput`
 */
export type farmUpdateWithoutAddressInput = Prisma.farmUpdateWithoutAddressInput

/**
 * @deprecated Renamed to `Prisma.fieldUpdateWithoutAreaInput`
 */
export type fieldUpdateWithoutAreaInput = Prisma.fieldUpdateWithoutAreaInput

/**
 * @deprecated Renamed to `Prisma.quotationUpdateWithoutCompanyInput`
 */
export type quotationUpdateWithoutCompanyInput = Prisma.quotationUpdateWithoutCompanyInput

/**
 * @deprecated Renamed to `Prisma.diagnosisUpdateWithoutCropInput`
 */
export type diagnosisUpdateWithoutCropInput = Prisma.diagnosisUpdateWithoutCropInput

/**
 * @deprecated Renamed to `Prisma.infestationUpdateWithoutDiagnosisInput`
 */
export type infestationUpdateWithoutDiagnosisInput = Prisma.infestationUpdateWithoutDiagnosisInput

/**
 * @deprecated Renamed to `Prisma.prescriptionUpdateWithoutDiagnosisInput`
 */
export type prescriptionUpdateWithoutDiagnosisInput = Prisma.prescriptionUpdateWithoutDiagnosisInput

/**
 * @deprecated Renamed to `Prisma.areaUpdateWithoutFarmInput`
 */
export type areaUpdateWithoutFarmInput = Prisma.areaUpdateWithoutFarmInput

/**
 * @deprecated Renamed to `Prisma.imagingUpdateWithoutFarmInput`
 */
export type imagingUpdateWithoutFarmInput = Prisma.imagingUpdateWithoutFarmInput

/**
 * @deprecated Renamed to `Prisma.many_user_has_many_farmUpdateWithoutFarmInput`
 */
export type many_user_has_many_farmUpdateWithoutFarmInput = Prisma.many_user_has_many_farmUpdateWithoutFarmInput

/**
 * @deprecated Renamed to `Prisma.cropUpdateWithoutFieldInput`
 */
export type cropUpdateWithoutFieldInput = Prisma.cropUpdateWithoutFieldInput

/**
 * @deprecated Renamed to `Prisma.many_quotation_modal_package_has_many_fieldUpdateWithoutFieldInput`
 */
export type many_quotation_modal_package_has_many_fieldUpdateWithoutFieldInput = Prisma.many_quotation_modal_package_has_many_fieldUpdateWithoutFieldInput

/**
 * @deprecated Renamed to `Prisma.infestationUpdateWithoutPlagueInput`
 */
export type infestationUpdateWithoutPlagueInput = Prisma.infestationUpdateWithoutPlagueInput

/**
 * @deprecated Renamed to `Prisma.user_accepted_privacy_policyUpdateWithoutPrivacy_policyInput`
 */
export type user_accepted_privacy_policyUpdateWithoutPrivacy_policyInput = Prisma.user_accepted_privacy_policyUpdateWithoutPrivacy_policyInput

/**
 * @deprecated Renamed to `Prisma.many_quotation_modal_package_has_many_fieldUpdateWithoutQuotation_modal_packageInput`
 */
export type many_quotation_modal_package_has_many_fieldUpdateWithoutQuotation_modal_packageInput = Prisma.many_quotation_modal_package_has_many_fieldUpdateWithoutQuotation_modal_packageInput

/**
 * @deprecated Renamed to `Prisma.quotationUpdateWithoutQuotation_modal_packageInput`
 */
export type quotationUpdateWithoutQuotation_modal_packageInput = Prisma.quotationUpdateWithoutQuotation_modal_packageInput

/**
 * @deprecated Renamed to `Prisma.quotation_modal_packageUpdateWithoutQuotation_packageInput`
 */
export type quotation_modal_packageUpdateWithoutQuotation_packageInput = Prisma.quotation_modal_packageUpdateWithoutQuotation_packageInput

/**
 * @deprecated Renamed to `Prisma.user_roleUpdateWithoutRoleInput`
 */
export type user_roleUpdateWithoutRoleInput = Prisma.user_roleUpdateWithoutRoleInput

/**
 * @deprecated Renamed to `Prisma.addressUpdateWithoutStateInput`
 */
export type addressUpdateWithoutStateInput = Prisma.addressUpdateWithoutStateInput

/**
 * @deprecated Renamed to `Prisma.user_accepted_termsUpdateWithoutTerms_and_conditionsInput`
 */
export type user_accepted_termsUpdateWithoutTerms_and_conditionsInput = Prisma.user_accepted_termsUpdateWithoutTerms_and_conditionsInput

/**
 * @deprecated Renamed to `Prisma.many_user_has_many_farmUpdateWithoutUserInput`
 */
export type many_user_has_many_farmUpdateWithoutUserInput = Prisma.many_user_has_many_farmUpdateWithoutUserInput

/**
 * @deprecated Renamed to `Prisma.notificationUpdateWithoutUserInput`
 */
export type notificationUpdateWithoutUserInput = Prisma.notificationUpdateWithoutUserInput

/**
 * @deprecated Renamed to `Prisma.user_accepted_privacy_policyUpdateWithoutUserInput`
 */
export type user_accepted_privacy_policyUpdateWithoutUserInput = Prisma.user_accepted_privacy_policyUpdateWithoutUserInput

/**
 * @deprecated Renamed to `Prisma.user_accepted_termsUpdateWithoutUserInput`
 */
export type user_accepted_termsUpdateWithoutUserInput = Prisma.user_accepted_termsUpdateWithoutUserInput

/**
 * @deprecated Renamed to `Prisma.user_roleUpdateWithoutUserInput`
 */
export type user_roleUpdateWithoutUserInput = Prisma.user_roleUpdateWithoutUserInput